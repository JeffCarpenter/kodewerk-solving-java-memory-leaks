START
ftp://ftp.ora.com/pub/examples/java/javapt/technique-list.html
A long list of most of the tuning techniques covered in my "Java Performance Tuning" book
(Page last updated August 2000, Added 2000-10-23, Author Jack Shirazi, Publisher O'Reilly).
1
<! CTGRY everything ><LI>[Since the referred to page is already a summary list, I have not extracted it here. Especially since there are nearly 300 techniques listed. Check the page out directly].
START
http://www.oreilly.com/catalog/javapt/chapter/ch04.html
Chapter 4 of "Java Performance Tuning", "Object Creation".
(Page last updated September 2000, Added 2000-10-23, Author Jack Shirazi, Publisher O'Reilly).
31
<! CTGRY profiling object_creation heap_and_memory_and_garbage_collection ><LI>Establish whether you have a memory problem.
<! CTGRY object_creation heap_and_memory_and_garbage_collection loops ><LI>Reduce the number of temporary objects being used, especially in loops.
<! CTGRY object_creation heap_and_memory_and_garbage_collection ><LI>Avoid creating temporary objects within frequently called methods.
<! CTGRY object_creation collections ><LI>Presize collection objects.
<! CTGRY object_creation heap_and_memory_and_garbage_collection ><LI>Reuse objects where possible.
<! CTGRY object_creation heap_and_memory_and_garbage_collection collections ><LI>Empty collection objects before reusing them. (Do not shrink them unless they are very large.)
<! CTGRY object_creation heap_and_memory_and_garbage_collection conversion ><LI>Use custom conversion methods for converting between data types (especially strings and streams) to reduce the number of temporary objects.
<! CTGRY object_creation heap_and_memory_and_garbage_collection analysis_and_design a_d:methd a_d:objects ><LI>Define methods that accept reusable objects to be filled in with data, rather than methods that return objects holding that data. (Or you can return immutable objects.)
<! CTGRY object_creation heap_and_memory_and_garbage_collection analysis_and_design a_d:objects ><LI>Canonicalize objects wherever possible. Compare canonicalized objects by identity. [Canonicalizing objects means having only a single reference of an object, with no copies possible].
<! CTGRY object_creation heap_and_memory_and_garbage_collection analysis_and_design a_d:objects ><LI>Create only the number of objects a class logically needs (if that is a small number of objects).
<! CTGRY object_creation heap_and_memory_and_garbage_collection analysis_and_design a_d:objects ><LI>Replace strings and other objects with integer constants. Compare these integers by identity.
<! CTGRY object_creation heap_and_memory_and_garbage_collection ><LI>Use primitive data types instead of objects as instance variables.
<! CTGRY object_creation heap_and_memory_and_garbage_collection ><LI>Avoid creating an object that is only for accessing a method.
<! CTGRY object_creation heap_and_memory_and_garbage_collection ><LI>Flatten objects to reduce the number of nested objects.
<! CTGRY object_creation heap_and_memory_and_garbage_collection collections ><LI>Preallocate storage for large collections of objects by mapping the instance variables into multiple arrays.
<! CTGRY object_creation heap_and_memory_and_garbage_collection java.lang.StringBuffer java.lang.String><LI>Use <CODE>StringBuffer</CODE> rather than the string concatenation operator (+).
<! CTGRY object_creation heap_and_memory_and_garbage_collection analysis_and_design a_d:methd a_d:objects ><LI>Use methods that alter objects directly without making copies.
<! CTGRY object_creation heap_and_memory_and_garbage_collection wrapping analysis_and_design a_d:class ><LI>Create or use specific classes that handle primitive data types rather than wrapping the primitive data types.
<! CTGRY object_creation heap_and_memory_and_garbage_collection java.lang.ThreadLocal threading ><LI>Consider using a <CODE>ThreadLocal</CODE> to provide threaded access to singletons with state.
<! CTGRY object_creation heap_and_memory_and_garbage_collection finalkey ><LI>Use the <CODE>final</CODE> modifier on instance-variable definitions to create immutable internally accessible objects.
<! CTGRY object_creation heap_and_memory_and_garbage_collection java.lang.ref.WeakReference java.lang.ref.Reference java.lang.ref.SoftReference ><LI>Use <CODE>WeakReference</CODE>s to hold elements in large canonical lookup tables. (Use <CODE>SoftReference</CODE>s for cache elements.)
<! CTGRY object_creation heap_and_memory_and_garbage_collection ><LI>Reduce object-creation bottlenecks by targeting the object-creation process.
<! CTGRY object_creation heap_and_memory_and_garbage_collection analysis_and_design a_d:class a_d:methd ><LI>Keep constructors simple and inheritance hierarchies shallow.
<! CTGRY object_creation heap_and_memory_and_garbage_collection ><LI>Avoid initializing instance variables more than once.
<! CTGRY object_creation heap_and_memory_and_garbage_collection ><LI>Use the <CODE>clone()</CODE> method to avoid calling any constructors.
<! CTGRY object_creation heap_and_memory_and_garbage_collection collections ><LI>Clone arrays if that makes their creation faster.
<! CTGRY object_creation heap_and_memory_and_garbage_collection collections ><LI>Create copies of simple arrays faster by initializing them; create copies of complex arrays faster by cloning them.
<! CTGRY object_creation heap_and_memory_and_garbage_collection analysis_and_design a_d:objects ><LI>Eliminate object-creation bottlenecks by moving object creation to an alternative time.
<! CTGRY object_creation heap_and_memory_and_garbage_collection analysis_and_design a_d:objects ><LI>Create objects early, when there is spare time in the application, and hold those objects until required.
<! CTGRY object_creation heap_and_memory_and_garbage_collection analysis_and_design a_d:objects ><LI>Use lazy initialization when there are objects or variables that may never be used, or when you need to distribute the load of creating objects.
<! CTGRY object_creation heap_and_memory_and_garbage_collection analysis_and_design a_d:objects ><LI>Use lazy initialization only when there is a defined merit in the design, or when identifying a bottleneck which is alleviated using lazy initialization.
START
http://java.oreilly.com/news/javaperf_0900.html
My article on basic optimizations for queries on collections
(Page last updated September 2000, Added 2000-10-23, Author Jack Shirazi, Publisher O'Reilly).
8
<! CTGRY collections loops ><LI>Use short-circuit boolean operators instead of the normal boolean operators.
<! CTGRY collections loops ><LI>Eliminate any unnecessarily repeated method calls from loops.
<! CTGRY collections loops casting ><LI>Eliminate unnecessary casts.
<! CTGRY collections synchronization ><LI>Avoid synchronization where possible.
<! CTGRY collections loops ><LI>Avoid method calls by implementing queries in a subclass, allowing direct field access.
<! CTGRY collections ><LI>Use temporary local variables to manipulate data fields (instance/class variables).
<! CTGRY collections ><LI>Use more precise object typing where possible.
<! CTGRY collections JVM ><LI>Before manual tuning, HotSpot VMs are often faster than JIT VMs. But JIT VMs tend to benefit more from manual tuning and can end up faster than HotSpot VMs.
START
http://www.cs.cmu.edu/~jch/java/optimization.html
For years, Jonathan Hardwick's old but classic site was the only coherent Java performance tuning site on the web. He built it while doing his PhD. It wasn't updated beyond March 1998, when he moved to Microsoft, but most tips are still useful and valid. The URL is for the top page, there are another eight pages. Thanks Jonathan.
(Page last updated March 1998, Added 2000-10-23, Author Jonathan Hardwick, Publisher Hardwick).
34
<! CTGRY management management_and_strategy_and_tactics analysis_and_design a_d:non ><LI>Don't optimize as you go. Write your program concentrating on clean, correct, and understandable code.
<! CTGRY profiling testing_profiling_measuring_benchmarking ><LI>Use profiling to find out where that 80% of execution time is going, so you know where to concentrate your effort.
<! CTGRY profiling testing_profiling_measuring_benchmarking ><LI>Always run "before" and "after" benchmarks.
<! CTGRY algorithms structures ><LI>Use the right algorithms and data structures.
<! CTGRY compiling ><LI>Compile with optimization flag, javac -O. 
<! CTGRY JVM ><LI>Use a JIT.
<! CTGRY threading ><LI>Multithread for multi-processor machines.
<! CTGRY animation ><LI>Use clipping to reduce the amount of work done in repaint()
<! CTGRY animation ><LI>Use double buffering to improve perceived speed.
<! CTGRY animation applet startuptime ><LI>Use image strips or compression to speed up downloading times.
<! CTGRY animation ><LI><A HREF="http://www.javaworld.com/javaworld/jw-03-1996/jw-03-animation.html">Animation in Java Applets</A> from JavaWorld and <A HREF="http://java.sun.com/books/Series/Tutorial/ui/drawing/animation.html">Performing Animation</A> from Sun are two good tutorials.
<! CTGRY animation ><LI>Use high-level primitives; it's much faster to call drawPolygon() on a bunch of points than looping with drawLine().
<! CTGRY animation ><LI>If you have to draw a single pixel drawLine (x,y,x,y) may be faster than fillRect (x,y,1,1).
<! CTGRY IO ><LI>Use Buffered I/O classes.
<! CTGRY synchronization ><LI>Avoid synchronized methods if you can.
<! CTGRY synchronization ><LI>Synchronizing on methods rather than on code blocks is slightly faster.
<! CTGRY exceptions ><LI>Use exceptions only where you really need them.
<! CTGRY strings conversion><LI>Use StringBuffer instead of +.
<! CTGRY loops ><LI>Use System.arraycopy() and any other optimized API's available from the SDK.
<! CTGRY management_and_strategy_and_tactics analysis_and_design a_d:class ><LI>Replace the generic standard classes with faster implementations specific to the application.
<! CTGRY management_and_strategy_and_tactics ><LI>Create subclasses to override methods with faster versions.
<! CTGRY structures analysis_and_design a_d:class ><LI>Avoid expensive constructs and data structures, e.g. one-dimensional array is faster than a two-dimensional array.
<! CTGRY bytecode_disassembling ><LI>Use the faster switch bytecode.
<! CTGRY compiling finalkey ><LI>Use private and static methods, and final classes, to encourage inlining by the compiler.
<! CTGRY object_creation heap_and_memory_and_garbage_collection ><LI>Reuse objects.
<! CTGRY variables ><LI>Local variables are the faster than instance variables, which are in turn faster than array elements.
<! CTGRY variables ><LI>ints are the fastest data type.
<! CTGRY compiling ><LI>Compiler optimizations: loop invariant code motion; common subexpression elimination; strength reduction; variable allocation reassignment.
<! CTGRY profiling testing_profiling_measuring_benchmarking ><LI>Use java -prof or other profiler.
<! CTGRY profiling management testing_profiling_measuring_benchmarking ><LI>Use a timing harness to run benchmarks.
<! CTGRY profiling management testing_profiling_measuring_benchmarking ><LI>Use a memory measurement harness to run benchmarks.
<! CTGRY profiling heap_and_memory_and_garbage_collection ><LI>Call system.gc() before every timing run to minimize inconsistent results due to garbage collection in the middle of a run.
<! CTGRY startuptime size IO ><LI>Use JAR or zip files.
<! CTGRY j2me size ><LI>If size is a constraint: use SDK classes wherever possible; inherit whatever possible; put common code in one place; initialize big arrays at runtime by parsing a string; use short names; 
START
http://www.glenmccl.com/jperf/
Glen McCluskey's paper with 30 tuning tips, now free.
(Page last updated October 1999, Added 2000-10-23, Author Glen McCluskey, Publisher McCluskey).
32
<! CTGRY algorithms ><LI>Faster algorithms are better.
<! CTGRY management analysis_and_design a_d:non ><LI>Different architectures can be functionally identical but perform very differently. Keep performance in mind at the design stage.
<! CTGRY JVM ><LI>Use the fastest available JVM.
<! CTGRY analysis_and_design a_d:class a_d:mmry object_creation ><LI>Use static variables for fields that only need to be assigned once.
<! CTGRY object_creation ><LI>Reuse objects where reasonable, e.g. nodes of a linked list.
<! CTGRY compiling ><LI>Inline methods manually where appropriate. [Better to use a preprocessor].
<! CTGRY compiling ><LI>Keep methods short and simple to make them automatic inlining candidates.
<! CTGRY compiling finalkey ><LI><CODE>final</CODE> classes can be faster.
<! CTGRY synchronization ><LI>Synchronized methods are slower than the identical non-synchronized one.
<! CTGRY synchronization wrapping ><LI>Consider using non-synchronized classes and synchronized-wrappers.
<! CTGRY inner_classes ><LI>Access to private members of inner classes from the enclosing class goes by a method call even if not intended to.
<! CTGRY strings conversion ><LI>Use StringBuffer instead of the '+' String concatentation operator.
<! CTGRY strings conversion ><LI>Use <CODE>char[]</CODE> arrays directly to create Strings rather than StringBuffers.
<! CTGRY strings algorithms ><LI>'==' is faster than equals().
<! CTGRY strings ><LI>intern() Strings to enable identity (==) comparisons.
<! CTGRY strings conversion ><LI>Convert strings to char[] arrays to process characters, rather than accessing characters one at a time using String.charAt().
<! CTGRY strings conversion ><LI>Creating Doubles from strings is slow.
<! CTGRY IO ><LI>Buffer i/o.
<! CTGRY strings conversion ><LI>MessageFormat is slow.
<! CTGRY object_creation ><LI>Reuse objects.
<! CTGRY IO ><LI>File information such as File.length() requires a system call and can be slow.
<! CTGRY collections ><LI>Use System.arraycopy() to copy arrays.
<! CTGRY collections ><LI>ArrayList is faster than Vector.
<! CTGRY collections ><LI>Preset array capacity to as large as will be required.
<! CTGRY collections ><LI>LinkedList is faster than ArrayList for inserting elements to the front of the array, but slower at indexed lookup.
<! CTGRY analysis_and_design a_d:class ><LI>Program using interfaces so that the actual structure can be easily swapped to improve performance.
<! CTGRY compiling ><LI>Use the -g:none option to the javac compiler.
<! CTGRY wrapping ><LI>Primitive data wrapper classes (e.g. Integer) are slower than using the primitive data directly.
<! CTGRY heap_and_memory_and_garbage_collection ><LI>Null out references when they are no longer used so that garbage collection can reclaim their space.
<! CTGRY heap_and_memory_and_garbage_collection ><LI>Use SoftReferences to recycle memory when required.
<! CTGRY heap_and_memory_and_garbage_collection size ><LI>BitSets have deterministic memory requirements where boolean arrays do not (booleans are implemented as bytes rather than bits in some JVMs).
<! CTGRY size ><LI>Use sparse arrays to hold widely spaced indexable data.
START
http://www.sun.com/solaris/java/wp-java/6.html
Performance tuning part of a white paper about Java on Solaris 2.6.
(Page last updated 2000, Added 2000-10-23, Author ?, Publisher Sun).
32
<! CTGRY profiling IO testing_profiling_measuring_benchmarking ><LI>To profile I/O calls, use a profiler or use truss and look for read() and write() system calls.
<! CTGRY IO size ><LI>Buffer I/O. Tune the buffer size (bigger is usually better if memory is available).
<! CTGRY loops strings ><LI>Use char arrays for all character processing in loops, rather than using the String or StringBuffer classes.
<! CTGRY loops strings ><LI>Avoid character processing using methods (e.g. charAt(), setCharAt()) inside a loop.
<! CTGRY collections strings ><LI>Set the initial StringBuffer size to the maximum string length, if it is known.
<! CTGRY strings ><LI>StringTokenizer is very inefficient, and can be optimized by storing the string and delimiter in a character array instead of in String, or by storing the highest delimiter character to allow a quicker check.
<! CTGRY collections ><LI>Accessing arrays is much faster than accessing vectors, String, and StringBuffer.
<! CTGRY collections ><LI>Use System.arraycopy() to improve performance.
<! CTGRY collections ><LI>Vector is convenient to use, but inefficient. Ensure that elementAt() is not used inside a loop.
<! CTGRY synchronization collections ><LI>FastVector is faster than Vector by making the elementData field public, thus avoiding (synchronized) calls to elementAt().
<! CTGRY animation ><LI>Use double buffering and override update() to improve screen painting and drawing.
<! CTGRY animation ><LI>Use custom LayoutManagers.
<! CTGRY animation ><LI>Repaint only the damaged regions (use ClipRect).
<! CTGRY animation ><LI>To improve image handling: use MediaTracker; use your own imageUpdate() method; pre-decode and store the image in an array - image decoding time is greater than loading time. Pre-decoding using PixelGrabber and MemoryImageSource should combine multiple images into one file for maximum speed.
<! CTGRY heap_and_memory_and_garbage_collection ><LI>Increase the initial heap size from the 1-MByte default with -ms and -mx [-Xms and -Xmx].
<! CTGRY heap_and_memory_and_garbage_collection ><LI>Use -verbosegc.
<! CTGRY size collections ><LI>Take size into account when allocating arrays (for instance, if short is big enough, use it instead of int.
<! CTGRY loops object_creation ><LI>Avoid allocating objects in loops (readLine() is a common example).
<! CTGRY synchronization ><LI>Minimize synchronization.
<! CTGRY synchronization IO ><LI>Polling is only acceptable when waiting for outside events and should be performed in a "side" thread. Use wait/notify instead.
<! CTGRY loops ><LI>Move loop invariants outside the loop.
<! CTGRY profiling loops ><LI>Make tests as simple as possible.
<! CTGRY loops ><LI>Perform the loop backwards (this actually performs slightly faster than forward loops do). [Actually it is converting the test to compare against 0 that makes the difference].
<! CTGRY loops variables ><LI>Use only local variables inside a loop; assign class fields to local variables before the loop.
<! CTGRY loops ><LI>Move constant conditionals outside loops.
<! CTGRY loops ><LI>Combine similar loops.
<! CTGRY loops ><LI>Nest the busiest loop, if loops are interchangeable.
<! CTGRY loops ><LI>Unroll the loop, as a last resort.
<! CTGRY loops ><LI>Convert expressions to table Lookups.
<! CTGRY caching ><LI>Use caching.
<! CTGRY caching ><LI>Pre-compute values or delay evaluation to shift calculation cost to another time.
<! CTGRY profiling testing_profiling_measuring_benchmarking ><LI>[Also gives information on using Solaris Trace Normal Format (TNF) utilities for profiling java applications].
START
http://www.patrick.net/jpt/index.html
Patrick Killelea's Java performance tips.
(Page last updated 1999, Added 2000-10-23, Author Patrick Killelea, Publisher Killelea).
41
<! CTGRY profiling testing_profiling_measuring_benchmarking ><LI>System.currentTimeMillis may take up to 0.5 milliseconds to execute.
<! CTGRY profiling algorithms analysis_and_design a_d:bttlnck ><LI>The architecture and algorithms of your program are much more important than any low-level optimizations you might perform.
<! CTGRY profiling management_and_strategy_and_tactics ><LI>Tune at the highest level first.
<! CTGRY management_and_strategy_and_tactics ><LI>Make the common case fast (Amdahl's advice).
<! CTGRY management_and_strategy_and_tactics ><LI>Use what you know about the runtime platform or usage patterns.
<! CTGRY profiling management_and_strategy_and_tactics ><LI>Look at a supposedly quiet system to see if it's wasting time even when there's no input.
<! CTGRY analysis_and_design a_d:class ><LI>Keep small inheritance chains.
<! CTGRY variables ><LI>Use stack (local) variables in preference to class variables.
<! CTGRY management_and_strategy_and_tactics analysis_and_design a_d:class ><LI>Merge classes.
<! CTGRY animation ><LI>drawPolygon() is faster than using drawLine() repeatedly. 
<! CTGRY object_creation ><LI>Don't create too may objects.
<! CTGRY object_creation heap_and_memory_and_garbage_collection ><LI>Reuse objects if possible.
<! CTGRY heap_and_memory_and_garbage_collection ><LI>Beware of object leaks (references to objects that are never nulled).
<! CTGRY analysis_and_design a_d:methd ><LI>Accessor methods increase overhead.
<! CTGRY bytecode_disassembling loops ><LI>Compound operators such as n += 4; are faster than n = n + 4; because fewer bytecodes are generated.
<! CTGRY bytecode_disassembling loops ><LI>Shifting by powers of two is faster than multiplying.
<! CTGRY bytecode_disassembling loops ><LI>Multiplication is faster than exponentiation.
<! CTGRY bytecode_disassembling variables loops ><LI>int increments are faster than byte or short increments.
<! CTGRY bytecode_disassembling variables loops ><LI>Floating point increments are much slower than any integral increment.
<! CTGRY bytecode_disassembling variables loops ><LI>Memory access from better to worse: local vars; supersuperclass instance variable; superclass instance var; class instance var; class static var; array elements.
<! CTGRY bytecode_disassembling variables loops ><LI>It can help to copy slower-access vars to fast local vars if you are going to operate on them repeatedly, as in a loop.
<! CTGRY distributed IO ><LI>Use networking timeouts, TCP_NODELAY, SO_TIMEOUT, especially in case of dying DNS servers.
<! CTGRY distributed IO ><LI>Buffer network io. [or read explicitly in chunks].
<! CTGRY distributed IO ><LI>Avoid reverse DNS where you can.
<! CTGRY distributed IO analysis_and_design a_d:distrib ><LI>Use UDP rather than TCP if speed is more important than accuracy.
<! CTGRY synchronization threading analysis_and_design a_d:threads ><LI>Use threads. Prioritize threads. Use notify instead of notifyAll. Use synchronization sparingly.
<! CTGRY bytecode_disassembling loops ><LI>Counting down is often faster than counting up. [the loop test comparison to 0 is what matters].
<! CTGRY synchronization loops ><LI>Keep synchronized methods out of loops if you possibly can.
<! CTGRY strings ><LI>Avoid excessive String manipulation.
<! CTGRY strings ><LI>Use String Buffers or Arrays rather than String.
<! CTGRY strings ><LI>byte arrays may be faster than StringBuffers for certain operations, especially if you use System.arraycopy(). 
<! CTGRY strings ><LI>Use StringBuffer rather than the + operator.
<! CTGRY animation ><LI>Watch out for slow fonts, Fonts vary in speed of rendering.
<! CTGRY animation analysis_and_design a_d:anim ><LI>Keep the paint method small. It will get called a lot. 
<! CTGRY animation ><LI>Double buffer where possible.
<! CTGRY conversion ><LI>For some applications that access the date a lot, it can help to set the local timezone to be GMT, so that no conversion has to take place.
<! CTGRY bytecode_disassembling loops ><LI>Potential compiler optimizations: loop invariant code motion; common subexpression elimination; strength reduction; variable allocation.
<! CTGRY threading ><LI>Don't turn off native threads.
<! CTGRY size startuptime applet ><LI>Use .jar files.
<! CTGRY synchronization size object_creation ><LI>Rewrite Java library classes to make them smaller or instantiate fewer objects or eliminate synchronization.
<! CTGRY applet ><LI>Install classes locally.
START
http://www.devresource.hp.com/JavaATC/JavaPerfTune/index.html
HP Java tuning site, including optimizing Java and optimizing HPUX for Java. This is the top page, but several useful pages lie off it (tips extracted for inclusion below). Includes a nice "procedure" list for tuning apps, and some useful forms for what you should record while tuning.
(Page last updated 2000, Added 2000-10-23, Author ?, Publisher HP).
19
<! CTGRY management profiling management_and_strategy_and_tactics testing_profiling_measuring_benchmarking ><LI>Have a performance target.
<! CTGRY profiling management_and_strategy_and_tactics analysis_and_design a_d:non ><LI>Consider architecture and components for bottlenecks.
<! CTGRY profiling management_and_strategy_and_tactics testing_profiling_measuring_benchmarking analysis_and_design a_d:bttlnck ><LI>Third-party components may have options that cause bottlenecks.
<! CTGRY profiling testing_profiling_measuring_benchmarking ><LI>Having debugging turned on can cause performance problems.
<! CTGRY profiling testing_profiling_measuring_benchmarking ><LI>Having logging turned on can cause performance problems.
<! CTGRY profiling management_and_strategy_and_tactics testing_profiling_measuring_benchmarking ><LI>Is the underlying machine powerful enough.
<! CTGRY profiling management_and_strategy_and_tactics testing_profiling_measuring_benchmarking ><LI>Carefully document any tests and changes.
<! CTGRY profiling management_and_strategy_and_tactics testing_profiling_measuring_benchmarking ><LI>Create a performance baseline.
<! CTGRY profiling management_and_strategy_and_tactics ><LI>Make one change at a time.
<! CTGRY profiling management_and_strategy_and_tactics ><LI>Be careful not to lose a winning tune because it's hidden by a bad tune made at the same time.
<! CTGRY profiling management_and_strategy_and_tactics testing_profiling_measuring_benchmarking ><LI>Record all aspects of the system (app/component/version/version date/dependent software/CPU/Numbers of CPUs/RAM/Disk space/patches/OS config/etc.)
<! CTGRY JVM management_and_strategy_and_tactics testing_profiling_measuring_benchmarking JVM ><LI>Give the JVMs top system priority.
<! CTGRY JVM heap_and_memory_and_garbage_collection ><LI>Tune the heap size (-mx, -ms options) and use -verbosegc to minimize garbage collection impact. A larger heap reduces the frequency of garbage collection but increases the length of time that any particular garbage collection takes.
<! CTGRY JVM heap_and_memory_and_garbage_collection ><LI>Rules of thumbs are: 50% of free space available after a gc; set the maximum heap size to be 3-4 times the space required for the estimated maximum number of live objects; set the initial heap to size a little below the space required for the average data set, and the maximum value large enough to handle the largest data set; increase -Xmn for applications that create many short-lived objects [is -Xmn a standard option?]. [These rules of thumb should only be considered as starting points. Ultimately you need to tune the VM heap empirically, i.e. by trial and error].
<! CTGRY management_and_strategy_and_tactics testing_profiling_measuring_benchmarking JVM heap_and_memory_and_garbage_collection ><LI>You may need to add flags to third party products running in the JVM to eliminate explicit calls to garbage collect (VisiBroker has this known problem).
<! CTGRY profiling management_and_strategy_and_tactics testing_profiling_measuring_benchmarking JVM heap_and_memory_and_garbage_collection analysis_and_design a_d:bttlnck ><LI>Watch out for bottlenecks introduced from third party products. Make sure you know and use the options available, many of which can affect performance (for better or worse). Document the changes you make so that you will be able to reproduce the performance.
<! CTGRY profiling management_and_strategy_and_tactics load_balancing scaling analysis_and_design a_d:predict a_d:ldbalnc ><LI>computationally intensive applications should increase the number of CPUs to increase overall system performance and throughput.
<! CTGRY profiling management_and_strategy_and_tactics testing_profiling_measuring_benchmarking heap_and_memory_and_garbage_collection synchronization ><LI>Be certain that the application's CPU usage is a factor limiting performance: often, highly contended locks and garbage collections that are too frequent will make the system look busy, but little work is done by the application.
<! CTGRY profiling management_and_strategy_and_tactics testing_profiling_measuring_benchmarking ><LI>[Some nice detailed description on how to profile and analyze application problems, from the HP system and JVM level at <A HREF="http://www.devresource.hp.com/JavaATC/JavaPerfTune/symptoms_solutions.html">http://www.devresource.hp.com/JavaATC/JavaPerfTune/symptoms_solutions.html</A>.]
START
http://developer.java.sun.com/developer/technicalArticles/Programming/PerfTuning/
Glen McCluskey's article on tuning Java I/O performance. Weak on serialization tuning.
(Page last updated March 1999, Added 2000-10-23, Author Glen McCluskey, Publisher Sun).
13
<! CTGRY IO ><LI>Avoid accessing the disk.
<! CTGRY IO ><LI>Avoid accessing the underlying operating system. 
<! CTGRY IO ><LI>Avoid method calls. 
<! CTGRY IO ><LI>Avoid processing bytes and characters individually. 
<! CTGRY IO ><LI>Use buffering either at the class level or at the array level.
<! CTGRY IO ><LI>Disable line buffering.
<! CTGRY IO ><LI>MessageFormat is slow.
<! CTGRY IO object_creation ><LI>Reuse objects.
<! CTGRY IO java.io.RandomAccessFile ><LI>Creating a buffered RandomAccessFile class can be faster than plain RandomAccessFile if you are seeking alot.
<! CTGRY IO ><LI>Compression can help I/O, but only sometimes.
<! CTGRY IO caching ><LI>Use caching to speed I/O.
<! CTGRY IO java.io.StreamTokenizer ><LI>Your own tokenizer will be faster than using the available SDK tokenizer.
<! CTGRY IO java.io.File ><LI>Many java.io.File methods are system calls which can be slow.
START
http://www.javaworld.com/javaworld/jw-09-1996/jw-09-indepth.html
Article about avoiding creating objects where possible.
(Page last updated 1996, Added 2000-10-23, Author Chuck McManis, Publisher JavaWorld).
4
<! CTGRY algorithms heap_and_memory_and_garbage_collection object_creation ><LI>"The mythology surrounding the slowness of garbage-collected systems is just that, myth. I can show that the number of instructions executed is the same whether I call malloc() and free() or I only call malloc() and some other code calls free()."
<! CTGRY heap_and_memory_and_garbage_collection object_creation analysis_and_design a_d:threads ><LI>Simple designs can easily run through many unnecessary objects, e.g. data wrapper objects like Integer.
<! CTGRY heap_and_memory_and_garbage_collection object_creation ><LI>Reuse objects where possible.
<! CTGRY profiling heap_and_memory_and_garbage_collection object_creation ><LI>Use -verbosegc to check the impact of garbage collection on your application.
START
http://www.unixsolutions.hp.com/products/java/perf.html
A different HP tip page on optimizing Java performance, from the "HP-UX Programmer's Guide for Java". Gives info on HP system performance monitoring too
(Page last updated ?, Added 2000-10-23, Author ?, Publisher HP).
9
<! CTGRY threading analysis_and_design a_d:threads ><LI>Maximize thread lifetimes and minimize thread creation/destruction cycles.
<! CTGRY synchronization multiuser analysis_and_design a_d:shared ><LI>Minimize contention for shared resources.
<! CTGRY object_creation heap_and_memory_and_garbage_collection ><LI>Minimize creation of short-lived objects.
<! CTGRY profiling heap_and_memory_and_garbage_collection ><LI>Use -verbosegc to monitor garbage collection. Tune the applications to minimize the effects of garbage collections.
<! CTGRY IO ><LI>Disk I/O should be minimized. Don't do random I/O to read a file serially (RandomAccessFile class). You should use buffered I/O.
<! CTGRY animation analysis_and_design a_d:anim ><LI>Complex AWT graphics will slow down your performance.
<! CTGRY JVM ><LI>Use the most current version of Java.
<! CTGRY heap_and_memory_and_garbage_collection ><LI>Use -mx and -ms to tune the heap size [now -Xms and -Xmx].
<! CTGRY profiling testing_profiling_measuring_benchmarking ><LI>Profile the code to find bottlenecks.
START
http://www.artima.com/designtechniques/hotspot.html
Bill Venners on "the right way to optimize"
(Page last updated May 1998, Added 2000-10-23, Author Bill Venners, Publisher Artima).
9
<! CTGRY management profiling management_and_strategy_and_tactics ><LI>Don't optimize until you know you have a problem.
<! CTGRY management profiling management_and_strategy_and_tactics ><LI>Measure the program before and after your optimization efforts.
<! CTGRY profiling management_and_strategy_and_tactics testing_profiling_measuring_benchmarking ><LI>Profile the program to isolate the code that really matters to performance (10 to 20 percent), and just focus your optimization efforts there.
<! CTGRY management_and_strategy_and_tactics algorithms ><LI>Try to devise a better algorithm
<! CTGRY management_and_strategy_and_tactics ><LI>Use APIs in a smarter way
<! CTGRY management_and_strategy_and_tactics loops bytecode_disassembling ><LI>Use standard code optimization techniques such as strength reduction, common sub-expression elimination, code motion, and loop unrolling.
<! CTGRY management_and_strategy_and_tactics analysis_and_design a_d:non ><LI>Only as a last resort should you sacrifice good object-oriented, thread-safe design and maintainable code in the name of performance.
<! CTGRY management_and_strategy_and_tactics variables ><LI>Make methods static wherever possible.
<! CTGRY management_and_strategy_and_tactics object_creation heap_and_memory_and_garbage_collection ><LI>Avoid creating lots of short-lived objects
START
http://jsl.jcon.org/javaperformance.html
An assortment of tips
(Page last updated 2000, Added 2000-10-23, Author Curt Smith, Publisher Smith).
48
<! CTGRY ><LI>Use the Java compiler’s optimization flag (javac -O)
<! CTGRY profiling ><LI>Profile the application (using -prof) & re-code the methods that are taking the longest.
<! CTGRY ><LI>Avoid repeatedly instantiating exceptions. Reuse exceptions in preference.
<! CTGRY ><LI>Move common subexpressions to one execution.
<! CTGRY ><LI>Eliminate casts, or reduce the number of casts being made.
<! CTGRY ><LI>Method local variables are faster than Class variables
<! CTGRY finalkey ><LI>Declare method arguments final if they are not modified in the method. In general declare all variables final if they are not modified after being initialized or set to some value.
<! CTGRY finalkey ><LI>Declare methods private and/or final whenever that makes sense. This can help the compiler inline methods. [final methods are of dubious value]
<! CTGRY ><LI>Buffer i/o. Use BufferedReaders.
<! CTGRY ><LI>DON’T create static strings via new().
<! CTGRY ><LI>Use String.intern() to reduce the number of strings in your runtime. [but this is an expensive operation]
<! CTGRY ><LI>Use char[] arrays for all character processing in loops, rather than using the String or StringBuffer classes.
<! CTGRY ><LI>StringBuffer default size is 16 chars. Set this to the maximum expected string length.
<! CTGRY ><LI>StringTokenizer is inefficient. It can be optimized by storing the string and delimiter in a character array instead of in a String, or by storing the highest delimiter character to allow a quicker check.
<! CTGRY ><LI>Accessing arrays is much faster than accessing vectors, String, and StringBuffer.
<! CTGRY ><LI>Use System.arraycopy() to improve performance.
<! CTGRY ><LI>Initialize expensive arrays in class static initializers, and create a per instance copy of this array initialized with System.arrarycopy().
<! CTGRY ><LI>Vector is convenient to use, but inefficient. For best performance, use it only when the structure size is unknown, and efficiency is not a concern.
<! CTGRY ><LI>When using Vector, ensure that elementAt() is not used inside a loop.
<! CTGRY synchronization ><LI>Vector element access is faster using a subclassed non-synchronized accessor.
<! CTGRY ><LI>Re-use Vectors by using Vector.removeAllElements().
<! CTGRY ><LI>Initialize Vector to the maximum expected size.
<! CTGRY ><LI>Re-use Hashtables by using Hashtable.clear().
<! CTGRY ><LI>Set the Hashtable size to be large enough to hold the expected elements. Use a prime number for table size.
<! CTGRY ><LI>Override hashcode() methods of Hashtable keys to improve hashing efficiency.
<! CTGRY ><LI>Use non-synchronized hash table classes.
<! CTGRY ><LI>Increase heap size to reduce garbage collection [actally to defer it - this is a balancing act].
<! CTGRY ><LI>Use the -verbosegc option to monitor garbage collection.
<! CTGRY ><LI>Use arrays of smaller datatypes (short rather than int) is possible.
<! CTGRY ><LI>Avoid allocating objects in loops (readLine() is a common example).
<! CTGRY synchronization ><LI>Minimizing synchronization may take work, but can pay off well.
<! CTGRY analysis_and_design a_d:mltplx ><LI>Polling is only acceptable when waiting for outside events and should be performed in a "side" thread. Use wait/notify instead.
<! CTGRY synchronization ><LI>Eliminate calls to synchronized methods (but be careful of being overly ambitious in this).
<! CTGRY synchronization ><LI>It is slightly faster to call a synchronized method than to enter a synchronized block.
<! CTGRY synchronization ><LI>Calling a synchronized method when the monitor is already owned by the thread executes somewhat faster than calling a synchronized method when the monitor isn't already owned by the thread.
<! CTGRY ><LI>Creating objects is expensive.
<! CTGRY ><LI>Consider reusing objects in reuse pools.
<! CTGRY ><LI>Move new(), invariants and constant conditionals outside of loops.
<! CTGRY ><LI>Unroll loops.
<! CTGRY ><LI>Make tests in loops as simple as possible.
<! CTGRY ><LI>Loop tests run backwards are slightly faster [actually the test comparing to 0 is what is faster].
<! CTGRY ><LI>Use local variables, rather than any other type of variable, in loops.
<! CTGRY algorithms ><LI>Combine similar loops. Nest the busiest loop, if loops are interchangeable. 
<! CTGRY algorithms ><LI>Convert expressions to table lookups [doesn't always work].
<! CTGRY algorithms ><LI>Cache values that are expensive to fetch or compute.
<! CTGRY algorithms ><LI>Pre-compute results.
<! CTGRY algorithms ><LI>Delay computation of results until they are needed [if the computation comes at a bad time]
<! CTGRY algorithms ><LI>Put all one-time initializations into a class initializer.
START
http://www-1.ibm.com/servers/eserver/zseries/software/java/perform.html
Both Java specific and Java on OS/390 tips.
(Page last updated 2000, Added 2000-10-23, Author ?, Publisher IBM).
20
<! CTGRY ><LI>Use the latest release of the SDK.
<! CTGRY ><LI>Use zip and jar files. Partition classes to different zip/jar files according to usage.
<! CTGRY ><LI>Order the entries in CLASSPATH so that classes are found quickly (the default classloaders do a linear search in each entry's directory or zip/jar file).
<! CTGRY ><LI>If using a large number of threads (thousands) tune the underlying OS to support this.
<! CTGRY ><LI>Vary the -ss parameter to optimize for threads. Threads generally don't need more than 256K stack size.
<! CTGRY jni ><LI>Minimize the number of JNI calls
<! CTGRY ><LI>Use primitive types for variables
<! CTGRY ><LI>Avoid excessive writing to the Java console
<! CTGRY synchronization ><LI>Use synchronized methods only when necessary
<! CTGRY ><LI>Cache/reuse frequently used objects when possible
<! CTGRY finalkey ><LI>Declare methods as final [dubious tip].
<! CTGRY finalkey ><LI>Use static final when creating constants
<! CTGRY ><LI>Use int instead of long.
<! CTGRY ><LI>Use local variables in preference to class and instance variables.
<! CTGRY ><LI>Use arrays instead of vectors 
<! CTGRY ><LI>Consider when to use a temporary variable to manipulate class and instance variables in loops (speed vs. memory)
<! CTGRY ><LI>Add and delete items from the end of a vector
<! CTGRY ><LI>Avoid unnecessary cast and instanceof
<! CTGRY ><LI>Avoid using String when doing a lot of character manipulation. Use StringBuffer instead.
<! CTGRY ><LI>Avoid using long divides.
START
http://www.javaworld.com/javatips/jw-javatip26.html
Javaworld tip article, detailing a buffered RandomAccessFile class.
(Page last updated 1998?, Added 2000-10-23, Author Nick Zhang). Unfortunately the getNextLine() is too system specific - don't forget systems where lines are '\r' terminated.
2
<! CTGRY ><LI>Use buffered i/o classes.
<! CTGRY synchronization ><LI>Re-implement classes to avoid synchronization, where this is applicable.
START
http://www.developer.ibm.com/library/articles/programmer/haggar_bytecode.html
Nice article on understanding bytecodes by Peter Haggar, Added 2000-10-23, Author of "Practical Java". Explains why a synchronized method is faster than a functionally identical synchronized block.
(Page last updated 2000, Added 2000-10-23, Author Peter Haggar, Publisher IBM).
7
<! CTGRY profiling j2me ><LI>Understanding bytecodes can help determine how to improve performance. It can also help you to create smaller sized class files.
<! CTGRY synchronization ><LI>Don't synchronize code unless synchronization is required.
<! CTGRY synchronization ><LI>Use synchronized methods rather than synchronized blocks where the code would be functionally identical.
<! CTGRY ><LI>The -O option in SDK 1.2 does nothing.
<! CTGRY j2me ><LI>Use the -g:none option to make files class smaller [or use a better optimizing compiler]
<! CTGRY ><LI>Move invariants out of loops.
<! CTGRY ><LI>Apply simple optimizations like loop unrolling, algebraic simplification, and strength reduction by hand.
START
http://developer.java.sun.com/developer/Books/programming/performance/eperformance/eJavaCh01.pdf
Chapter 1 of "Enterprise Java Performance", "Performance in General". Includes the infamous sentences "It is likely that the code will not meet the performance requirements the very first time it runs. Even if it does, it may be worthwhile to look for some ways to improve it." NO NO NO! If the code meets the performance requirements, DON'T CHANGE IT. Next time guys, ask me to review your book before you publish.
(Page last updated 2000, Added 2000-10-23, Authors  Steven Halter & Steven Munroe, Publisher Sun).
19
<! CTGRY algorithms ><LI>The simplest code usually performs best.
<! CTGRY management algorithms ><LI>Consider performance requirements before coding.
<! CTGRY ><LI>Write reasonable code without worrying too much about performance until later.
<! CTGRY algorithms ><LI>If the design identifies a critical section of code, spend time considering that code's performance before and while writing it.
<! CTGRY management analysis_and_design a_d:predict ><LI>Define performance requirements explicitly. Redefine fuzzy requirements to be more explicit.
<! CTGRY management ><LI>The target machine affects performance requirements.
<! CTGRY ><LI>Use the simplest classes possible--but no simpler. [Don'cha just love it. And here I was using classes simpler than is possible. Gotta make 'em more complex now.]
<! CTGRY algorithms ><LI>Don’t recalculate things that are constant in loops.
<! CTGRY ><LI>Reuse objects where possible.
<! CTGRY ><LI>Choose the correct collection for performance.
<! CTGRY ><LI>Use the default Java data values where possible to avoid reassigning them.
<! CTGRY ><LI>Use raw arrays in preference to collections.
<! CTGRY ><LI>Performance fixing is iterative. Fixing one bottleneck often reveals another previously hidden one.
<! CTGRY analysis_and_design a_d:non ><LI>Keep performance in mind during the design phase.
<! CTGRY synchronization ><LI>Avoid monopolizing shared resources.
<! CTGRY analysis_and_design a_d:distrib ><LI>Design is important for any distributed parts of a distributed application.
<! CTGRY management profiling analysis_and_design a_d:distrib ><LI>The real performance limitations are physical limitations: bandwidth, communication distance, access speed, unavoidable overheads, resource limitations, etc.
<! CTGRY jni ><LI>JNI calls are not necessarily faster than using pure Java because of JNI overheads.
<! CTGRY analysis_and_design a_d:non ><LI>Schema mapping is complex. [Buy a product that does it for you.]
START
http://developer.java.sun.com/developer/Books/programming/performance/eperformance/eJavaCh04.pdf
Chapter 4 of "Enterprise Java Performance", "Local/Remote Issues".
(Page last updated 2000, Added 2000-10-23, Authors  Steven Halter & Steven Munroe, Publisher Sun).
12
<! CTGRY analysis_and_design a_d:rmi j2ee:rmi ><LI>RMI over IIOP has a higher overhead than plain RMI.
<! CTGRY analysis_and_design a_d:rmi j2ee:rmi ><LI>Objects that can be configured to be local or remote at any time, provides the flexibility to optimize performance.
<! CTGRY analysis_and_design a_d:rmi j2ee:rmi ><LI>Large grained remote calls [i.e. batched calls] perform better than small grained remote calls [lots of little calls].
<! CTGRY analysis_and_design a_d:prstnce ><LI>Persistency adds overheads that make persistent objects slower.
<! CTGRY j2ee:rmi ><LI>Instead of serializing the transitive closure (recursive traversal of all objects referenced), break up objects into smaller chunks.
<! CTGRY j2ee:rmi ><LI>Use stubs, proxies and handles [essentially objects that indirectly refer to other objects] to break up serialization into smaller chunks.
<! CTGRY analysis_and_design a_d:rmi j2ee:rmi ><LI>Unless the application is put together with care, the remote method call costs may dominate.
<! CTGRY analysis_and_design a_d:rmi j2ee:rmi ><LI>Group objects that interact strongly [a lot] in the same physical location. The closer they are, the more efficient their interaction.
<! CTGRY j2ee:rmi ><LI>Cache in the client any read-only objects, for the whole session. Replicate any data needed so that queries run locally in the client.
<! CTGRY analysis_and_design a_d:distrib j2ee:rmi ><LI>Written objects can be held in the client and periodically written to the server, rather than updating the server object on each change.
<! CTGRY analysis_and_design a_d:distrib j2ee:rmi ><LI>Good partitioning of objects in distributed applications limits interactions between objects in different partitions and takes advantage of local method access for objects within each partition.
<! CTGRY analysis_and_design a_d:distrib j2ee:rmi ><LI>Application partitioning is best addressed early in the design.
START
http://www.javaworld.com/javaworld/jw-04-1997/jw-04-optimize.html
Doug Bell's article with various low-level techniques and benchmark applets.
(Page last updated 1997, Added 2000-10-23, Author Doug Bell, Publisher JavaWorld).
9
<! CTGRY ><LI>Don't optimize unless necessary. Optimizing can: introduce new bugs; make code harder to understand and maintain; reduce the extensibility of the code.
<! CTGRY profiling ><LI>90 percent of a program's excution time is spent executing 10 percent of the code. (Some people use the 80 percent/20 percent rule).  Optimizing the other 90 percent of the program (where 10 percent of the execution time was spent) has no noticeable effect on performance.
<! CTGRY ><LI>General optimization techniques include: strength reduction; common sub expression elimination; code motion; unrolling loops.
<! CTGRY ><LI>Use compiler features: constant folding; branch folding; dead code elimination.
<! CTGRY ><LI>Use the -O option (javac -O).
<! CTGRY profiling ><LI>Use a profiler to identify bottlenecks.
<! CTGRY profiling ><LI>Always time the code before and after making changes to verify that, at least on the test platform, your changes improved the program.
<! CTGRY profiling ><LI>Try to make each timing test under identical conditions.
<! CTGRY profiling ><LI>If possible, contrive a test that doesn't rely on any user input, as the variations in user response can cause the results to fluctuate.
START
http://developer.java.sun.com/developer/Books/performance/ch10.pdf
Chapter 10 (Swing models and renderers) of "Java Platform Performance: Strategies and Tactics."
(Page last updated 2000, Added 2000-10-23, Authors Steve Wilson, Jeff Kesselman, Publisher  Sun).
6
<! CTGRY analysis_and_design a_d:anim ><LI>Swing’s model-view architecture is critical for building scalable programs.
<! CTGRY ><LI>When changing data stored in models, perform the operations in bulk whenever possible. E.g. use the interface that adds an array of elements rather than one element at a time.
<! CTGRY analysis_and_design a_d:mmry a_d:anim ><LI>Use custom models to handle large datasets. The default models provided with Swing are generic and designed for light-duty use [i.e. are slow].
<! CTGRY ><LI>Custom renderers can sometimes be used to improve performance. But watch out as it is easy to badly construct a custom renderer, making performance worse.
<! CTGRY ><LI>A custom model and a custom renderer can be used together in the same Component.
<! CTGRY ><LI>When initializing or totally replacing the contents of a model, consider constructing a new one instead of reusing the existing one, as this avoid posting notifications to any listeners. [Or reuse the object but deregister the listeners first].
START
http://www.protomatter.com/nate/java-optimization/
Various tips.
(Page last updated 1999?, Added 2000-10-23, Author Nate Sammons, Publisher Sammons).
14
<! CTGRY ><LI>Use StringBuffer for String concatenations, rather than the '+' operator.
<! CTGRY ><LI>Use static strings, String.intern() or a static Hashtable to reduce the number of occurrances of identical string objects.
<! CTGRY ><LI>Modify java.lang.String to cache the hashCode if you are using many string keys in hash tables [note Sun added this optimization to the String class in SDK 1.3]
<! CTGRY ><LI>String.getBytes() is very inefficient with a method call for <em>every</em> character. Use getBytes(int, int, byte[] int) instead, or some other mecahnism.
<! CTGRY synchronization ><LI>Use non-synchronized Vector, Hashtable, etc. where possible.
<! CTGRY ><LI>Size Vector, Hashtable, etc. appropriately.
<! CTGRY ><LI>Object creation is expensive. Pool your objects where possible.
<! CTGRY ><LI>Inner class object creation is even more expensive than normal. Use non-public concrete support classes instead.
<! CTGRY finalkey ><LI>Method call times: static 220ns; final 300ns; instance 550ns; interface methods 750ns; synchronized methods 1,500ns. [But times vary enormously depending on the VM and context].
<! CTGRY finalkey ><LI>Use static final methods where possible. [And do functional programming too ;-)]
<! CTGRY ><LI>Rewrite loops so that the termination test compares against 0.
<! CTGRY ><LI>Use exception terminated infinite loops for long loops.
<! CTGRY ><LI>Use System.arraycopy() to copy arrays.
<! CTGRY ><LI>Use temporary local variables to manipulate instance variables.
START
http://www.javaworld.com/javatips/jw-javatip18.html
Cute tip on unblocking a blocked socket by sending it data from a timer thread.
(Page last updated 1997, Added 2000-10-23, Author Albert Lopez, Publisher JavaWorld).
2
<! CTGRY ><LI>Use a separate timer thread to timeout socket operations
<! CTGRY ><LI>Instead of killing the blocked socket, send it some data to unblock it.
START
http://www.macadamian.com/column/column_fastjava.html
Article by Frederic Boulanger with tuning tips.
(Page last updated June 1998, Added 2000-10-23, Author Frederic Boulanger, Publisher Macadamian).
7
<! CTGRY algorithms ><LI>Choose the best algorithm or data structure.
<! CTGRY ><LI>Whatever can be calculated outside of a loop should be calculated outside of the loop.
<! CTGRY ><LI>Try to minimize method calls within a loop.
<! CTGRY ><LI>Reduce the number of references to an array in loops.
<! CTGRY ><LI>Store the value of array or array elements in temporary variables and use these in the loop.
<! CTGRY ><LI>For multidimensional arrays store a reference for the currently accessed row in a variable. 
<! CTGRY ><LI>Store member variables in a local temporary variable in loops.
START
http://www-4.ibm.com/software/os/warp/performance/javatip.htm
IBM's list of Java performance tuning tips (same page, two URLs).
(Page last updated 2000, Added 2000-10-23, Author ?, Publisher IBM).
18
<! CTGRY jni ><LI>Group native operations to reduce the number of JNI calls. 
<! CTGRY ><LI>Primitive types are faster than classes encapsulating types. 
<! CTGRY ><LI>Avoid excessive writing to the java console. 
<! CTGRY ><LI>Reorder CLASSPATH so that the most used libraries occur first. 
<! CTGRY synchronization ><LI>Don't overuse synchronized methods. 
<! CTGRY ><LI>Use int instead of long when possible. 
<! CTGRY finalkey ><LI>When possible, declare methods as final. 
<! CTGRY ><LI>If needed, only call the garbage collector explicitly at an appropriate time (when things are quiet). 
<! CTGRY ><LI>Prudent use of zip and jar formats can improve load time. 
<! CTGRY ><LI>Compile java files with the optimizer on. 
<! CTGRY ><LI>Cache frequently used objects when possible. 
<! CTGRY finalkey ><LI>Use static final when creating constants. 
<! CTGRY ><LI>Use StringBuffer when doing excessive string manipulations. 
<! CTGRY ><LI>Consider when to use local variables in loops (speed vs. memory?). 
<! CTGRY ><LI>Vectors are more flexible than arrays, but much slower. 
<! CTGRY ><LI>It is faster to add/delete items from the end of the vector. 
<! CTGRY ><LI>Avoid unnecessary casts and instanceof. 
<! CTGRY ><LI>Scope of variables can impact performance.
START
http://developer.irt.org/script/java.htm
FAQ site with a couple of basic performance tips.
(Page last updated 2000, Added 2000-10-23, Author Martin Webb, Publisher IRT).
3
<! CTGRY ><LI>FAQ 4002: Use an ImageObserver (method listed in FAQ) to control how and when images are painted during loading.
<! CTGRY ><LI>FAQ 4003: Minimise flicker in animations by overriding update() to simply call paint() (default action is to clear the image first), and use double buffering.
<! CTGRY ><LI>FAQ 4063 & 4066: Use jar files to reduce the amount of time that it takes to download an applet.
START
http://www.as400.ibm.com/developer/java/faq/perffaq.html
Some IBM Java performance tips. Although intended for AS/400 Java, many tips are generally applicable
(Page last updated ?, Added 2000-10-23, Author ?, Publisher IBM).
9
<! CTGRY synchronization ><LI>Minimize the use of synchronized methods.
<! CTGRY ><LI>Use the -O javac option.
<! CTGRY ><LI>Minimize object creation, reuse objects.
<! CTGRY ><LI>Use StringBuffers or char[] arrays to minimize the number of String objects created.
<! CTGRY synchronization ><LI>Use faster accesses. Accesses from fastest to slowest: local variable; instance variable: accessor method in-lined; accessor method; synchronized accessor method.
<! CTGRY ><LI>Minimize the use of created exceptions.
<! CTGRY finalkey ><LI>Use <CODE>static final</CODE> when creating constants.
<! CTGRY jdbc jdbc:prepared ><LI>Use Prepared Statements.
<! CTGRY jdbc jdbc:conversion ><LI>Store character data in DB2 as Unicode, numeric data as float.
START
http://www.aikido.ozactivity.com.au/doc/en/administration/server_tune_procs.html
Tuning tips intended for Sun's "Web Server" product, but actually generally applicable.
(Page last updated 1999, Added 2000-10-23, Author ? - a Sun document, Publisher Aikido).
12
<! CTGRY app_server j2ee:servlets ><LI>Use more server threads if multiple connections have high latency.
<! CTGRY app_server j2ee:servlets ><LI>Use keep-alive sockets for higher throughput.
<! CTGRY app_server j2ee:servlets ><LI>Increase server listen queues for high load or high latency servers.
<! CTGRY app_server j2ee:servlets ><LI>Avoid or reduce logging.
<! CTGRY app_server j2ee:servlets ><LI>Buffer logging output: use less than one real output per log.
<! CTGRY profiling app_server j2ee:servlets ><LI>Avoid reverse DNS lookups.
<! CTGRY app_server j2ee:servlets ><LI>Write time stamps rather than formatted date-times.
<! CTGRY app_server j2ee:servlets ><LI>Separate paging and application files.
<! CTGRY app_server j2ee:servlets ><LI>A high VM heap size may result in paging, but could avoid some garbage collections.
<! CTGRY profiling app_server user_perception j2ee:servlets ><LI>Occasional very long GCs makes the VM hang for that time, leading to variability in service quality.
<! CTGRY app_server j2ee:servlets ><LI>Doing GC fairly often and avoiding paging is more efficient.
<! CTGRY app_server j2ee:servlets ><LI>Security checks consume CPU resources. You will get better performance if you can turn security checking off.
START
http://www.ibm.com/java/education/javahipr/javahipr1.html
Research paper on high performance Java.
(Page last updated 1999, Added 2000-10-23, Author Sandeep K. Singhal, Publisher IBM).
6
<! CTGRY ><LI>Use local variables as a first choice for manipulating data.
<! CTGRY ><LI>Rewrite the loop test so that it uses a comparison to 0.
<! CTGRY synchronization ><LI>Avoid synchronization where possible.
<! CTGRY ><LI>Reuse and pool objects.
<! CTGRY ><LI>Avoid throwing exceptions (<em>not</em> avoid using try-catch blocks).
<! CTGRY ><LI>Build specialized classes, don't rely on the general-purpose (but slow) core SDK library.
START
http://www.javaworld.com/javaworld/javatips/jw-javatip21.html
Use a zip archive to download classes.
(Page last updated 1997, Added 2000-10-23, Author John D. Mitchell, Publisher JavaWorld).
1
<! CTGRY ><LI>Use a zip archive to download classes.
START
http://m5.peakin.com/html/body_performance.html
Various tips. For web servers?
(Page last updated 2000, Added 2000-10-23, Author ?, Publisher ?).
6
<! CTGRY app_server ><LI>Test multiple VMs.
<! CTGRY app_server ><LI>Tune the heap and stack sizes [by trial and error], using your system memory as a guide to upper limits.
<! CTGRY app_server ><LI>Keep the system file cache large. [OS/Product tuning, not Java]
<! CTGRY app_server j2ee:servlets ><LI>Compression uses significant system resources. Don't use it on a server unless necessary.
<! CTGRY profiling app_server ><LI>Monitor thread utilization. Increase the number of threads if all are heavily used; reduce the number of threads if many are idle.
<! CTGRY profiling app_server jdbc jdbc:conn_pool ><LI>Empirically test for the optimal number of database connections.
START
http://sharkysoft.com/software/lava/docs/lavadocs/lava/clib/stdio/doc-files/optimize.htm
A worked example of optimizing Lava Rocks Java Printf.
(Page last updated 1999, Added 2000-10-23, Author ?, Publisher SharkySoft).
4
<! CTGRY ><LI>When adding multiple items to a collection, add them all in one call if possible.
<! CTGRY ><LI>Avoid creating multiple objects where they can be replaced by one object referred to many times.
<! CTGRY ><LI>Avoid repeatedly executing a parse [or other constant expression] in a loop when the execution can be achieved once outside the loop.
<! CTGRY ><LI>Call more complex underlying methods instead of simpler wrapping methods.
START
http://www.ddj.com/articles/1996/9604/9604e/9604e.htm
Paul Tyma's article on low level Java optimizations.
(Page last updated 1996, Added 2000-10-23, Author Paul Tyma, Publisher Dr. Dobb's).
7
<! CTGRY ><LI>Speed up the most-used code, such as highly iterated loops and popularly called methods.
<! CTGRY ><LI><CODE>int</CODE> is faster than <CODE>long</CODE>
<! CTGRY ><LI>Performance of code that is heavily dependent upon system API calls is largely out of your hands.
<! CTGRY analysis_and_design a_d:class ><LI>Create classes that support primitive data types directly, rather than having to wrap the data, e.g. a Stack class that directly stores <CODE>int</CODE>s.
<! CTGRY ><LI>Inline code.
<! CTGRY ><LI>Declare methods as static or private to allow inlining.
<! CTGRY ><LI>Apply code motion (eliminating redundant calculations).
START
http://www.javaworld.com/javaworld/jw-06-1997/jw-06-plugins.html
Improving applet download time by installing the applet on the client.
(Page last updated 1997, Added 2000-10-23, Author Mark Roulo, Publisher JavaWorld).
1
<! CTGRY user_perception ><LI>Store your applet on the client machine so that applet download time is absolutely minimal. This is not worth doing for really small applets.
START
http://www.sunworld.com/sunworldonline/swol-11-1998/swol-11-itarchitect.html
Article on high availability architecture. If the system isn't up when you need it, its not performing.
(Page last updated November 1998, Added 2000-10-23, Author Sam Wong, Publisher Sun).
2
<! CTGRY app_server analysis_and_design a_d:ldbalnc ><LI>Eliminate all potential single-points-of-failure, basically with redundancy and automatic fail-over.
<! CTGRY app_server analysis_and_design a_d:ldbalnc ><LI>Consider using the redundant components to improve performance, with a component failure causing decreased performance rather system failure.
START
http://codeguru.earthweb.com/java/articles/511.shtml
Another "use StringBuffer instead of '+' tip.
(Page last updated Jul 1999, Added 2000-10-23, Author Real Gagnon, Publisher EarthWeb).
1
<! CTGRY ><LI>use StringBuffer instead of '+'.
START
http://www.spec.org/osg/jbb2000/docs/userguide.html
Tuning the SPECjbb2000 Java specmark.
(Page last updated 2000, Added 2000-10-23, Author ?, Publisher SPEC).
2
<! CTGRY profiling ><LI>Use Java profilers (-prof, -Xrunhprof) to determine the routines most heavily used.
<! CTGRY ><LI>Having extra stuff in CLASSPATH can degrade performance on some JVMs.
START
http://www.sun.com/software/white-papers/wp-optimize/optimize-part1.pdf
Sun system (not Java) profiling with Sun WorkShop.
(Page last updated 1998, Added 2000-10-23, Author ?, Publisher Sun).
3
<! CTGRY ><LI>Select the right combination of compiler options, optimized libraries, and coding techniques.
<! CTGRY ><LI>Compiler optimizations: common subexpression elimination; loop-invariant hoisting; strength reduction; dead and redundant code elimination; loop pipelining/unrolling; instruction scheduling; inlining; code motion; profile feedback; tail recursion elimination; loop parallelization; loop interchange; loop fusion (combining loops to reduce overhead).
<! CTGRY ><LI>Cache blocking: a technique that increases the cache-hit rates of the program by increasing the reuse of the data present in the cache.
START
http://java.oreilly.com/news/jptsummary_1100.html
A high level overview of technical performance tuning, covering 5 levels of tuning competence. Note that this is a reissue of an article already available from my book's examples page at O'Reilly
(Page last updated November 2000, Added 2000-12-20, Author Jack Shirazi).
9
<LI>Start tuning by examining the application architecture for potential bottlenecks.
<LI>Architecture bottlenecks are often easy to spot: they are the connecting lines on the diagrams; the single threaded components; the components with many connecting lines attached; etc.
<LI>Ensure that application performance is measureable for the given performance targets.
<LI>Ensure that there is a test environment which represents the running system. This test-bed should support testing the application at different loads, including a low load and a fully scaled load representing maximum expected usage. 
<LI>After targetting design and architecture, the biggest bang for your buck in terms of improving performance is choosing a better VM, and then choosing a better compiler.
<LI>Start code tuning with proof of concept bottleneck removal: this consists of using profilers to identify bottlenecks, then making simplified changes which may only improve the performance at the bottleneck for a specialized set of activities, and proceeding to the next bottleneck. After tuning competence is gained, move to full tuning.
<LI>Multi-user performance tests can typically take a full day to run and analyse. Even simple multi-user performance tuning can take several weeks.
<LI>After the easily idenitified bottlenecks have been removed, the remaining performance improvements often come mainly from targetting loops, structures and algorithms.
<LI>In running systems, performance should be continually monitored to ensure that any performance degradation can be promptly identified and addressed.
START
http://www.javaworld.com/javaworld/jw-11-2000/jw-1117-optimize.html
Article about optimizing queries on Maps.
(Page last updated November 2000, Added 2000-12-20, Author Jack Shirazi).
8
<LI>Avoid using synchronization in read-only or single-threaded queries.
<LI>In the SDK, Enumerators are faster than Iterators due to the specific implementations.
<LI>Eliminate repeatedly called methods where alternatives are possible.
<LI>Iterator.hasNext() and Enumerator.hasMoreElements() do not need to be repeatedly called when the size of the collection is known. Use collection.size() and a loop counter instead.
<LI>Avoid accessing collection data through the data access methods by implementing a query in the collection class.
<LI>Elminate repeated casts by casting once and holding the cast item in a correctly typed variable.
<LI>Reimplement the collection class to specialize for the data being held in the collection.
<LI>Reimplment the Map class to use a hash function which is more efficient for the data being mapped.
START
http://www.onjava.com/pub/a/onjava/2000/12/15/formatting_doubles.html
Efficiently formatting doubles
(Page last updated December 2000, Added 2000-12-20, Author Jack Shirazi).
5
<LI>Double.toString(double) is slow. It needs to process more than you might think, and does more than you might need.
<LI>Proprietary conversion algorithms can be significantly faster. One such algorithm is presented in the article.
<LI>Converting integers to strings can also be faster than the SDK. An algorithm successively stripping off the highest is used in the article.
<LI>Formatting numbers using java.text.DecimalFormat is always slower than Double.toString(double), because it first calls Double.toString(double) then parses and converts the result.
<LI>Formatting using a proprietary conversion algorithm can be faster than any of the methods discussed so far, if the number of digits being printed is not large. The actual time taken depends on the number of digits being printed.
START
http://www.javaworld.com/javaworld/jw-11-2000/jw-1117-performance.html
Article about optimizing I/O performance.
(Page last updated November 2000, Added 2000-12-20, Author Brian Goetz).
7
<LI>Measure early, measure often. You can't effectively manage performance if you don't know the source of your problem.
<LI>Spending days tuning a subsystem that accounts for 1 percent of an application's total runtime simply cannot yield more than a 1 percent improvement in application performance.
<LI>Use performance measurement tools to identify where your application spends its time and focus your energy on those hot spots.
<LI>Object creation is an expensive operation: avoid excessive object instantiations. 
<LI>Use buffered I/O (with buffering classes or by explicitly buffering to an array).
<LI>InputStream runs faster than Reader.
<LI>Combine tasks from multiple classes to avoid extra overhead and redundant object creation.
START
http://www.java-pro.com/upload/free/features/javapro/2001/01jan01/tm0101/tm0101.asp
Basic article on performance tuning techniques.
(Page last updated January 2001, Added 2000-12-14, Author Tarak Modi).
8
<LI>[The compiler concatenates strings where they are fully resolvable, so don't move these concatenations to runtime with StringBuffer.]
<LI>Where the compiler cannot resolve concatenated strings at compile time, the code should be converted to StringBuffer appends, and the StringBuffer should be appropriately sized rather than using the default size.
<LI>Using the concatenation operator (+) in a loop is very inefficient, as it creates many intermediate temporary objects.
<LI>Presizing collections (like Vector) to the expected size is more efficient than using the default size and letting the collection grow.
<LI>Removing elements from a Vector will necessitate copying within the Vector if the element is removed from anywhere other than the end of the collection.
<LI>Cache the size of the collection in a local variable to use in a loop instead of repeatedly calling collection.size().
<LI>Unsynchronized methods are faster than synchronized ones.
<LI>[Article discusses applying these optimzations to a thread pool implementation.]
START
http://www.theparticle.com/javadata2.html
Particle's pretty good coverage of the main Java data structures. Only a few tuning tips: reuse, pools, optimized sorting. But knowing which structure to use for a particular problem is an important performance tuning technique.
(Page last updated April 2000, Added 2000-12-20, Author J. Particle).
8
<LI>Make linked lists faster by having dummy first and last nodes.
<LI>Reusing code is easier than reimplementing, but can lead to slower performance.
<LI>Use node pools to reduce memory impact.
<LI>Sorting elements on insertion means they don't need to be sorted later.
<LI>[Article includes several(non-optimized) standard sort algorithms implemented in Java, and compares their performance.]
<LI>[Article discusses optimizing a quicksort.]
<LI>If you are using many small collections, carefully consider the collection structure used. Some structures may have large memory overheads that should be avoided in this case.
<LI>Some discussion of hidden surface removal for graphics.
START
http://developer.java.sun.com/developer/technicalArticles/InnerWorkings/JDCPerformTips/index.html
Various performance tips from a JavaOne 1998 presentation.
(Page last updated September 1998, Added 2000-12-20, Author Tony Squier & Steven Meloan).
4
<LI>Minimize the number of times that an applet has to request data from the server.
<LI>Package Applet images into a single class file.
<LI>Use Thread pools where these improve performance.
<LI>Use BufferedIO streams to access URLConnection's Input/Output streams.
START
http://www.javaworld.com/javaworld/jw-11-1999/jw-11-performance.html
Object management article
(Page last updated November 1999, Added 2000-12-20, Author Dennis M. Sosnoski).
9
<LI>Objects have a space overhead in addition to the space taken by the data held by the object.
<LI>Object creation and garbage collection have significant overheads.
<LI>Providing you're sensible about creating objects in heavily used code, it's easy to avoid the object churn cycle.
<LI>The easiest way to reduce object creation in your programs is by using primitive types in place of objects.
<LI>Avoid using wrapper classes (for primitive data types, e.g. Integer) as they impose extra overheads.
<LI>Avoid convenience classes like Point if you can manage the underlying data directly.
<LI>Reuse objects where possible.
<LI>Use object pools where this is helpful in reusing objects, but be careful that the pool implementation does actually give a performance improvement (dedicated pools within the class can be significantly faster than abstract pool implementations).
<LI>Implement pools so that the pool does not retain a reference to any allocated object, so that if the object is not returned to the pool, it can still be garbage collected when finished with (thus avoiding memory leaks).
START
http://www.javaworld.com/javaworld/jw-12-1999/jw-12-performance.html
Article on the cost of casts
(Page last updated December 1999, Added 2000-12-20, Author Dennis M. Sosnoski).
4
<LI>Casting can be detrimental to performance.
<LI>Improve performance by minimizing casting in heavily used code.
<LI>Some casts take nearly as long as a simple object allocation.
<LI>[Article discusses various ways of avoiding casts, showing advantages and drawbacks.]
START
http://www.javaworld.com/javaworld/jw-02-2000/jw-02-performance.html
Article on Java 2 collections
(Page last updated February 2000, Added 2000-12-20, Author Dennis M. Sosnoski).
5
<LI>Convert collections into arrays for improved access speed.
<LI>The conversion can be made slightly faster by implementing it in a subclass so that collection element access can avoid access methods, accessing elements directly.
<LI>Customized implementations of Hashtables can perform better.
<LI>Use type specific implementations of collections for better performance (e.g. IntegerVector rather than Vector)
<LI>[Article describes a type-generic base class for typed arrayed collections.]
START
http://www.javaworld.com/jw-06-1998/jw-06-object-pool.html
Article on building an object pool for improved performance.
(Page last updated June 1998, Added 2000-12-20, Author Thomas E. Davis).
2
<LI>[Article discusses generic pool issues including storage, tracking, and expiration times of pool elements.]
<LI>Use connection pools to recycle connections and reduce overheads [Article includes a JDBC connection pool implementation.]
START
http://www.javaworld.com/jw-08-1998/jw-08-object-pool.html
Article on improving object pools performance.
(Page last updated September 1998, Added 2000-12-20, Author Thomas E. Davis).
3
<LI>Use an expiration thread to clean up excessive amounts of objects in the pool.
<LI>Use java.lanf.ref.Reference objects to determine when objects checked out but never checkd in have been released by the application.
<LI>Limiting the size of the pool can adversely impact performance.
START
http://www.javaworld.com/javaworld/javatips/jw-javatip78.html
Article on recycling resource pools
(Page last updated 1998, Added 2000-12-20, Authors Philip Bishop and Nigel Warren).
2
<LI>Check for broken resources when putting them back in the pool.
<LI>Use the builder pattern: break the construction of complex objects into a series simpler Builder objects, and a Director object which combines the Builders to form the complex object. Then you can use Recycler (a type of Director) to replace only the broken parts of the complex object, so reducing the amount of objects that need to be recreated.
START
http://www.javaworld.com/javaworld/jw-03-1996/jw-03-animation.html
Animation in java applets article. Old article, but basically sound (the basics haven't changed).
(Page last updated March 1996, Added 2000-12-20, Authors Arthur van Hoff and Kathy Walrath).
8
<LI>Use a separate thread to draw the animation. Do not use the paint() method.
<LI>Destroy the animation drawing thread when the user leaves the page (Applet.stop() is called) to avoid consuming CPU when nothing is being viewed.
<LI>Keep the correct frame rate by calculating elapsed time and delaying for the remaining time, rather than always simply delaying for a contant time period.
<LI>Override the update() method to avoid flashing (update() clears the frame each time it is painted).
<LI>Use double buffering to eliminate further flashing and usually faster drawing: drawing offscreen is potentially faster, and mapping blocks of pixels oto the screen is normally very fast.
<LI>Use a media tracker class to avoid displaying images until they are fully loaded. [This still applies, but Java 2 has more interfaces to help you do this.]
<LI>Use image strips to load multiple images in one action.
<LI>Inter-frame compression can reduce the total size of multiple images of an animation, and so improve animation network/disk transfer rates.
START
http://java.sun.com/books/Series/Tutorial/ui/drawing/animation.html
Another tutorial from Sun. This ones on animation
(Page last updated ?, Added 2000-12-20, Author ?).
5
<LI>Normal frame rates for animation: 8 frames per second (fps) for poor quality animation; 12 fps for standard animation; 24 fps for short bursts of smooth, realistic motion.
<LI>Animation loop (usually a separate thread) keeps track of frames and requests screen updates.
<LI>Suspend the animation whenever it is not visible.
<LI>Use the MediaTracker to load all required images before drawing, using checkID(anInt, true)/checkAll(true) [asynchronously] or waitForID()/waitForAll() [synchronous]. [example code included in article]
<LI>Combine images in a single file (e.g. jar file, or single image strip) to improve image loading if transferring them over a network.
START
http://www.cs.tcd.ie/courses/baict/bacs/sf/Animation/
Basic animation tutorial
(Page last updated ?, Added 2000-12-20, Author Dave ?).
5
<LI>Avoid flicker by overriding the update() method to avoid blanking the canvas.
<LI>Use a separate thread to manage the calculations and drawing.
<LI>Use MediaTracker to load all required images before drawing.
<LI>Use double buffering (draw image on offscreen buffer, then map onto screen buffer).
<LI>Use synchronization to synchronize methods in the two threads.
START
http://theserverside.com/home/thread.jsp?thread_id=3276
Some performance tips
(Page last updated January 2001, Added 2001-01-19, Author Shyam Lingegowda).
12
<LI>Use buffering for files & stream i/o . Use byte streams (not char-streams) for ASCII characters.
<LI>Recycle objects wherever possible.
<LI>Factor out constant computations from loops. For Servlets, push one time computations into the init() method.
<LI>Use StringBuffer when dealing with mutable strings. Initialize the StringBuffer with proper size. 
<LI>Let the compiler do compile time string concatenation.
<LI>Comparison of two string objects is faster if they differ in length. 
<LI>StringTokenizer is slow.
<LI>minimize the number of objects you create.
<LI>Avoid initializing twice. 
<LI>Order boolean expressions so that they execute as fast as possible.
<LI>ArrayList is faster than Vector.
<LI>Minimize calls to Date and related classes. 
START
http://www.joot.com/articles/practices.html
Good Java practices, some of which are good for performance. This page has already been listed on the <A HREF="http://www.JavaPerformanceTuning.com/tips.shtml">Tuning Tips</A> page, and the following tips are new items that have been added to the page since it was last listed
(Page last updated January 2001, Added 2001-01-19, Author Dave Jarvis).
4
<LI>Always profile the code to find where the bottlenecks are.
<LI>equalsIgnoreCase() is faster than equals() in most cases (except where string sizes are the same).
<LI>Loop backwards rather than forwards [actually its the comparison to 0 that matters].
<LI>Reduce code size by: obfuscating code; compression in jar files; excluding the manifest in jar files; reordering variable declarations; eliminating dead code; using protected methods.
START
http://www.javareport.com/html/from_pages/article.asp?id=252
Detailed article on load testing systems
(Page last updated January 2001, Added 2001-01-19, Author Himanshu Bhatt).
9
<LI>Internet systems should be load-tested throughout development.
<LI>Load testing can provide the basis for: Comparing varying architectural approaches; Performance tuning; Capacity planning.
<LI>Initially you should identify the probable performance and scalability based on the requirements. You should be asking about: numbers of users/components; component interactions; throughput and transaction rates; performance requirements.
<LI>Factor in batch requirements and performance characteristics of dependent (sub)systems. Note that additional layers, like security, add overheads to performance.
<LI>Logging and stateful EJB can degrade performance.
<LI>After the initial identification phase, the target should be for a model architecture that can be load-tested to feedback information.
<LI>Scalability hotspots are more likely to exist in the tiers that are shared across multiple client sessions.
<LI>Performance measurements should be from presentation start to presentation completion, i.e. user clicks button (start) and information is displayed (completion).
<LI>Use load-test suites and frameworks to perform repeatable load testing.
START
http://www.javareport.com/html/from_pages/article.asp?id=249
Article about frameworks and the effective memory management of objects; avoiding memory leaks by design.
(Page last updated January 2001, Added 2001-01-19, Author Leonard Slipp).
3
<LI>Define the life cycles of objects and the duration of object interrelationships. Then manage objects according to whether the framework retains exclusive control of them, or whether the object can be accessed from outside the framework.
<LI>Minimize the number of objects that can be accessed from outside the framework.
<LI>In general, the creator of an object should be responsible for the objects' life cycle. Where this is not the case, the transfer of ownership of the object should be explicit and emphasized. Similarly object relationship management should be explicit and reversible: for every add() action, there must be a remove(); for every register() action, there must be a deregister().
START
http://www.devx.com/free/articles/2000/maso01/maso01-1.asp
Article on using syslog to track performance across distributed systems
(Page last updated December 2000, Added 2001-01-19, Author Brian Maso ).
2
<LI>Use syslog to log distributed system performance.
<LI>Make sure you instrument distributed systems so that you do get performance logging.
START
http://www.onjava.com/pub/a/onjava/2000/12/15/ejb_clustering.html
"EJB2 clustering with application servers"
(Page last updated December 2000, Added 2001-01-19, Author Tyler Jewell).
1
<LI>[Article discusses multiple independent ways to load balance EJBs]
START
http://developer.java.sun.com/developer/community/chat/JavaLive/2000/jl1212.html
Sun community chat session with  Bill Shannon, Kevin Osborn, and Jim Glennon on JavaMail
(Page last updated December 2000, Added 2001-01-19, Author Edward Ort).
3
<LI>You might see a performance increase by using multiple connections to your mail server. You would need to get multiple Transport objects and call connect and sendMessage on each of them, using multiple threads (one per connection) in your application.
<LI>JavaMail 1.2 includes the ability to set timeouts for the initial connection attempt to the server.
<LI>JavaMail tries to allow you to make good and efficient use of the IMAP protocol. Fetch profiles are one technique to allow you to get batches of information from the server all at once, instead of single pieces on demand. Used properly, this can make quite a difference in your performance.
START
http://www.cs.berkeley.edu/~mdw/proj/java-nbio/
Whoopee!! A non-blocking I/O library for Java. This is the single most important functionality missing from the SDK for scalable server applications. The important class is SelectSet which allows you to multiplex all your i/o streams. If you want a scalable server and can use this class then DO SO.
(Page last updated November 2000, Added 2001-01-19, Author Matt Welsh).
1
<LI>[The system select(2)/poll(2) functions allow you to take any collection of i/o streams and ask the operating system to check whether any of them can execute read/write/accept without blocking. The system call will block if requested until any one of the i/o streams is ready to execute. Before Java, no self-respecting server would sit on multiple threads in blocked i/o mode, wasting thread resources: instead select/poll would have been used.]
START
http://www.ibiblio.org/javafaq/slides/sd2000east/javaio/Java_I_O.html
Java I/O tutorial by Elliotte Rusty Harold (author of O'Reilly's Java I/O book).
(Page last updated November 2000, Added 2001-01-19, Author Elliotte Rusty Harold).
3
<LI>Sometimes output streams are buffered by the operating system for performance. The flush() method forces the data to be written whether or not the buffer is full. This is not the same as the buffering performed by a BufferedOutputStream. That buffering is handled by the Java runtime. This buffering is at the native OS level. However, a call to flush() should empty both buffers
<LI>It's more efficient to read multiple bytes at a time, i.e use read(byte[]) rather than read().
<LI>The best size for the buffer is highly platform dependent and generally related to the block size of the disk, at least for file streams. Less than 512 bytes is probably too little and more than 4096 bytes is probably too much. Ideally you want an integral multiple of the block size of the disk. However, you should use smaller buffer sizes for unreliable network connections. 
START
http://www.javaworld.com/javaworld/jw-11-2000/jw-1110-smartproxy.html
Article on using smart proxies.
(Page last updated November 2000, Added 2001-01-19, Author M. Jeff Wilson).
4
<LI>Use smart proxies to transparently cache data in the client, thus reducing the number of remote calls.
<LI>Use this approach for caching frequently read, seldom-updated data of remote objects.
<LI>Use smart proxies to monitor the performance of RMI calls.
<LI>Use smart proxies to prevent returning multiple copies of the same remote object to client code.
START
http://java.oreilly.com/news/jsptips_1100.html
Hans Bergsten's top ten JSP tips
(Page last updated November 2000, Added 2001-01-19, Author Hans Bergsten).
3
<LI>The include <em>directive</em> (&lt;%@ include file="filename.inc" %&gt;) is faster than the include <em>action</em> (&lt;jsp:include page="pagename.jsp" flush="true"/&gt;).
<LI><em>redirect</em>s are slower than <em>forward</em>s because the browser has to make a new request.
<LI>Database access is typically very expensive in terms of server resources. Use a connection pool to share database connections efficiently between all requests, but don't use the JDBC ResultSet object itself as the cache object.
START
http://www-4.ibm.com/software/webservers/appserv/ws_bestpractices.pdf
Paper detailing the "Best Practices for Developing High Performance Web and Enterprise Applications" using IBM's WebSphere. All the tips are generally applicable to servlet/EJB development, as well as other types of server development.
(Page last updated September 2000, Added 2001-01-19, Author Harvey W. Gunther).
15
<LI>Do not store large object graphs in javax.servlet.http.HttpSession. Servlets may need to serialize and deserialize HttpSession objects for persistent sessions, and making them large produces a large serialization overhead.
<LI>Use the tag "&lt;%@ page session="false"%&gt;" to avoid creating HttpSessions in JSPs.
<LI>Minimize synchronization in Servlets to avoid multiple execution threads becoming effectively single-threaded.
<LI>Do not use javax.servlet.SingleThreadModel.
<LI>Use JDBC connection pooling, release JDBC resources when done, and reuse datasources for JDBC connections.
<LI>Use the HttpServlet Init method to perform expensive operations that need only be done once.
<LI>Minimize use of System.out.println.
<LI>Avoid String concatenation "+=".
<LI>Access entity beans from session beans, not from client or servlet code.
<LI>Reuse EJB homes.
<LI>Use Read-Only methods where appropriate in entity-beans to avoid unnecessary invocations to store.
<LI>Use the lowest impact transaction level possible for each transaction.
<LI>The EJB "remote programming" model always assumes EJB calls are remote, even where this is not so. Where calls are actually local to the same JVM, try to use calling mechanisms that avoid the remote call.
<LI>Remove stateful session beans (and any other unneeded objects) when finished with, to avoid extra overheads in case the container needs to be passivated.
<LI>Beans.instantiate() incurs a filesystem check to create new bean instances. Use "new" to avoid this overhead.
START
http://www-4.ibm.com/software/webservers/appserv/3steps_perf_tuning.pdf
Tuning IBM's WebSphere product. White paper: "Methodology for Production Performance Tuning". Only non-product specific Java tips have been extracted here.
(Page last updated September 2000, Added 2001-01-19, Author Gennaro (Jerry) Cuomo).
11
<LI>A size restricted queue (closed queue) allows system resources to be more tightly managed than an open queue.
<LI>The network provides a front-end queue. A server should be configured to use the network queue as its bottleneck, i.e. only accept a request from the network when there are sufficient resources to process the request. This reduces the load on an app server. However, sufficient requests should be accepted to ensure that the app server is working at maximum capacity, i.e. try not to let a component sit idle while there are still requests that can be accepted even if other components are fully worked.
<LI>Try to balance the workload of the various components.
<LI>[Paper shows a nice throughput curve giving recommended scaling behavior for an server]
<LI>The desirable target bottleneck is the CPU, i.e. a server should be tuned until the CPU is the remaining bottleneck. Adding CPUs is a simple remedy to this.
<LI>Use connection pools and cached prepared statements for database access.
<LI>Object memory management is particularly important for server applications. Typically garbage collection could take between 5% and 20% of the server execution time. Garbage collection statistics provide a useful monitor to determine the server's "health". Use the verbosegc flag to collect basic GC statistics.
<LI>GC statistcs to monitor are: total time spent in GC (target less than 15% of execution time); average time per GC; average memory collected per GC; average objects collected per GC.
<LI>For long lived server processes it is particularly important to eliminate memory leaks (references retained to objects and never released).
<LI>Use -ms and -mx to tune the JVM heap. Bigger means more space but GC takes longer. Use the GC statistics to determine the optimal setting, i.e the setting which provides the minimum average overhead from GC.
<LI>The ability to reload classes is typically achieved by testing a filesystem timestamp. This check should be done at set intermediate periods, and not on every request as the filesystem check is an expensive operation.
START
http://developer.java.sun.com/developer/community/chat/JavaLive/2000/jl0829.html
Sun community chat session with Steve Wilson and Jeff Kesselman on Java Performance
(Page last updated August 2000, Added 2001-01-19, Author Edward Ort).
9
<LI>HotSpot JVMs can return heap memory to the OS while running.
<LI>HotSpot Client VM (JVM 1.3) is optimized for quick startup time and low-memory footprint. The server VM (HotSpot 1.0/2.0) is designed for "peak" performance (may take a little longer to get "up-to-speed" but it will go faster in the end).
<LI>Always use System.arraycopy to copy arrays.
<LI>Sticky applets available with the 1.3 plugin speeds startup (persistently caches classes on clients). Also put resources together into jar file to reduce download requests.
<LI>SwingSet2 (demo in SDK distribution) provides a good example of large numbers of Swing components in a window, created asynchronously. 
<LI>Don't use use finalizers for anything that must be done in a timely manner.
<LI>Use primitives and transients to speed up serialization.
<LI>Use a concentrator object to limit the repaint events to once every 100 milliseconds in heavily loaded systems and in multi-threaded swing environments. There is some overhead for context switching (using invokeLater) into the AWT-event thread, which you want to minimize.
<LI>The key to high performance code is organization and process. Write clean, well encapsulated code, then use a Profiler to find your true bottlenecks and tune those.
START
http://www.awlonline.com/product/0,2627,0201616467,00.html
Peter Haggar's Practical Java Programming Language Guide.
(Page last updated 2000, Added 2001-01-19, Author Peter Haggar).
18
<LI>Focus initially on design, data structures, and algorithms.
<LI>Do not rely on compile-time code optimization.
<LI>Understand runtime code optimization.
<LI>Use StringBuffer, rather than String, for concatenation.
<LI>Minimize the cost of object creation.
<LI>Guard against unused objects.
<LI>Minimize synchronization.
<LI>Use stack variables whenever possible.
<LI>Use static, final, and private methods to allow inlining.
<LI>Initialize instance variables only once.
<LI>Use primitive types for faster and smaller code.
<LI>Do not use an Enumeration or an Iterator to traverse a Vector.
<LI>Use System.arraycopy for copying arrays.
<LI>Prefer an array to a Vector or ArrayList.
<LI>Reuse objects whenever possible.
<LI>Use lazy evaluation.
<LI>Optimize source code by hand.
<LI>Compile to native code.
START
http://www.redbooks.ibm.com/abstracts/sg245657.html
WebSphere V3 Performance Tuning Guide
(Page last updated March 2000, Added 2001-01-19, Authors Ken Ueno, Tom Alcott, Jeff Carlson, Andrew Dunshea, Hajo Kitzhöfer, Yuko Hayakawa, Frank Mogus, Colin D. Wordsworth).
7
<LI>[The Red book lists and discusses tuning parameters available to Websphere]
<LI>Run an application server and any database servers on separate server machines.
<LI>JVM heap size: -mx, -ms [-Xmx, -Xms]. As a starting point for a server based on a single JVM, consider setting the maximum heap size to 1/4 the total physical memory on the server and setting the minimum to 1/2 of the maximum. Sun recommends that ms be set to somewhere between 1/10 and 1/4 of the mx setting. They do not recommend setting ms and mx to be the same. Bigger is not always better for heap size. In general increasing the size of the Java heap improves throughput to the point where the heap no longer resides in physical memory. Once the heap begins swapping to disk, Java performance drastically suffers. Therefore, the mx heap setting should be set small enough to contain the heap within physical memory. Also, large heaps can take several seconds to fill up, so garbage collection occurs less frequently which means that pause times due to GC will increase. Use verbosegc to help determine the optimum size that minimizes overall GC.
<LI>In some cases turning off asynchronous garbage collection ("-noasyncgc", not always available to all JVMs) can improve performance.
<LI>Setting the JVM stack and native thread stack size (-oss and -ss) too large (e.g. greater than 2MB) can significantly degrade performance.
<LI>When security is enabled (e.g. SSL, password authentication, security contexts and access lists, encryption, etc) performance is degraded by significant amounts.
<LI>One of the most time-consuming procedures of a database application is establishing a connection to the database. Use connection pooling to minimize this overhead.
START
http://www.onjava.com/pub/a/onjava/2001/01/25/hash_functions.html
Optimizing hash functions: generating a perfect hash function
(Page last updated January 2001, Added 2001-02-21, Author Jack Shirazi).
7
<LI><em>perfect</em> hash functions guarantee that every key maps to a separate entry in a hashtable, and so provide more efficient hastable implementations than generic hash functions.
<LI><em>perfect</em> hash functions are possible when the key data is restricted to a known set of elements.
<LI>Optimize Map implementations by specializing the types of internal datastructures, and method parameter types and return types.
<LI>Optimize Map implementations by using a specialized hash function that is optimized for the key type, rather than generic to all possible types of keys.
<LI>Generate a perfect hash function using some variable combination of simple arithmentic operators.
<LI>Perfect hash functions may require excessive amounts of memory.
<LI>Minimal perfect hash maps do not require any excess memory, but may impose significant overheads on the map.
START
http://www.javaworld.com/javaworld/jw-02-2001/jw-0202-cachedrow.html
Article on using CachedRowSet, a ResultSet that doesn't need continuous connection to the database
(Page last updated February 2001, Added 2001-02-21, Author Taylor G. Cowan).
4
<LI>CachedRowSet provides cached result sets that do not require continuous connection to the database, allowing connections to be reused more efficiently.
<LI>Using CachedRowSet lets you batch updates, and execute them asynchronously.
<LI>CachedRowSet also supports offline work which is later synchronized.
<LI>CachedRowSet is probably not appropriate for managing large datasets.
START
http://developer.java.sun.com/developer/community/chat/JavaLive/2001/jl0131.html
Sun community chat session on "Optimizing Java Program Performance" with Peter Haggar.
(Page last updated January 2001, Added 2001-02-21, Author Edward Ort).
9
<LI>Try faster JVMs if possible.
<LI>Never tune code unless you have identified a performance problem with a profiling tool.
<LI>Beware that tuning techniques may not work well on all platforms.
<LI>Speed start-up time by: minimizing the .class sizes (use -g:none or a shrink tool e.g. DashO, JAX, JOpt); turn off the JIT
<LI>Good design, data structures, and algorithms are the best things to produce good performance.
<LI>Check String manipulation code.
<LI>It is much more efficient to read data from disk all at once rather than with multiple reads. Use the buffered classes when doing i/o.
<LI><CODE>import</CODE> is a compile time function, so has no effect on runtime (i.e. import a.b.*; or import a.b.c; make no difference to runtime performance).
<LI>Optimize conditionals to have the most likely true results first.
START
http://developer.java.sun.com/developer/community/chat/JavaLive/2001/jl0109.html
Sun community chat session on "Threading and Concurrency in the Java Platform" with Thomas Christopher and George Thiruvathukal
(Page last updated January 2001, Added 2001-02-21, Author Edward Ort).
4
<LI>If memory is at a premium, the cost of allocating a Thread object and allocating a stack can be expensive.
<LI>If there are real-time considerations, you do not have any scheduling and performance guarantees for threads.
<LI>Be careful about the number of threads you create: too many and you can exhaust your memory: too few and you don't get the advantages of parallelism.
<LI>Use javax.swing.SwingUtilities.invokeLater() [java.awt.EventQueue.invokeLater()] to schedule work onto the awt thread.
START
http://developer.java.sun.com/developer/Books/performance2/chap3.pdf
Chapter 3 of "High Performance Java Computing : Multi-Threaded and Networked Programming", "Race Conditions and Mutual Exclusion"
(Page last updated January 2001, Added 2001-02-21, Authors George Thiruvathukal, Thomas Christopher).
5
<LI>Execute I/O in blocks rather than one byte at a time.
<LI>I/O reads are normally faster than writes. This means that I/O performance can be improved by decoupling reading and writing to dedicated threads, rather than interleaving reads and writes.
<LI>volatile primitive datatypes cannot be cached, and have a write-through update policy allowing atomic read-writes, i.e. x++ is an atomic operation if x is volatile.
<LI>[The chapter describes implementations for lock objects (wait until unlocked), counting semaphore objects (wait until positive), barrier sempahore objects (wait until last thread is finished), future objects (wait until a variable is first set). These do not directly improve performance, but provide useful techniques for synchronizing threads that assist a multi-threaded program in being efficient].
<LI>Use resource enumeration (acquire resources in a set order) to avoid deadlocks.
START
http://developer.java.sun.com/developer/Books/performance2/chap4.pdf
Chapter 4 of "High Performance Java Computing : Multi-Threaded and Networked Programming", "Monitors"
(Page last updated January 2001, Added 2001-02-21, Authors George Thiruvathukal, Thomas Christopher).
3
<LI>Java monitors are not necessarily the most efficient synchronization mechanism, especially if transferring the lock can lead to a race condition [chapter discusses a more complete Monitor class].
<LI><CODE>volatile</CODE> fields can be slower than non-<CODE>volatile</CODE> fields, because the system is forced to store to memory rather than use registers. But they may useful to avoid concurrency problems.
<LI>[The chapter discusses various policies for synchronizing threads trying to read from or write to shared resources, which provide different scheduling policies: one thread at a time; readers-preferred (readers have priority); writers-preferred (writers have priority); alternating readers-writers (alternates between a single writer and a batch of readers); take-a-number (first-come, first-served)].
START
http://www.java-zone.com/free/articles/sf0101/sf0101-1.asp
Choosing a J2EE application server, emphasizing the importance of performance issues
(Page last updated February 2001, Added 2001-02-21, Author Steve Franklin).
4
<LI>Application server performance is affected by: the JDK version; connection pooling availability; JDBC version and optimized driver support; caching support; transactional efficiency; EJB component pooling mechanisms; efficiency of webserver-appserver connection; efficiency of persistence mechanisms.
<LI>Your application server needs to be load tested with scaling, to determine suitability.
<LI>Always validate the performance of the app server on the target hardware with peak expected user numbers.
<LI>Decide on what is acceptable downtime for your application, and ensure the app server can deliver the required robustness. High availability may require: transparent fail-over; clustering; load balancing; efficient connection pooling; caching; duplicated servers; scalable CPU support.
START
http://www.javaworld.com/javaworld/jw-01-2001/jw-0112-performance.html
Article on designing for performance focusing on interfaces
(Page last updated January 2001, Added 2001-02-21, Author Brian Goetz).
5
<LI>Avoid excessive object creation: be wary of object creation inside of tight loops when executing performance-critical code.
<LI>Performance-conscious programmers avoid excessive use of String.
<LI>Defining a utility class which is applied to data required by its constructor means that you must create a new object for every piece of data to run it on. Instead, do not require data in the constructor.
<LI>Do not force methods to provide arguments with input in the form that is convenient rather than efficient. For example, don't require that arguments be passed only as String objects if a byte array or char array would also be functionally equivalent (try to support all formats, especially the efficient ones).
<LI>Defining an interface in terms of an interchange type (the type of object passed from a caller method to the callee method as an argument) reduces the interface's complexity while maintaining its flexibility, but sometimes this simplicity comes at the cost of performance.
START
http://developer.java.sun.com/developer/technicalArticles/Programming/JVMPerf/
Sun engineering report on performance tests of various configurations of the 1.2.2 and 1.3 JVM
(Page last updated February 2001, Added 2001-02-21, Author Ed Ort).
5
<LI>Different versions of the Sun JVM support different optimization flags. Some flags may allow you to configure the garbage collector generational spaces.
<LI>Configure heap space using -Xms and -Xmx [-ms and -mx for 1.1.x JVMs] to optimize the JVM heap memory for improved performance.
<LI>If the JVM supports configuring the garbage collector generational spaces (-Xgenconfig in 1.2.2; -XX:newSize, -XX:MaxNewSize, -XX:SurvivorRatio in 1.3), then you can improve performance by specifying generation spaces more appropriate for your application [you can start with some appropriate configuration depending on the ratios of short-lived to medium-lived to long-lived objects, then test multiple configurations to determine the optimal config].
<LI>The 1.3 JVM appears to be faster when run with the -server flag.
<LI>The -Xoptimize flag seems to improve performance on those 1.2.x JVMs that support it.
START
http://www.jguru.com/jguru/faq/view.jsp?EID=131579
Discussion on JDBC performance
(Page last updated August 2000, Added 2001-02-21, Author Swarraj Kulkarni).
11
<LI>Use a connection pool mechanism whenever possible.
<LI>Use prepared statements.
<LI>Use stored procedures.
<LI>Select only required columns rather than using select * from Table xyz.
<LI>Always close Statement and ResultSet objects as soon as possible. 
<LI>Work with DatabaseMetaData to get information about database functionality.
<LI>Always catch <em>and</em> handle database warnings and exceptions.
<LI>Time DB queries.
<LI>Use the most appropriate datatype specific kinds of data, e.g. store dates as a date type rather than varchar. 
<LI>Use scrollable ResultSet (JDBC 2.0).
<LI>Stay away from the JDBC-ODBC and other Type 1 drivers where possible.
START
http://www.bastie.de/resource/res/mjp.pdf
Performance tuning report in German. As I don't speak German, it is difficult for me to comment any further
(Page last updated December 2000, Added 2001-02-21, Author Sebastian Ritter).
1
<LI>[Report is in German. I'd be delighted if someone extracted the tips].
START
http://docs.iplanet.com/docs/manuals/fasttrak/41/servlets/1-using.htm#17322
iPlanet Web Server guide to servlets, with a section at the end on "Maximizing Servlet Performance".
(Page last updated July 2000, Added 2001-02-21, Author ?).
3
<LI>Try to optimize the servlet loading mechanism, e.g. by listing the servlet first in loading configurations.
<LI>Tune the heap size.
<LI>Keep the classpath short.
START
http://www.webdevelopersjournal.com/columns/connection_pool.html
Article on connection pools
(Page last updated September 1999, Added 2001-02-21, Author Hans Bergsten).
2
<LI>Reuse database connections using a connection pool.
<LI>Put helper classes (non-servlet classes used by servlets) in the CLASSPATH of the servlet engine.
START
http://java.sun.com/docs/hotspot/PerformanceFAQ.html
HotSpot FAQ
(Page last updated August 2000, Added 2001-02-21, Author ?).
11
<LI>HotSpot has a bunch of startup options that may help you configure your VM to go faster.
<LI>HotSpot garbage collection parameters can be tuned with -Xincgc, -XX:NewSize, -XX:MaxNewSize and -XX:SurvivorRatio(and heap size parameters).
<LI>Sun recommends you no longer use objects pools [this is rather a sweeping and inappropriate statement. Object pools are still useful even with HotSpot, but presumably not as often as previously].
<LI>Undocumented option -Xconcurrentio may help performance when there are very many threads. It uses a lighter thread synchronization model.
<LI>If using few threads, using -XX:+UseBoundThreads and the light weight process threads (LWP) library may improve performance. LWP threads are scheduled by the JVM, system threads have kernel scheduling.
<LI>Don't call System.gc().
<LI>Warming loops is no longer necessary from HotSpot 2.0 (SDK 1.3). HotSpot now supports on-stack-replacement.
<LI>HotSpot supports -Xrunhprof options and also -Xaprof for object allocation statistics.
<LI>Integer alignment of generated native code affects its speed [so it is conceivable that adding the odd bytecode could make code faster].
<LI>HotSpot can eliminate "dead variables" and dead code, i.e. variables that are assigned to but never used [in isolated code segments].
<LI>The generational-GC per object costs varies depending on the length of life of the object.
START
http://www.onjava.com/pub/a/onjava/2001/02/22/optimization.html
Performance planning for managers
(Page last updated February 2001, Added 2001-03-21, Author Jack Shirazi).
10
<LI>Include budget for performance management.
<LI>Create internal performance experts.
<LI>Set performance requirements in the specifications.
<LI>Include a performance focus in the analysis.
<LI>Require performance predictions from the design.
<LI>Create a performance test environment.
<LI>Test a simulation or skeleton system for validation.
<LI>Integrate performance logging into the application layer boundaries.
<LI>Performance test the system at multiple scales and tune using the resulting information
<LI>Deploy the system with performance logging features.
START
http://developer.java.sun.com/developer/technicalArticles/ebeans/ejbperformance/
Designing Entity Beans for Improved Performance
(Page last updated March 2001, Added 2001-03-21, Author Beth Stearns).
4
<LI>Remember that every call of an entity bean method is potentially a remote call.
<LI>Designing with one access method per data attribute should only be used where remote access will not occur, i.e. entities are guaranteed to be in the same container.
<LI>Use a value object which encapsulates all of an entity's data attributes, and which transfers all the data in one network transfer. This may result in large objects being transferred though.
<LI>Group entity bean data attributes in subsets, and use multiple value objects to provide remote access to those subsets.
START
http://www.onjava.com/pub/a/onjava/2001/03/01/pseudo_sessions.html
Pseudo Sessions for JSP, Servlets and HTTP
(Page last updated March 2001, Added 2001-03-21, Author Budi Kurniawan).
3
<LI>Use pseudo sessions rather than <CODE>HttpSession</CODE>s to improve web server scalability.
<LI>Pseudo sessions reside on file instead of in memory, thus both decreasing memory and allowing sessions to be distributed across multiple servers.
<LI>Pseudo sessions do not use cookies, instead they alter URLs to encode the session, and so reduce the generation of session objects by cookie-declining browsers.
START
http://www.javaworld.com/javaworld/jw-02-2001/jw-0223-extremescale.html
Clustering for J2EE and Java application servers. Looks at Bluestone Total-e-server, Sybase Enterprise Application Server, SilverStream Application Server, and WebLogic Application Server.
(Page last updated February 2001, Added 2001-03-21, Author Abraham Kang).
7
<LI>A cluster in this context is a group of machines working together to transparently provide enterprise services.
<LI>A cluster can be implemented using a dispatcher which accepts requests and passes them on to other servers (either by redirecting the client or directly).
<LI>Clusters target to provide scalability and high-availability.
<LI>J2EE application servers implement clustering around their implementation of JNDI.
<LI>Clustering should allow failover if a machine/process crashes. For stateful sessions, this requires state replication.
<LI>Database and filesystem session persistence can limit scalability when storing large or numerous objects in the HttpSession.
<LI>To scale the static portions of your Website, add Web servers; to scale the dynamic portions of your site, add application servers.
START
http://www-106.ibm.com/developerworks/library/j-leaks/?dwzone=java
Tracking Memory leaks
(Page last updated February 2001, Added 2001-03-21, Author Jim Patrick).
5
<LI>An object is only counted as being unused when it is no longer referenced. If objects remain referenced unintentionally, this is a memory leak.
<LI>If you get a java.lang.OutOfMemoryError after a while, memory leakage is a strong suspect.
<LI>If an application is meant to run 24 hours a day, then memory leaks become highly significant.
<LI>Most JVMs grow towards the upper heap limit (-Xmx/-mx options) when more memory is required, and do not return memory to the operating system, even if the memory is no longer needed, until the JVM process terminates.
<LI>[Article provides an example of tracking memory leaks using JProbe].
START
http://www.sys-con.com/java/article.cfm?id=639
Benchmarking JMS
(Page last updated March 2001, Added 2001-03-21, Author Dave Chappell, Bill Wood).
5
<LI>Scaling middleware exposes a number of issues such as threading contention, network bottlenecks, message persistence issues, memory leaks, and overuse of object allocations.
<LI>[Article dicusses questions to ask when setting up benchmarks for messaging middleware].
<LI>Message traffic under high-volume conditions are unpredictable and bursty. Messages can be produced far faster than they can be consumed, causing congestion. This condition requires the message sends to be throttled with flow control (could be an exception, or an automatic resend).
<LI>When testing performance, run overnight and over weekends to generate longer term trends. Some concerns are: testing without a real network connection can give false measures; low user simulation can be markedly different from high user simulations; network throughput may be large than the deployed environment; nonpersistent message performance is dependent on processor and memory; disk speed is crucial for persistent messages.
<LI>[Article provides a benchmark harness for testing JMS].
START
http://www.javaworld.com/javaworld/jw-02-2001/jw-0223-performance.html
Designing Java Performance: reducing object creation
(Page last updated March 2001, Added 2001-03-21, Author Brian Goetz).
6
<LI>Watch out for method interfaces which force unnecessary or inefficient object creation.
<LI>Immutable objects are inefficient if you want to alter their structure, but efficient for sharing.
<LI>One way to avoid creating objects simply for information is to provide finer-grained methods which return information as primitives. This swaps object creation for increased method calls.
<LI>A second technique is to provide methods which accept dummy information objects that have their state overwritten to pass the information.
<LI>A third technique is to provide immutable classes with mutable subclasses, by having state defined as <CODE>protected</CODE> in the superclass, but with no public updators. The subclass provides public updators, hence making it mutable.
<LI>Don't try to speed up the application if there is no performance problem.
START
http://www.javaworld.com/javaworld/jw-03-2001/jw-0309-games.html
The performance of games on J2ME
(Page last updated March 2001, Added 2001-03-21, Author Jason R. Briggs).
4
<LI>Target performance for processors that you will run on when the project is deployed.
<LI>Implementing the ImageProducer interface and setting an image's pixels directly eliminates one or two steps in the MemoryImageSource option and seems to be about 10 percent to 20 percent faster on average.
<LI>Raw frame rate display, without taking account of the time taken to draw an image, runs from 2 frames per second (fps) to 400 fps, depending on processor and JVM. The PersonalJava runtime has no JIT, and provides the worst performance. With a JIT it might be usable.
<LI>[Article includes references to a number of hardware based Java implementations, i.e. Java enabled CPUs.]
START
http://developer.java.sun.com/developer/technicalArticles/Threads/applet/index.html
Introductory level article on threading applets
(Page last updated March 2001, Added 2001-03-21, Author Monica Pawlan).
4
<LI>Multi-threaded programs can allow multiple activities to continue without blocking the user.
<LI>Spawning additional threads carries extra memory and processor overhead, but can easily be worth the overheads.
<LI>Applets need a separate timer thread to execute any non-short tasks so that the applet remains responsive to the browser.
<LI>The volatile modifier requests the Java VM to always access the shared copy of the variable so the its most current value is always read. If two or more threads access a member variable, AND one or more threads might change that variable's value, AND ALL of the threads do not use synchronization (methods or blocks) to read and/or write the value, then  that member variable must be declared volatile to ensure all threads see the changed value.
START
http://www.javaworld.com/javaworld/jw-02-2001/jw-0216-jfile.html
Speeding up file searching in JFileChooser
(Page last updated February 2001, Added 2001-03-21, Author Slav Boleslawski).
1
<LI>[Article discusses JFileChooser's operation in detail, including multi-threading, filename caching and batched delivery. Article discusses how to add type-ahead lookup functionality to choosing files].
START
http://www.javaworld.com/javaworld/jw-02-2001/jw-0216-ternary.html
Using a ternary search tree for fast searches of partial text matches
(Page last updated February 2001, Added 2001-03-21, Author Wally Flint).
1
<LI>[Article discusses several efficient algorthms for searching through ternary search trees which provide fast partial match searches of character array keys].
START
http://www.as400.ibm.com/developer/java/topics/jdbctips.html
JDBC Performance Tips (targetted at AS/400, but generically applicable)
(Page last updated February 2001, Added 2001-03-21, Authors Richard Dettinger and Mark Megerian).
13
<LI>Move to the latest releases of Java as they become available.
<LI>Use prepared statements (PreparedStatement class) [article provides coded example of using Statement vs. PreparedStatement].
<LI>Note that two database calls are made for each row in a ResultSet: one to describe the column, the second to tell the db where to put the data. PreparedStatements make the description calls at construction time, Statements make them on every execution.
<LI>Avoid retrieving unnecessary columns: don't use "SELECT *".
<LI>If you are not using stored procedures or triggers, turn off autocommit. All transaction levels operate faster with autocommit turned off, and doing this means you must code commits. Coding commits while leaving autocommit on will result in extra commits being done for every db operation.
<LI>Use the appropriate transaction level. Increasing performance costs for transaction levels are: TRANSACTION_NONE; TRANSACTION_READ_UNCOMMITTED; TRANSACTION_READ_COMMITTED; TRANSACTION_REPEATABLE_READ; TRANSACTION_SERIALIZABLE. Note that TRANSACTION_NONE, with autocommit set to true gives access to triggers, stored procedures, and large object columns.
<LI>Store string and char data as Unicode (two-byte characters) in the database.
<LI>Avoid expensive database query functions such as: getBestRowIdentifier; getColumns; getCrossReference; getExportedKeys; getImportedKeys; getPrimaryKeys; getTables; getVersionColumns.
<LI>Use connection pooling, either explicitly with your own implementation, or implicitly via a product that supports connection pooling.
<LI>Use blocked fetchs (fetching table data in blocks), and tailor the block size to reduce calls to the database, according to the amount of data required.
<LI>Use batch updates (sending multiple rows to the database in one call).
<LI>Use stored procedures where appropriate. These benefit by reducing JDBC complexity, are faster as they use static SQL, and move execution to the server and potentially reduce network trips.
<LI>Use the type-correct get() method, rather than getObject().
START
http://www.javaworld.com/javaworld/jw-03-2001/jw-0316-jdk.html
JDK 1.4 features update
(Page last updated March 2001, Added 2001-03-21, Author Vinay Aggarwal).
8
<LI>New standardized logging API.
<LI>JDBC 3.0 includes connection pooling, connection pool configurations, reuse of prepared statements with connection pools, multiple open result sets on a statement, distributed transactions, CachedRowSets, and hooks to insert custom reader/writer classes.
<LI>Assertions with new <CODE>assert</CODE> keyword.
<LI>RMI support for customized remote objects and custom communications.
<LI>Class reloading without customized classloaders.
<LI>Scalable I/O including asynchronous requests and [presumably efficient] polling.
<LI>64-bit support in the JVM, class sharing across JVMs, faster classloading.
<LI>Faster rendering in Java 2D, smaller jar files.
START
http://www.weblogic.com/docs51/admindocs/tuning.html
Weblogic tuning (generally applicable Java tips extracted)
(Page last updated June 2000, Added 2001-03-21, Author BEA Systems).
11
<LI>Response time is affected by: contention and wait times, particularly for shared resources; and software and hardware component performance, i.e. the amount of time that resources are needed. 
<LI>A well-designed application can increase performance by simply adding more resources (for instance, an extra server).
<LI>Use clustered or multi-processing machines; use a JIT-enabled JVM; use Java 2 rather than JDK 1.1;
<LI>Use -noclassgc. Use the maximum possible heap size that also is small enough to avoid the JVM from swapping (e.g. 80% of RAM left over after other required processes). Consider starting with minimum initial heap size so that the garbage collector doesn't suddenly encounter a full heap with lots of garbage. Benchmarkers sometimes like to set the heap as high as possible to completely avoid GC for the duration of the benchmark.
<LI>Distributing the application over several server JVMs means that GC impact will be spread in time, i.e. the various JVMs will most likely GC at different times from each.
<LI>On Java 1.1 the most effective heap size is that which limits the longest GC incurred pause to the longest acceptable pause in processing time. This will typically require a <em>reduction</em> in the maximum heap size.
<LI>Too many threads causes too much context switching. Too few threads may underutilize the system. If n=number of threads, k=number of CPUs, then: (n < k) results in an under utilized CPU;  (n == k) is theoretically ideal, but each CPU will probably be under utilized; (n > k) by a "moderate amount of threads" is practically ideal; (n > k) by "many threads" can lead to significant performance degradation from context switching. Blocked threads count for less in the previous formulae.
<LI>Symptoms of too few threads: CPU is waiting to do work, but there is work that could be done; Can not get 100% CPU; All threads are blocked [on i/o] and runnable when you do an execution snapshot.
<LI>Symptoms of too many threads: An execution snapshot shows that there is a lot of context switching going on in your JVM; Your performance increases as you decrease the number of threads.
<LI>If many client connections are dropped or refused, the TCP listen queue may be too short.
<LI>Try to avoid excessive cycling (creation/deletion or activation/passivation) of beans.
START
http://www.weblogic.com/docs51/techdeploy/jdbcperf.html
Weblogic JDBC tuning
(Page last updated April 1999, Added 2001-03-21, Author BEA Systems).
16
<LI>Use connection pools to the database. Optimal pool size is when the connection pool is just large enough to service requests without waits.
<LI>Cache frequently requested data in the JVM and avoid the unnecessary database requests.
<LI>Use zip files to download classes all together to an applet.
<LI>Avoid accessing the database wherever possible.
<LI>Pre-fetch rows in batches. Tune the number of rows pre-fetched. Avoid pre-fetching BLOBs.
<LI>Avoid moving data unless absolutely necessary. Process the data and produce results as close to its source as possible. Use stored procedures.
<LI>Use set processing, not row at a time processing. Process multiple rows together wherever possible.
<LI>Counting entries in a table (e.g. using <CODE>SELECT count(*) from myTable, yourTable where ... </CODE>) is resource intensive. Try first selecting into temporary tables, returning only the count, and then sending a refined second query to return only a subset of the rows in the temporary table.
<LI>Proper use of SQL can reduce resource requirements. Use queries which return the minimum of data needed: avoid <CODE>SELECT *</CODE> queries. A complex query that returns a small subset of data is more efficient than a simple query that returns more data than is needed.
<LI>Try to batch updates: collect statements together and execute them together in one transaction. Use conditional logic and temporary if necessary to achieve statement batching.
<LI>Never let a DBMS transaction span user input.
<LI>Consider using optimistic locking. Optimistic locking employs timestamps to verify that data has not been changed by another user, otherwise the transaction fails.
<LI>Use in-place updates. Try to avoid moving rows or changing their sizes.
<LI>Store operational data and historic data separately (or more generally store frequently used data separately from infrequently used data).
<LI>DBMSs work well with parallelism. Try to design the application to do other things while interacting with the DBMS.
<LI>Choose the fastest JDBC driver.
START
http://www.weblogic.com/docs51/techoverview/rmi.html
Weblogic's RMI framework
(Page last updated January 1999, Added 2001-03-21, Author BEA Systems).
5
<LI>Use a single, multiplexed, asynchronous, bidirectional connection for RMI client-to-network traffic instead of the standard reference implementation using multiple sockets.
<LI>Try to improve the serialization mechanism for faster RMI [Externalization is better].
<LI>Use local calls for objects located in the same JVM.
<LI>Minimize distributed garbage collection.
<LI>Use smart stubs which provide data caching and localized execution in addition to the normal remote execution and data fetching capabilities.
START
http://www.javaworld.com/javaworld/jw-03-2000/jw-03-javaperf_2.html
Basic performance tuning intro
(Page last updated March 2000, Added 2001-03-21, Author Reggie Hutcherson).
1
<LI>Use a JIT-enabled JVM or HotSpot.
START
http://www.javareport.com/html/from_pages/article.asp?id=799&mon=4&yr=2001
Various strategies for connecting to databases
(Page last updated March 2001, Added 2001-04-20, Author Prakash Malani).
5
<LI>Use pooled connections to reduce connection churn overheads.
<LI>javax.sql.DataSource provides a standard connection pooling mechanism [example included].
<LI>Obtain and release pooled conections within each method that requires the resource if the connection is very short (termed "Quick Catch-and-Release Strategy" in the article). However do not release the connection only to use it again almost immediately, instead hold the connection until it will not be immediately needed.
<LI>The performance penalty of obtaining and releasing connections too frequently is quite small in comparison to potential scalability problems or issues raised because EntityBeans are holding on to the connections for too long.
<LI>The "Quick Catch-and-Release Strategy" is the best default strategy to ensure good performance and scalability.
START
http://www.javaworld.com/javaworld/jw-03-2001/jw-0323-performance.html
Designing remote interfaces
(Page last updated March 2001, Added 2001-04-20, Author Brian Goetz).
12
<LI>Remote object creation has overheads: several objects needed to support the remote object are also created and manipulated.
<LI>Remote method invocations involve a network round-trip and marshalling and unmarshaling of parameters. This adds together to impose a significant latency on remote method invocations.
<LI>Different object parameters can have very different marshalling and unmarshaling costs.
<LI>A poorly designed remote interface can kill a program's performance.
<LI>Excessive remote invocation network round-trips are a huge performance problem.
<LI>Calling a remote method that returns multiple values contained in a temporary object (such as a Point), rather than making multiple consecutive method calls to retrieve them individually, is likely to be more efficient. (Note that this is exactly the opposite of the advice offered for good performance of local objects.)
<LI>Avoid unnecessary round-trips: retrieve several related items simultaneously in one remote invocation, if possible.
<LI>Avoid returning remote objects when the caller may not need to hold a reference to the remote object.
<LI>Avoid passing complex objects to remote methods when the remote object doesn't necessarily need to have a copy of the object.
<LI>If a common high-level operation requires many consecutive remote method calls, you need to revisit the class's interface.
<LI>A naively designed remote interface can lead to an application that has serious scalability and performance problems.
<LI>[Article gives examples showing the effect of applying the listed advice].
START
http://www.microjava.com/articles/techtalk/object_lists?content_id=1152
Basic article on a minimal ArrayList implementation, from a micro-Java slant
(Page last updated March 2001, Added 2001-04-20, Author Lee Miles).
3
<LI>ArrayLists are the fastest SDK collection class.
<LI>System.arraycopy provides an efficient method for copying arrays.
<LI>You should request garbage collection whenever elements are dereferenced (e.g. the list is cleared).
START
http://developer.java.sun.com/developer/JDCTechTips/2001/tt0327.html
How to use java.rmi.MarshalledObject
(Page last updated March 2001, Added 2001-04-20, Author Stuart Halloway).
1
<LI>MarshalledObject lets you postpone deserializing objects. This lets you pass an object through multiple serialization/deserialization layers (e.g. passing an object through many JVMs), without incurring the serialization/deserialization overheads until absolutely necessary.
START
http://developer.java.sun.com/developer/community/chat/JavaLive/2001/jl0327.html
Sun community chat session: Tuning the Java Runtime for "Big Iron"
(Page last updated March 2001, Added 2001-04-20, Author Edward Ort).
13
<LI>Use the -server option. Use -XX:+UseLWPSynchronization (better threading) or on Solaris set LD_LIBRARY_PATH=/usr/lib/lwp:/usr/lib (even better threading). 
<LI>Set the "young" generation space to 1/4 to 1/3 of heap space, e.g. -Xms1024m -Xmx1024m -XX:NewSize=256m -XX:MaxNewSize=256m. On Solaris use vmstat, pstat (utilities) and -verbose:gc (runtime option).
<LI>GC is single-threaded (at least to 1.3.x), so cannot take advantage of multiple-CPUs (i.e. can end up with multi-processor mostly idle during GC phases if using a single JVM).
<LI>Too many threads can lead to thread "starvation" [presumably thrashing].
<LI>Use at least one thread per CPU, more if any threads will be i/o blocked. On Solaris use the mpstat utility to monitor CPU utlization.
<LI>1.4 will include concurrent GC that should avoid large GC pauses.
<LI>The biggest performance problem is bad design.
<LI>Use: -XX:NewSize=<value> -XX:MaxNewSize=<value> rather than -XX:SurvivorRatio and -XX:NewRatio.
<LI>Set initial heap size to max heap size when you know what size heap you'll want and you want to avoid wasting time growing the heap as you'll fill up space. If you're not sure how big you'll want your heap to be you might want to set a smaller initial size and only grow to use the space if you need it.
<LI>Low CPU utilization together with bad performance may indicate GC, synchronization, I/O or network inefficiencies.
<LI>-XX:MaxPermSize affects Perm Space size (storage for HotSpot internal data structures), and only needs altering if a really large number of classes are being loaded.
<LI>[The session also discussed some Solaris OS parameters to tune].
<LI>For JDK 1.3, the heap is: TotalHeapSize = -Xmx setting + MaxPermSize; with -Xmx split into new and old spaces [i.e. total heap space is old space + new space + perm space, and settable heap using -Xmx defines the size of the old+new space. -XX:MaxNewSize defines how much of -Xmx heap space goes to new space].
START
http://www.sys-con.com/java/article.cfm?id=673
J2EE Application servers
(Page last updated April 2001, Added 2001-04-20, Authors Christopher G. Chelliah and Sudhakar Ramakrishnan).
7
<LI>A scalable server application probably needs to be balanced across multiple JVMs (possibly pseudo-JVMs, i.e. multiple logical JVMs running in the same process).
<LI>Performance of an application server hinges on caching, load balancing, fault tolerance, and clustering.
<LI>Application server caching should include web-page caches and data access caches. Other caches include caching servers which "guard" the application server, intercepting requests and either returning those that do not need to go to the server, or rejecting or delaying those that may overload the app server.
<LI>Application servers should use connection pooling and database caching to minimize connection overheads and round-trips.
<LI>Load balancing mechanisms include: round-robin DNS (alternating different IP-addresses assigned to a server name); and re-routing mechanisms to distribute requests across multiple servers. By maintaining multiple re-routing servers and a client connection mechanism that automatically checks for an available re-routing server, fault tolerance is added.
<LI>Using one thread per user can become a bottleneck if there are a large number of concurrent users.
<LI>Distributed components should consider the proximity of components to their data (i.e., avoid network round-trips) and how to distribute any resource bottlenecks (i.e., CPU, memory, I/O) across the different nodes.
START
http://www.sys-con.com/java/article.cfm?id=671
J2EE Application server performance
(Page last updated April 2001, Added 2001-04-20, Author Misha Davidson).
18
<LI>Good performance has sub-second latency (response time) and hundreds of (e-commerce) transactions per second.
<LI>Avoid n-way database joins: every join has a multiplicative effect on the amount of work the database has to do. The performance degradation may not be noticeable until large datasets are involved.
<LI>Avoid bringing back thousands of rows of data: this can use a disproportionate amount of resources.
<LI>Cache data when reuse is likely.
<LI>Avoid unnecessary object creation.
<LI>Minimize the use of synchronization.
<LI>Avoid using the SingleThreadModel interface for servlets: write thread-safe code instead.
<LI>ServletRequest.getRemoteHost() is very inefficient, and can take seconds to complete the reverse DNS lookup it performs.
<LI>OutputStream can be faster than PrintWriter. JSPs are only generally slower than servlets when returning binary data, since JSPs always use a PrintWriter, whereas servlets can take advantage of a faster OutputStream.
<LI>Excessive use of custom tags may create unnecessary processing overhead.
<LI>Using multiple levels of BodyTags combined with iteration will likely slow down the processing of the page significantly.
<LI>Use optimistic transactions: write to the database while checking that new data is not be overwritten by using WHERE clauses containing the old data. However note that optimistic transactions can lead to worse performance if many transactions fail.
<LI>Use lazy-loading of dependent objects.
<LI>For read-only queries involving large amounts of data, avoid EJB objects and use JavaBeans as an intermediary to access manipulate and store the data for JSP access.
<LI>Use stateless session EJBs to cache and manage infrequently changed data. Update the EJB occasionally.
<LI>Use a dedicated session bean to perform and cache all JNDI lookups in a minimum number of requests.
<LI>Minimize interprocess communication.
<LI>Use clustering (multiple servers) to increase scalability.
START
http://www.javaworld.com/javaworld/jw-04-2001/jw-0406-syslog.html
Using the Syslog class for logging
(Page last updated April 2001, Added 2001-04-20, Author Nate Sammons).
4
<LI>Use Syslog to log system performance.
<LI>Logging should not take up a significant amount of the system's resources nor interfere with its operation.
<LI>Use <CODE>static final boolean</CODE>s to wrap logging statements so that they can be easily truned off or eliminated.
<LI>Beware of logging to slow external channels. These will slow down logging, and hence the application too.
START
http://developer.java.sun.com/developer/Books/performance/performance2/appendixa.pdf
Appendix A (Garbage Collection) of "Java Platform Performance: Strategies and Tactics."
(Page last updated 2001, Added 2001-04-20, Authors Steve Wilson, Jeff Kesselman).
4
<LI>Large RAM requirements can force the OS to use virtual memory, which slows down the application.
<LI>Most JVM implementations will not dereference temporary objects until the method has gone out of scope, even if the object is created in an inner block which has gone out of scope. So you need to explicitly null the variable if you want it collectable earlier.
<LI>Adding a finalizer method extends the life of the object, since it cannot be collected until the finalize() method is run.
<LI>Do not use finalizers to free resources in a timely manner.
START
http://www.AmbySoft.com/javaCodingStandards.pdf
Coding standards with a small but interesting section (section 7.3) on optimizations
(Page last updated January 2000, Added 2001-04-20, Author Scott Ambler).
8
<LI>Optimizing code is one of the last things that programmers should be thinking about, not one of the first.
<LI>Don't optimize code that already runs fast enough.
<LI>Prioritize where speed comes among the following factors, so that goals are better defined: speed, size, robustness, safety, testability, maintainability, simplicity, reusability, and portability.
<LI>The most important factors in looking for code to optimize are fixed overhead and performance on large inputs: fixed overhead dominates speed for small inputs and the algorithm dominates for large inputs (a program that works well for both small and large inputs will likely work well for medium-sized inputs).
<LI>Operations that take a particular amount of time, such as the way that memory and buffers are handled, often show substantial time variations between platforms.
<LI>Users are sensitive to particular delays: users will likely be happier with a screen that draws itself immediately and then takes eight seconds to load data than with a screen that draws itself after taking five seconds to load data.
<LI>Give users immediate feedback: you do not always need to make your code run faster to optimize it in the eyes of your users.
<LI>Slow software that works is almost always preferable to fast software that does not.
START
http://developer.java.sun.com/developer/J2METechTips/2001/tt0416.html
Using Timers (java.util.Timer)
(Page last updated April 2001, Added 2001-04-20, Author Eric Giguere).
1
<LI>Timers provide a simple mechanism for repeatedly executing a task at a set interval [with simplicity being the keyword here. Don't look for anything sophisticated like thread interrupt control].
START
http://www-106.ibm.com/developerworks/java/library/j-super.html
Parallel clustering of machines using Java
(Page last updated April 2001, Added 2001-04-20, Author Aashish N. Patil).
1
<LI>[Article describes an implemented architecture for distributing Runnable threads across multiple computer nodes].
START
http://developer.java.sun.com/developer/TechTips/2000/tt0829.html
The Javap disassembler
(Page last updated August 2000, Added 2001-04-20, Author Stuart Halloway).
3
<LI>[Article describes using the <CODE>javap</CODE> disassembler, useful for identifying exactly what the code has been compiled into].
<LI>Use the <CODE>javap</CODE> disassembler to determine the efficiency of generated bytecodes.
<LI><CODE>javap</CODE> is not sufficient to determine code efficiency, because JIT compilers can apply additional optimizations.
START
http://billharlan.com/pub/papers/Improving_Swing_Performance.html
Swing performance tips
(Page last updated 1999, Added 2001-05-21, Author Bill Harlan).
6
<LI>Redraw events can easily be generated faster than the redraw can execute. Ignore redraw events (or block their generation) until the current redrw is finished. Don't up redraw events.
<LI>Consider holding redraw events for a few milliseconds to see if it can be discarded due to getting another redraw event.
<LI>If possible, consider drawing to off-screen buffers, and execute copies from that buffer in response to redraws, rather than actualy redrawing.
<LI>Extend from JPanel, not Canvas; override paintComponent(), not paint().
<LI>Action listeners are all executed in the <em>one</em> event-dispatching thread. Time-consuming listeners should execute their work in a separate thread and should avoid blocking the event-dispatching thread. (To reenter the event-dispatching thread calling SwingUtilities.invokeLater() or invokeAndWait()).
<LI>Add event listeners after initialization of components have finished. 
START
http://java.sun.com/products/jfc/tsc/articles/performance/index.html
Swing performance tips
(Page last updated March 2001, Added 2001-05-21, Author Steve Wilson).
5
<LI>Use the latest version of Swing available, as the Swing development team have an ongoing project tp improve performance.
<LI>When JScrollPane is scrolled, the entire visible contents of the scroll pane are redrawn. A backing store (off screen buffer) can be enabled using setBackingStoreEnabled(true) to speed up redraws, but this has some limitations: an extra buffer to copy can be significant for simple drawing operations; the backing store doesn't work when scrollRectToVisible() is called directly by the programmer (depends on Swing version); extra RAM is needed to maintain the extra backing buffer.
<LI>Use window blitting (may be default depending on Swing version) enabled with scrollpane.getViewport().putClientProperty("EnableWindowBlit", Boolean.TRUE).
<LI>Enable outline dragging (no redrawing while dragging) with JDesktopPane.putClientProperty("JDesktopPane.dragMode", "outline").
<LI>Enable faster dragging using blitting with JDesktopPane.putClientProperty("JDesktopPane.dragMode", "faster").
START
http://www.stqemagazine.com/featured.asp?id=10
Web application scalability.
(Page last updated June 2000, Added 2001-05-21, Author Billie Shea).
15
<LI>Web application scalability is the ability to sustain the required number of simultaneous users and/or transactions, while maintaining adequate response times to end users.
<LI>The first solution built with new skills and new technologies will <em>always</em> have room for improvement.
<LI>Avoid deploying an application server that will cause embarrassment, or that could weaken customer confidence and business reputation [because of bad response times or lack of calability].
<LI>Consider application performance throughout each phase of development and into production.
<LI>Performance testing must be an integral part of designing, building, and maintaining Web applications.
<LI>There appears to be a strong correlation between the use of performance testing tools and the likelihood that a site would scale as required.
<LI>Automated performance tests must be planned for and iteratively implemented to identify and remove bottlenecks.
<LI>Validate the architecture: decide on the maximum scaling requirements and then performance test to validate the necessary performance is achievable. This testing should be done on the prototype, before the application is built.
<LI>Have a clear understanding of how easily your configurations of Web, application, and/or database servers can be expanded.
<LI>Factor in load-balancing software and/or hardware in order to efficiently route requests to the least busy resource.
<LI>Consider the effects security will have on performance: adding a security layer to transactions will impact response times. Dedicate specific server(s) to handle secure transactions.
<LI>Select performance benchmarks and use them to quantify the scalability and determine performance targets and future performance improvements or degradations. Include all user types such as "information-gathering" visitors or "transaction" visitors in your benchmarks.
<LI>Perform "Performance Regression Testing": continuously re-test and measure against the established benchmark tests to ensure that application performance hasn’t been degraded because of the changes you’ve made.
<LI>Performance testing must continue even after the application is deployed.  For applications expected to perform 24/7 inconsequential issues like database logging can degrade performance. Continuous monitoring is key to spotting even the slightest abnormality: set performance capacity thresholds and monitor them.
<LI>When application transaction volumes reached 40%, it is time to start executing plans to expand the system
START
http://www.stqemagazine.com/featured.asp?id=15
Web Load Test Planning
(Page last updated April 2001, Added 2001-05-21, Author Alberto Savoia).
6
<LI>The only reliable way to determine a system’s scalability is to perform a load test in which the volume and characteristics of the anticipated traffic are simulated as realistically as possible.
<LI>It is hard to design and develop load tests that come close to matching real loads.
<LI>Characterize the anticipated load as objectively and systematically as possible: use existing log files where possible; characterize user sessions (pages viewed - number and types; duration of session; etc). Determine the range and distribution of variations in sessions. Don't use averages, use representative profiles.
<LI>Estimate target load and peak levels: estimate overall and peak loads for the server and expected growth rates.
<LI>Estimate how quickly target peaks levels will be reached, and for how long they will be sustained. The duration of the peak is important and the server must be designed to handle it.
<LI>The key elements of a load test design are: test objective (e.g. can the server handle N sessions/hr peak load level?); pass/fail criteria (e.g. pass if response times stay within define values); script description (e.g. user1: page1, page2, ...; user2: page1, page3, start transaction1, etc); scenario description (which scripts at which frequency, and how load increases).
START
http://developer.java.sun.com/developer/JDCTechTips/2001/tt0518.html#optimizing
Optimizing StringBuffer usage
(Page last updated May 2001, Added 2001-05-21, Author Glen McCluskey).
1
<LI>Pre-size the StringBuffer to the expected result String size where possible.
START
http://www.javaworld.com/javaworld/jw-05-2001/jw-0504-cache.html
Faster JSP with caching
(Page last updated May 2001, Added 2001-05-21, Author Serge Knystautas).
3
<LI>The (open source) OSCache tag library provides fast in-memory caching.
<LI>Cache pages or page sections for a set length of time, rather than update the page (section) with each request.
<LI>Caching can give a trade-off between memory usage and CPU usage, especially if done per-session. This trade-off must be balanced correctly for optimal performance.
START
http://forums.itworld.com/webx?14@@.ee6b80a/534!skip=470
Stateful vs. Stateless EJBs
(Page last updated May 2001, Added 2001-05-21, Author Chuck Caveness, Doug Pardee).
1
<LI>Stateless session beans can support multiple clients, thus increasing scalability.
START
http://developer.java.sun.com/developer/qow/archive/134/index.jsp
Improving socket transfer rates
(Page last updated May 2001, Added 2001-05-21, Author Rama Roberts).
3
<LI>The usual "StringBuffer better than String" tip applies to socket communications too.
<LI>PrintWriters are not suitable for socket communications because they flush at each newline.
<LI>Socket.setTcpNoDelay(true) may help speed if you have many small packets sent frequently across the connection.
START
http://www.theserverside.com/resources/article.jsp?l=Tips-On-Performance-Testing-And-Optimization
Server performance testing
(Page last updated 2000, Added 2001-05-21, Author Floyd Marinescu).
8
<LI>Test response times against average current data/user volumes, then repeat the same test against four times as much volume as you expect in 3 years time. This defines your long term target - getting the response times the same for that latter test.
<LI>Response time increasing too much when database is over populated probably indicates lack of or inappropriate indexing on the database.
<LI>Response time increasing exponentially as load increases, you need to improve scalability by optimizing the application or adding resources.
<LI>Use SQL clause with EXPLAIN or similar (e.g. "Explain select * from table where tablefield = somevalue") to ensure that the database is doing an indexed search rather than a linear searches of large datasets.
<LI>Use a profiler to determine object usage, garbage collection behaviour and method bottlenecks in the application.
<LI>Minimize network calls, especially database calls: make one large database call rather than many small ones; make sure ejbStore isn’t storing anything for read only operations; use Details Objects to get entity bean state rather than making many trips for each aspect of state.
<LI>Use caching where possible.
<LI>Use session beans as a façade to your entity beans to encapsulate the workflow of one entire usecase in one network call to one method on a session bean (and one transaction).
START
http://developer.java.sun.com/developer/technicalArticles/ebeans/sevenrules/
Optimizing entity beans
(Page last updated May 2001, Added 2001-05-21, Author Akara Sucharitakul).
6
<LI>Use container-managed persistence when you can. An efficient container can avoid database writes when no state has changed, and reduce reads by retrieving records at the same time as find() is called.
<LI>Minimize database access in ejbStores. Use a "dirty" flag to avoid writing teh bean unless it has been changed.
<LI>Always cache references obtained from lookups and find calls. Always define these references as instance variables and look them up in the setEntityContext (method setSessionContext for session beans).
<LI>Always prepare your SQL statements.
<LI>Close all database access/update statements properly.
<LI>Avoid deadlocks. Note that the sequence of ejbStore calls is not defined, so the developer has no control over the access/locking sequence to database records.
START
http://www.sys-con.com/java/article.cfm?id=658
EJB best practices
(Page last updated April 2001, Added 2001-05-21, Author Sandra L. Emerson, Michael Girdley, Rob Woollen).
5
<LI>To avoid resources being held unnecessarily for long periods, a transaction should never encompass user input or user think time.
<LI>Container managed transactions are preferred for consistency, and should provide extra optimization options.
<LI>Don't model a shared cache or any shared resource as a stateful session bean.
<LI>Stateless session beans are easier to scale than stateful session beans. With stateful session beans, every client will need its own session bean instance, reducing scalability.
<LI>Always call remove after finishing with a stateful session bean instance, otherwise the EJB container will eventually passivate the bean, incurring extra unnecessary disk writes.
START
http://forums.itworld.com/webx?14@@.ee6bdcf/598!skip=542
Avoiding memory leaks in EJBs
(Page last updated April 2001, Added 2001-05-21, Author Govind Seshadri).
5
<LI>Make sure that any beans which have session scope implement the HttpSessionBindingListener interface
<LI>Explicitly release any resources that may be used within the bean by implementing the valueUnbound() callback.
<LI>Explicitly release the user's session by invoking invalidate() when they log out.
<LI>Try setting the session invalidation interval to a smaller value than the default 30 minutes.
<LI>Make sure that you are not placing any large grained objects into the servlet context (application scope) as that can also prove problematic sometimes.
START
http://www.onjava.com/pub/a/onjava/2001/05/30/optimization.html
Comparing the performance of LinkedLists and ArrayLists (and Vectors)
(Page last updated May 2001, Added 2001-06-18, Author Jack Shirazi).
17
<LI>ArrayList is faster than Vector except when there is no lock acquisition required in HotSpot JVMs (when they have about the same performance).
<LI>Vector and ArrayList implementations have excellent performance for indexed access and update of elements, since there is no overhead beyond range checking.
<LI>Adding elements to, or deleting elements from the end of a Vector or ArrayList also gives excellent performance except when the capacity is exhausted and the internal array has to be expanded.
<LI>Inserting and deleting elements to Vectors and ArrayLists always require an array copy (two copies when the internal array must be grown first). The number of elements to be copied is proportional to [size-index], i.e. to the distance between the insertion/deletion index and the last index in the collection. The array copying overhead grows significantly as the size of the collection increases, because the number of elements that need to be copied with each insertion increases.
<LI>For insertions to Vectors and ArrayLists, inserting to the front of the collection (index 0) gives the worst performance, inserting at the end of the collection (after the last element) gives the best performance. 
<LI>LinkedLists have a performance overhead for indexed access and update of elements, since access to any index requires you to traverse multiple nodes.
<LI>LinkedList insertions/deletion overhead is dependent on the how far away the insertion/deletion index is from the closer end of the collection.
<LI>Synchronized wrappers (obtained from Collections.synchronizedList(List)) add a level of indirection which can have a high performance cost.
<LI>Only List and Map have efficient thread-safe implementations: the Vector and Hashtable classes respectively.
<LI>List insertion speed is critically dependent on the size of the collection and the position where the element is to be inserted.
<LI>For small collections ArrayList and LinkedList are close in performance, though ArrayList is generally the fasterof the two. Precise speed comparisons depend on the JVM and the index where the object is being added.
<LI>Pre-sizing ArrayLists improves performance significantly. LinkedLists cannot be pre-sized.
<LI>ArrayLists can generate far fewer objects for the garbage collector to reclaim, compared to LinkedLists.
<LI>For medium to large sized Lists, the location where elements are to inserted is critical to the performance of the list. ArrayLists have the edge for random access.
<LI>A dedicated List implementation designed to match data, collection types and data manipulation algorithms will always provide the best performance.
<LI>ArrayList internal node traversal from the start to the end of the collection is significantly faster than LinkedList traversal. Consequently queries implemented in the class can be faster.
<LI>Iterator traversal of all elements is faster for ArrayList compared to Linkedlist.
START
http://library.cs.tuiasi.ro/programming/java/cutting_edge_java_game_programming/ewtoc.html
"Cutting Edge Java Game Programming". Oldish but still useful intro book to games programming using Java.
(Page last updated 1996, Added 2001-06-18, Author Neil Bartlett, Steve Simkin ).
37
<LI>AWT components are not useful as game actors (sprites) as they do not overlap well, nor are they good at being moved around the screen.
<LI>Celled image files efficiently store an animated image by dividing an image into a rectangular grid of cells, and allocating a different animation image to each cell. A sequence of similar images (as you would have for an animation) will be stored and transferred efficiently in most image formats.
<LI>Examining pixels using PixelGrabber is slow.
<LI>drawImage() can throw away and re-load images in response to memory requirements, which can make things slow.
<LI>Pre-load and pre-scale images before using them to get a smoother and faster display.
<LI>The more actors (sprites), the more time it takes to draw and the slower the game appears.
<LI>Use double-buffering to move actors (sprites), by redrawing the actor and background for the relevant area.
<LI>Redraw speed depends on: how quickly each object is drawn; how many objects are drawn; how much of each object is drawn; the total number of drawing operations. You need to reduce some or all of these until you get to about 30 redraws per second.
<LI>Don't draw actors or iages that cannot be seen.
<LI>If an actor is not moving then incorporate the actor as part of the background.
<LI>Only redraw the area that has changed, e.g. the old area where an actor was, and the new area where it is. Redrawing several small areas is frequently faster than drawing one large area. For the redraws, eliminate overlapping areas and merge adjacent (close) areas so that the number of redraws is kept to a minimum.
<LI>Put slow and fast drawing requirements in separate threads.
<LI>Bounding-box detection can use circles for the bounding box which requires a simple radii detection.
<LI>Load sounds in a background thread.
<LI>Make sure you have a throttle control that can make the game run slower (or pause) when necessary.
<LI>The optimal network topology for network games depends on the number of users.
<LI>If the cumulative downloading of your applet exceeds the player’s patience, you’ve lost a customer.
<LI>The user interface should always be responsive. A non-responsive window means you will lose your players. Give feedback on necessary delays. Provide distractions when unavoidable delays will be lengthy [more than a few seconds].
<LI>Transmission time varies, and is always slow compared to operations on the local hardware. You may need to decide the outcome of the action locally, then broadcast the result of the action. This may require some synchronization resolution.
<LI>Latency between networked players can easily lead to de-synchronized action and player frustration. Displays should locally simulate remote action as continuing current activities/motions, until the display is updated. On update, the actual current situation should be smoothly resolved with the simulated current situation.
<LI>Sending activity updates more frequently ensures smoother play and better synchronization between networked players, but requires more CPU effort and so affects the local display. In order to avoid adversely affecting local displays, send actvity updates from a low priority thread.
<LI>Discard any out-of-date updates: always use the latest dated update.
<LI>A minimum broadcast delay of one-third the average network connection travel time is appropriate. Once you exceed this limit, the additional traffic can cause more grief than benefit.
<LI>Put class files into a (compressed) container for network downloading.
<LI>Avoid repeatedly evaluating invariant expressions in a loop.
<LI>Take advantage of inlining where possible (using final, private and static keywords, and compiling with javac -O)
<LI>Profile the code to determine the expensive methods (e.g. using the -prof option)
<LI>Use a dissassembler (e.g. like javap) to determine which of various alternative coding formulations produces smaller bytecode.
<LI>To reduce the number of class files and their sizes: use the SDK classes as much as possible; and implement common functionality in one place only.
<LI>To optimize speed: avoid synchronized methods; use buffered I/O; reuse objects; avoid unnecessary screen painting.
<LI>Raycasting is faster than raytracing. Raycasting maps 2D data into a 3D world, drawing entire vertical lines using one ray. Use precalculated values for trignometric and other functions, based on the angle increments chosen for your raycasting.
<LI>In the absence of a JIT, the polygon drawing routines fron the AWT are relatively efficient (compared to array manipulation) and may be faster than texture mapping.
<LI>Without texture mapping, walls can be drawn faster with one call to fillPolygon (rather than line by line).
<LI>An exponential jump search algorithm can be used to reduce ray casts - by quickly finding boundaries where walls end (like a binary search, but double increments until your overshoot, then halving increments from the last valid wall position).
<LI>It is usually possible to increase performance at the expense of image quality and accuracy. Techniques include reducing pixel depth or display resolution, field interlacing, aliasing. The key, however, is to degrade the image in a way that is likely to be undetectable or unnoticeable to the user. For example a moving player often pays less attention to image quality than a resting or static player.
<LI>Use  information gathered during the rendering of one frame to approximate the geometry of the next frame, speeding up its rendering.
<LI>If the geometry and content is not too complicated, binary space partition trees map the view according to what the player can see, and can be faster than ray casting.
START
http://java.sun.com/docs/books/tutorial/extra/fullscreen/
Tutorial on the full screen capabilities in the 1.4 release (5 pages plus example pages under the top page)
(Page last updated June 2001, Added 2001-06-18, Author Michael Martak).
16
<LI>The full-screen exclusive mode provides maximum image display and drawing performance by allowing direct drawing to the screen.
<LI>Use java.awt.GraphicsDevice.isFullScreenSupported() to determine if full-screen exclusive mode is available. If it is not available, full-screen drawing can still be used, but better performance will be obtained by using a fixed size window in normal screen mode. Full-screen exclusive applications should not be resizable.
<LI>Turn off decoration using the setUndecorated() method.
<LI>Change the screen display mode (size, depth and refresh rate), to the best match for your image bit depth and display size so that scaling and other image alterations can be avoided or minimized.
<LI>Don't define the screen painting code in the paint() method called by the AWT thread. Define your own rendering loop for screen drawing, to be executed in any thread other than the AWT thread.
<LI>Use the setIgnoreRepaint() method on your application window and components to turn off all paint events dispatched from the operating system completely, since these may be called during inappropriate times, or worse, end up calling paint, which can lead to race conditions between the AWT event thread and your rendering loop.
<LI>Do not rely on the update or repaint methods for delivering paint events.
<LI>Do not use heavyweight components, since these will still incur the overhead of involving the AWT and the platform's windowing system.
<LI>Use double buffering (drawing to an off-screen buffer, then copying the finished drawing to the screen).
<LI>Use page-flipping (changing the video pointer so that an off-screen buffer becomes the on-screen buffer, with no image copying required).
<LI>Use a flip chain (a sequence of off-screen buffers which the video pointer successively points to one after the other).
<LI>java.awt.image.BufferStrategy provides getDrawGraphics() (to get an off-screen buffer) and show() (to display the buffer on screen).
<LI>Use java.awt.BufferCapabilities to customize the BufferStrategy for optimizing the performance of your application.
<LI>If you use a buffer strategy for double-buffering in a Swing application, you probably want to turn off double-buffering for your Swing components, 
<LI>Multi-buffering is only useful when the drawing time exceeds the time spent to do a show.
<LI>Don't make any assumptions about performance: profile your application and identify the bottlenecks first.
START
http://www.nandighosha.org/forum/topic.asp?TOPIC_ID=185&FORUM_ID=10&CAT_ID=2&Topic_Title=Java+performance+tuning+tips&Forum_Title=Java+%2D+Tips+Of+The+Day
Various performance tips
(Page last updated May 2001, Added 2001-06-18, Author Asha Balasubramanyan).
15
<LI>Use buffered I/O. Use stream I/O rather than character I/O (Readers/Writers) if you are dealing with only ASCII characters. Avoid premature flushing of buffers. 
<LI>Recycle objects. try to minimize the number of objects you create in your java programs.
<LI>Factor out constant computations from loops. Push one-time computations into methods called once only.
<LI>Use StringBuffer when dealing with mutable strings. Initialize the StringBuffer with the proper size. 
<LI>Comparison of two string objects is faster if they differ in length. 
<LI>Avoid converting Strings to bytes and back. 
<LI>StringTokenizer is slow. Write your own tokenizer.
<LI>Use charAt() instead of StartsWith() in case you are looking for a single character within a String.
<LI>Avoid premature object creation. Creation should be as close to the actual place of use as possible. 
<LI>Avoid initializing twice. 
<LI>Zeroing buffer contents is not usually required. 
<LI>Be careful about the order of evaluation of expressions with OR and AND conditions.
<LI>Use ArrayList for non-synchronized Vectors.
<LI>Minimize JNI calls in your code. 
<LI>Minimize calls to Date and related classes. 
START
http://www.javacoffeebreak.com/articles/network_timeouts/index.html
Timing out sockets
(Page last updated 2000, Added 2001-06-18, Author David Reilly).
2
<LI>Use a timer thread to monitor socket activity and timeout if blocked.
<LI>Use the socket option SO_TIMEOUT, set by using the setSoTimeout() method, to automatically timeout blocked sockets.
START
http://www.ibm.com/developerworks/java/library/j-load
Load testing of web applications
(Page last updated June 2001, Added 2001-06-18, Author Frank Cohen).
4
<LI>Current Web-application architectures consists many small servers that are accessed through a load balancer, providing a front-end to a powerful database server. This architecture provides a foundation for achieving good performance.
<LI>Load testing of web applications should include: State machine testing (entries in a shopping basket, should still be there when checked out); Really long session testing (session started then continued several hours later); Hordes of savage users testing (users do lots nonsensical activity); Privileged testing (only some users should be able to access some functionality); Speed testing (do tasks complete within the required times?). Each type of test should be run with several differetn user loads.
<LI>Test suites should be automated and easily changed.
<LI>[Article discusses <em>Load</em>, an open-source set of tools with XML scripting language]
START
http://www.javaworld.com/javaworld/javaone01/j1-01-patterns.html
J2EE design patterns to improve performance
(Page last updated June 2001, Added 2001-06-18, Author Daniel H. Steinberg).
2
<LI>Combine multiple remote calls for state informationinto one call using a value object to wrap the data (the Value Object pattern, superceded by local interfaces in EJB 2.0).
<LI>Where long lists of data are returned by queries, use the Page-by-Page Iterator pattern: a server-side object that holds data on the server and supplies batches of results to the client.
START
http://www.sys-con.com/java/article.cfm?id=713
Moving from JSP to EJB
(Page last updated June 2001, Added 2001-06-18, Author Patrick Sean Neville).
7
<LI>Entity EJBs should contain aggregate get/set methods that return chunks of data rather than fine-grained get/set methods for individual attributes, to reduce unnecessary database, transactional, and network communication overheads.
<LI>Avoid stateful session beans as they are resource-heavy, since one instance is maintained for each client.
<LI>Under heavy loads, entity beans should do more than merely represent a table in a database. If you are merely retrieving and updating data values, consider using JDBC within session beans instead.
<LI>If you have one large database host but only a small Web and middleware host, consider moving much of your logic into stored procedures and calling them via JDBC in session beans. 
<LI>If your database host is weak or unknown, or you require greater portability, keep the data calculations in entity beans.
<LI>Consider using a single stateless session bean to provide access to other EJBs (this is a façade pattern). This optimizes multiple EJB references and calls by keeping them in-process.
<LI>Container Managed Persistence (CMP) typically provides better performance (due to data caching) than Bean Managed Persistence (BMP).
START
http://www.devx.com/judgingjava/articles/maso/default.asp
Judging various aspects of Java, including performance
(Page last updated May 2001, Added 2001-06-18, Author Brian Maso).
3
<LI>J2EE defines component models with high scalability potential. Maximizing scalability requires sticking to stateless session beans and handling all database interactions programmatically (through pooled JDBC connections).
<LI>EJBs are slower and more complex than proprietary server implementations when high scalability is not needed.
<LI>Java (to 1.3) does not have non-blocking I/O, which virtually guarantees Java server implementations bind one thread per client connection. This limits communication throughput. Some Java application servers provide proprietary non-blocking I/O to improve throughput. From the 1.4 SDK, Java includes non-blocking I/O.
START
http://www.java-pro.com/upload/free/features/Javapro/2001/07jul01/ah0107/ah0107-1.asp
Experiences building a servlet
(Page last updated June 2001, Added 2001-06-18, Author Asif Habibullah, Jimmy Xu).
5
<LI>Keep the size of the client tier small so that downloads are fast.
<LI>Use the servlet init() and destroy() methods to start and stop limited and expensive resources, such as database connections.
<LI>Make the servlets thread-safe and use connection pooling.
<LI>Use PreparedStatements rather than plain Statement objects.
<LI>Use database stored procedures.
START
http://developer.java.sun.com/developer/onlineTraining/webcasts/chicago/pdf/j2se.pdf
Sun presentation on J2SE performance strategies (originally accessed from <A HREF="http://developer.java.sun.com/developer/onlineTraining/webcasts/chicago/rhutcherson.html">Reginald Hutcherson's page</A>)
(Page last updated May 2001, Added 2001-06-18, Author Reginald Hutcherson).
19
<LI>The Sun 1.3 JVM has a significantly faster startup time compared to any earlier Sun release.
<LI>Improve bytecode (method) execution by: using JITs; reducing (byte-)code size; profiling code to eliminate bottlenecks.
<LI>Reduce garbage collection overheads by: reducing the number of objects generated; reusing objects; caching objects.
<LI>Reduce multithreading overheads by targetting the granularity of locks, and managing synchronization correctly.
<LI>Other operations which improve performance include: using JAR files; using arrays rather than collections; using primitive types rather than objects.
<LI>If the CPU is the bottleneck, target: code; method profiler identified bottlenecks; algorithms; and object creation.
<LI>If system memory is the bottleneck, try to avoid paging by targeting: large objects; arrays; the application design.
<LI>If disk I/O is the bottleneck, identify the problem and eliminate it.
<LI>Ensure that you have becnhmarks and targets, and run reproducible benchmark tests.
<LI>Target the easiest of the top 5 methods, or the top method, identified by method profiling.
<LI>Repeat profile, fix, benchmark iterative process.
<LI>Avoid runtime String concatenation. Use StringBuffer instead.
<LI>Local variables (method arguments and tempoararies) remain on the stack and are much faster than heap variables (static, instance & new objects).
<LI>Use strength reduction: "x = x + 5" -> "x += 5"; "y = x/2" -> "y = x >> 1"; "z = x * 4" -> "z = x << 2".
<LI>Reuse threads by pooling threads.
<LI>Use Buffered I/O classes.
<LI>Method synchronization is slightly faster than block synchronization (and produces smaller bytecode).
<LI>Optimize after profiling the functional application, not before.
<LI>Obfuscators can make class files smaller.
START
http://www-106.ibm.com/developerworks/java/library/j-diag8.html
Optimizing recursive methods
(Page last updated June 2001, Added 2001-06-18, Author Eric E. Allen).
3
<LI>Try to convert recursive methods into tail-recursive methods.
<LI>You can test if a particular JIT is able to convert tail-recursive into loops with a dummy tail-recursive method which never terminates. If the JVM crashes because of stack overflow, no conversion is done (if the conversion is managed, the JVM loops and never terminates).
<LI>The HotSpot JVM with the 1.3 release does not convert tail-recursive methods into loops. The IBM JVM with the 1.3 release does.
START
http://softwaredev.earthweb.com/java/article/0,,12082_778571,00.html
Java collections
(Page last updated June 2001, Added 2001-06-18, Author Richard G. Baldwin).
2
<LI>Choose the right structure for the right job.
<LI>ArrayList may be faster than TreeSet for some operations, but ArrayList.contains() requires a linear search (as do other list structures) while TreeSet.contains() is a simple hashed lookup, so the latter is much faster.
START
http://www.sys-con.com/java/article.cfm?id=723
Computational planning and scheduling problem solving (not performance tuning)
(Page last updated June 2001, Added 2001-06-18, Author Irvin Lustig).
1
<LI>[Article introduces the solving of planning and scheduling problems in Java]
START
http://www.onjava.com/pub/a/onjava/2001/07/09/optimization.html
Using the WeakHashMap class
(Page last updated June 2001, Added 2001-07-20, Author Jack Shirazi).
10
<! CTGRY ><LI>WeakHashMap can be used to reduce memory leaks. Keys that are no longer strongly referenced from the application will automatically make the corresponding value reclaimable.
<! CTGRY ><LI>To use WeakHashMap as a cache, the keys that evaluate as equal must be recreatable.
<! CTGRY ><LI>Using WeakHashMap as a cache gives you less control over when cache elements are removed compared with other cache types.
<! CTGRY ><LI>Clearing elements of a WeakHashMap is a two stage process: first the key is reclaimed, then the corresponding value is released from the WeakHashMap.
<! CTGRY ><LI>String literals and other objects like Class which are held directly by the JVM are not useful as keys to a WeakHashMap, as they are not necessary reclaimable when the application no longer references them.
<! CTGRY ><LI>The WeakHashMap values are not released until the WeakHashMap is altered in some way. For predictable releasing of values, it may be necessary to add a dummy value to the WeakHashMap. If you do not call any mutator methods after populating the WeakHashMap, the values and internal WeakReference objects will never be dereferenced.
<! CTGRY ><LI>WeakHashMap wraps an internal HashMap adding an extra level of indirection which can be a significant performance overhead.
<! CTGRY ><LI>Every call to get() creates a new WeakReference object.
<! CTGRY ><LI>WeakHashMap.size() iterates through the keys, making it an operation that takes time proportional to the size of the WeakHashMap.
<! CTGRY ><LI>WeakHashMap.isEmpty() iterates through the collection looking for a non-null key, so a WeakHashMap which is empty requires more time for isEmpty() to return than a similar WeakHashMap which is not empty.
START
http://www-106.ibm.com/developerworks/java/library/j-threads1.html
When synchronization is required
(Page last updated July 2001, Added 2001-07-20, Author Brian Goetz).
7
<! CTGRY ><LI>synchronization means mutual exclusion (if the same monitor is used), atomicity of the synchronized block (again with respect to other threads using the same monitor) and synchronization of thread memory to main memory.
<! CTGRY ><LI>Because synchronization synchronizes thread memory with main memory, there is a cost to synchronization beyond simply acquiring a lock.
<! CTGRY ><LI>Too little synchronization can lead to corrupt data; too much can lead to reduced performance and deadlock.
<! CTGRY ><LI>The costs of synchronization vary with JVMs, with more recent JVMs being more efficient.
<! CTGRY ><LI>The costs of synchronization differs depending on whether or not threads are actually contending for locks (more expensive, slower), or for uncontended synchronization where the thread is basically acting in single-threaded mode (cheaper, faster).
<! CTGRY ><LI>You need to synchronize or make <CODE>volatile</CODE> variables holding data that will be shared between threads.
<! CTGRY ><LI>Composite operations may need synchronizing to make them atomic even if each individual operation is already synchronized.
START
ftp://ftp.java.sun.com/docs/j2se/1.4/VolatileImage.pdf
Using VolatileImage
(Page last updated May 2001, Added 2001-07-20, Author Someone@sun).
11
<! CTGRY ><LI>Graphics performance in 1.2 is worse than 1.1. 1.3 is better, and 1.4 should be the fastest yet.
<! CTGRY ><LI>From 1.2 direct access to image pixels was available, but was too slow to be usable because it involved copying many bits around in memory.
<! CTGRY ><LI>Use BufferedImage to move offscreen images to system memory rather than copying pixels.
<! CTGRY ><LI>For even faster image mapping, VolatileImage allows a hardware-accelerated offscreen image to be drawn directly on the video card.
<! CTGRY ><LI>VolatileImage is volatile because the image can be lost at any time, from various causes: running another application in fullscreen mode; starting a screen saver; changing screen resolution; interrupting a task.
<! CTGRY ><LI>Only constantly re-rendered images need to be explicitly created as VolatileImage objects to be hardware accelerated. Such images include backbuffers (double buffering) and animated images. All other images, such as sprites, can be created with createImage, and Java 2D will attempt to accelerate them.
<! CTGRY ><LI>If an image, such as a sprite, is drawn once and copied from many times, Java 2D makes a copy of it in accelerated memory and future copies from the image can perform better.
<! CTGRY ><LI>To render sprites to the screen, you should use double-buffering by: creating a backbuffer with createVolatileImage, copying the sprite to the backbuffer, and copying the backbuffer to the screen. If content loss occurs, Java 2D re-copies the sprite from software memory to accelerated memory.
<! CTGRY ><LI>Only some graphics operations (e.g. curved shapes) are accelerated on some platforms. Use profiling to determine what works best for your situation.
<! CTGRY ><LI>From 1.4 Swing uses VolatileImage for its double buffering.
<! CTGRY ><LI>VolatileImage.getCapabilities() provides an ImageCapabilities object which gives details of the runtime VolatileImage. The ImageCapabilities allows the application to decide to use less images, images of lower resolution, different rendering algorithms, or various other means to attempt to get better performance from the current situation and platform.
START
http://www.javaworld.com/javaworld/jw-06-2001/jw-0622-filters.html
Servlet Filters
(Page last updated June 2001, Added 2001-07-20, Author Jason Hunter).
3
<! CTGRY ><LI>Servlet Filters provide a standardized technique for wrapping servlet calls.
<! CTGRY ><LI>You can use a Servlet Filter to log servlet execution times [example provided].
<! CTGRY ><LI>You can use a Servlet Filter to compress the webserver output stream [example provided].
START
http://www.numega.com/library/dmpapers/javamem.shtml
Object creation tuning
(Page last updated 2000, Added 2001-07-20, Author Daniel F. Savarese).
11
<! CTGRY ><LI>Creating and dereferencing too many objects can adversely impact performance.
<! CTGRY ><LI>Avoid holding on to objects for too long by explicitly dereferencing them (setting variables to null) and by using weak references.
<! CTGRY ><LI>Use a profiler to determine which objects may be created too often, or may not be being dereferenced.
<! CTGRY ><LI>When looking for memory problems, look at methods that are called the most times or use the most memory. Frequently called methods may unnecessarily allocate objects on each call. Methods that use a lot of memory may not need to use as much memory or they may be a source of memory leaks.
<! CTGRY ><LI>Try to use mutable objects like StringBuffers or a char array instead of immutable objects like String.
<! CTGRY ><LI>Don't restrict object state initialization to the arguments passed to a constructor.
<! CTGRY ><LI>Provide a zero-argument constructor that creates reasonable default values and include setter methods or an init method to allow objects of that class to be reused.
<! CTGRY ><LI>If you have to wrap primitive types, such as an int, define your own wrapper class which can be reused instead of using java.lang.Integer.
<! CTGRY ><LI>If you need to create many instances of a wrapper class like Integer, consider writing your algorithm to accept primitive types.
<! CTGRY ><LI>Use a factory class instead of directly calling the "new" operator, to allow easier reuse of objects.
<! CTGRY ><LI>Object pooling and database connection pooling are two techniques for reducing object creation overheads. Object pools can be sources of memory leaks and can themselves be inefficient.
START
http://www.javaworld.com/javaworld/jw-07-2001/jw-0713-optimism.html
The Optimistic Locking pattern
(Page last updated July 2001, Added 2001-07-20, Author Yasmin Akbar-Husain and Eoin Lane).
3
<! CTGRY ><LI>Pessimistic locking, where database data is locked when read, can lead to high lock contention.
<! CTGRY ><LI>Optimistic locking only checks data integrity at update time, so has no lock contention [but can have high rollback costs]. This Optimistic Locking pattern is usually more scalable than pessimistic locking.
<! CTGRY ><LI>Detection of write-write conflicts with optimistic transactions can be done using timestamps or version counts or state comparisons.
START
http://developer.java.sun.com/developer/technicalArticles/JavaLP/Interposing/
Using java.lang.reflect.Proxy
(Page last updated July 2001, Added 2001-07-20, Author Tom Harpin).
2
<! CTGRY ><LI>The java.lang.reflect.Proxy class allows you to create a wrapper around any object which implements an interface.
<! CTGRY ><LI>Interposing proxy objects is a useful approach to trace or profile method calls.
START
http://www7b.boulder.ibm.com/wsdd/library/techarticles/0106_brown/sessionfacades.html
Rules and Patterns for Session Facades
(Page last updated June 2001, Added 2001-07-20, Author Kyle Brown).
1
<! CTGRY ><LI>Use the Facade pattern, and specifically Value objects, to transfer all the subset of data needed from en entity bean in one transfer.
START
http://www.sys-con.com/xml/article2a.cfm?id=229
Scaling web services
(Page last updated June 2001, Added 2001-07-20, Author Simeon Simeonov).
5
<! CTGRY ><LI>Use bigger, better, faster hardware, but there is a limit to the scalability of a single server: most application performance does not scale linearly with increases in the hardware power.
<! CTGRY ><LI>Use more than one server in a cluster that services requests as if it were a single server using: OS-level clustering (OS level built in failover mechanisms); Software load balancing (using a load-balancing front-end dispatcher); Hardware load balancing (e.g. DNS round-robin to different servers).
<! CTGRY ><LI>A basic load-balancing scheme is achievable by sending documents with varying binding addresses (different URL hosts)
<! CTGRY ><LI>Use faster communication protocols (e.g. plain sockets)
<! CTGRY ><LI>Support asynchronous request processing & message based interactions.
START
http://developer.java.sun.com/developer/community/chat/JavaLive/2001/jl0619.html
Sun community discussion on "Optimizing Entity Beans" with Akara Sucharitakul
(Page last updated June 2001, Added 2001-07-20, Author Edward Ort).
2
<! CTGRY ><LI>Prepared SQL statements get compiled in the database only once, future invocations do not recompile them. The result of this is a decrease in the database load, and an increase in performance of up to 5x.
<! CTGRY ><LI>Container Managed Persistence (CMP) can provide 2-3x better performance than Bean Managed Persistence (BMP).
START
http://www.sys-con.com/java/article.cfm?id=1081
Optimizing dynamic web pages
(Page last updated July 2001, Added 2001-07-20, Author Helen Thomas).
6
<! CTGRY ><LI>Dynamic generation of web pages is more resource intensive than delivering static web pages, and can cause serious performance problems.
<! CTGRY ><LI>Dynamic web page generation incurs overheads from: accessing persistent and/or remote resources/storage; data formatting; resource contention; JVM garbage collection; and script execution overheads.
<! CTGRY ><LI>Dynamic content caching tries to mitigate Dynamic web page generation overheads by reusing content that has already been generated to service a request.
<! CTGRY ><LI>JSP cache tagging solutions allow page and fragment level JSP output to be automatically cached.
<! CTGRY ><LI>On highly personalized sites page-level caching results in low cache hit rates since each page instance is unique to a user. 
<! CTGRY ><LI>Component-level caching applies more extensively when components are reused in many pages, but requires manual identification of bottleneck components.
START
http://www.sys-con.com/java/article2a.cfm?id=732
J2ME apps, with a discussion of the needs to balance performance
(Page last updated June 2001, Added 2001-07-20, Author Glenn Coates).
7
<! CTGRY ><LI>J2ME devices have limited processing power, so performance is important and must be considered for the target device.
<! CTGRY ><LI>JIT compiled or natively compiled code is preferred, but may be unobtainable because of memory resource or deployment considerations.
<! CTGRY ><LI>JVM Interpreters have a significantly lower memory overhead compared to JIT/HotSpot JVMs, but are much slower.
<! CTGRY ><LI>Selectively compiled code might provide a good compromise of speed and memory if deployment considerations allow.
<! CTGRY ><LI>The application does not need to be lightning fast in order to have a responsive user interface. The perception of speed is important: for example, the user interface should give immediate feedback.
<! CTGRY ><LI>JVM slection for the J2ME device is pivotal to achieving the required performance.
<! CTGRY ><LI>Compared to desktop environments, embedded systems typically have: lower memory availability; less processing power; user-interface restrictions; reduced communication bandwidth or unreliable connections; battery power; higher reliability requirements; lack of a file system.
START
http://www.sys-con.com/java/article.cfm?id=712
J2EE challenges
(Page last updated June 2001, Added 2001-07-20, Author Chris Kampmeier).
17
<! CTGRY ><LI>Thoroughly test any framework in a production-like environment to ensure that stability and performance requirements are met.
<! CTGRY ><LI>Each component should be thoroughly reviewed and tested for its performance and security characteristics.
<! CTGRY ><LI>Using the underlying EJB container to manage complex aspects such as transactions, security, and remote communication comes with the price of additional processing overhead.
<! CTGRY ><LI>To ensure good performance use experienced J2EE builders and use proven design patterns.
<! CTGRY ><LI>Consider the impact of session size on performance.
<! CTGRY ><LI>Avoid the following common mistakes: Failure to close JDBC result sets, statements, and connections; Failure to remove unused stateful session beans; Failure to invalidate HttpSession.
<! CTGRY ><LI>Performance test various options, for example, test both Type 2 and Type 4 JDBC drivers; Use a load-generation tool to simulate moderate loads; monitor the server to identify resource utlization.
<! CTGRY ><LI>Perform code analysis and profiling.
<! CTGRY ><LI>Performance requirements include: the required response times for end users; the perceived steady state and peak user loads; the average and peak amount of data transferred per Web request; the expected growth in user load over the next 12 months.
<! CTGRY ><LI>Note that peak user loads are the number of concurrent sessions being managed by the application server, not the number of possible users using the system.
<! CTGRY ><LI>Larger loads require greater amounts of hardware to satisfy that load.
<! CTGRY ><LI>Applications that perform very little work can typically handle many users for a given amount of hardware, but can scale poorly as they spend a large percentage of time waiting for shared resources.
<! CTGRY ><LI>Applications that perform a great number of computations tend to require much more hardware per user, but can scale much better than those performing a small number of computations.
<! CTGRY ><LI>Processor integer performance is usually the most important hardware factor, though a server can scale poorly if shared resources cause significant contention.
<! CTGRY ><LI>Cache design and memory bandwidth play a big role in determining how much extra performance is achieved, as processors are added to a server.
<! CTGRY ><LI>Additional capacity should be designed into the system.
<! CTGRY ><LI>Extrapolate from known performance test results to predict the performance of the system when varying amount of resources are available.
START
http://www.microjava.com/articles/techtalk/recycle
Reusing objects in embedded Java
(Page last updated July 2001, Added 2001-07-20, Author Angus Muir and Roman Bialach).
4
<! CTGRY ><LI>A lot of object creation and destruction can lead to a fragmented heap, which reduces the ability to create further objects.
<! CTGRY ><LI>Define the bulk of memory you need (buffers, etc.) up-front at initialization, and use object pooling to avoid further creation or destruction of objects.
<! CTGRY ><LI>Throwing/catching exceptions are tremendously expensive.
<! CTGRY ><LI>Pooling is not always faster than object creation.
START
http://www.microjava.com/chapter2
Chapter 2, "Java: Fat and Slow?", of "Java 2 Micro Edition: Professional Developer's Guide" referenced from <A HREF="http://www.microjava.com/articles/techtalk/giguere">http://www.microjava.com/articles/techtalk/giguere</A>
(Page last updated May 2001, Added 2001-07-20, Author Eric Giguere).
8
<! CTGRY ><LI>Reduce compiled code size by using implicit instruction bytcodes wherever possible. For example, limiting a method to four or fewer local variables (three on non-static methods as "this" takes the first slot), allows the compiler to use implicit forms of instructions (such as aload, iload, fload, astore, istore, fstore, and so on). 
<! CTGRY ><LI>Similarly numbers -1, 0, 1, 2, 3, 4 ,5 have special bytecodes
<! CTGRY ><LI>Java class files are standalone - no data  is shared between class files. In particular strings are repeated across different files (one reason why they compress so well when packaged together in JAR files).
<! CTGRY ><LI>An empty class compiles to about 200 bytes, of which only 5 bytes are bytecode.
<! CTGRY ><LI>There are no instructions for initializing complete arrays in the Java VM. Instead, compilers must generate a series of bytecodes that initialize the array element by element. This can make array initialization slow, and adds bytecode to the class.
<! CTGRY ><LI>You can reduce bytecode bloat from array initialization by encoded values in strings and using those strings initialize the arrays.
<! CTGRY ><LI>Explicitly set references to null when they are no longer needed to ensure that the objects can be garbage collected.
<! CTGRY ><LI>Allocate objects less often and allocate smaller objects to reduce garbage collection frequency.
START
http://www.bastie.de/resource/res/mjp.pdf
Performance tuning report in German, recently updated. Thanks to Peter Kofler for extracting the tips.
(Page last updated June 2001, Added 2001-07-20, Author Sebastian Ritter).
89
<! CTGRY ><LI>Performance optimizations vary in effect on different platforms. Always test for your platforms.
<! CTGRY ><LI>Reasons not to optimize: can lead to unreadable source code; can cause new errors; optimizations are often compiler/JVM/platform dependent; can lose object orientation.
<! CTGRY ><LI>Reasons to optimize: application uses too much memory/processor/I/O; application is unnaceptably slow.
<! CTGRY ><LI>Don't optimize before you have at least a fyunctioning prototype and some identified bottlenecks.
<! CTGRY ><LI>Try to optimize the design first before targeting the implementation.
<! CTGRY ><LI>Profile applications. Use the 80/20 rull which suggests that 80% of the work is done in 20% of the code.
<! CTGRY ><LI>Target loops in particular.
<! CTGRY ><LI>Monitor running applications to maintain performance.
<! CTGRY ><LI>Plan and budget for some resources to optimize the application. Try to have or develop a couple of performance experts.
<! CTGRY ><LI>Specify performance in the project requirements, and specify seperate performance requirements for the various layers of the application.
<! CTGRY ><LI>Consider the effects of performance at the analysis stage, and include testing of 3rd party tools.
<! CTGRY ><LI>Use a benchmark harness to make repeatable performance tests, varying the number of users, data, etc. Use profilers and logging to measure performance and identify performance problems.
<! CTGRY ><LI>Optimize the runtime system if the optimization does not require alterations to the application design or implementation.
<! CTGRY ><LI>Test various JVMs and choose the optimal JVM.
<! CTGRY ><LI>JIT compilers are faster but require more memory than interpreter JVMs. HotSpot can provide better performance and a faster startup and maintain a relatively low memory requirement.
<! CTGRY ><LI>Design in asynchronous operations so tasks are not waiting for others to finish when they don't need to.
<! CTGRY ><LI>use the right VM
<! CTGRY ><LI>use the right threading model (native vs. green)
<! CTGRY ><LI>use native compilers
<! CTGRY ><LI>give more ram to the VM
<! CTGRY ><LI>give all ram to short-lived applications to completely avoid GC
<! CTGRY ><LI>use alternate/optimizing compilers
<! CTGRY ><LI>use the right database driver
<! CTGRY ><LI>use direct JDBC drivers
<! CTGRY ><LI>expand all JDK classes into the filesystem to increase access to classes
<! CTGRY ><LI>use slot-local variables (1st 128 bit = 4 slots) (applies for interpreters only)
<! CTGRY ><LI>use int
<! CTGRY ><LI>use Arraylist instead of Vector
<! CTGRY ><LI>use own Hashtable implementations for atoms (i.e. int)
<! CTGRY ><LI>use caches
<! CTGRY ><LI>use object pools
<! CTGRY ><LI>avoid remote method calls
<! CTGRY ><LI>use callbacks to avoid blocking remote method calls
<! CTGRY ><LI>use batching for remote method calls
<! CTGRY ><LI>use the flyweight pattern to reduce object creation
<! CTGRY ><LI>use the right access modifier: static > private > final > protected > public
<! CTGRY ><LI>use inlining
<! CTGRY ><LI>use shallow hierarchies (to avoid long instantiation chains)
<! CTGRY ><LI>use empty default constructors
<! CTGRY ><LI>use direct variable access (not recommended, breaks OO)
<! CTGRY ><LI>mix model with view (not recommended, breaks OO)
<! CTGRY ><LI>use better algorithms
<! CTGRY ><LI>remove redundant code
<! CTGRY ><LI>optimize loops
<! CTGRY ><LI>unroll loops
<! CTGRY ><LI>use int as loop counter
<! CTGRY ><LI>count/test loops towards 0
<! CTGRY ><LI>use Exception terminated loops for long loops
<! CTGRY ><LI>use constants for expressions with known results, e.g. replace <CODE>x = 3; ... (x does not change) ...; x += 3;</CODE> with <CODE>x = 3; ... (x does not change) ...; x = 6;</CODE>
<! CTGRY ><LI>move code outside loops
<! CTGRY ><LI>how to optimize: 1st check for better algorithms, 2nd optimize loops
<! CTGRY ><LI>use shift for *2 and /2
<! CTGRY ><LI>do not initialize with default values (0, null)
<! CTGRY ><LI>use char arrays for mutable Strings
<! CTGRY ><LI>use arrays instead of collections
<! CTGRY ><LI>use the "private final" modifier
<! CTGRY ><LI>use System.arraycopy() to copy arrays
<! CTGRY ><LI>use Hashtable keys with fast hashcode()
<! CTGRY ><LI>do not use Strings as keys for Hashtables
<! CTGRY ><LI>use new Hashtable() instaed of Hashtable.clear() for very large Hashtables
<! CTGRY ><LI>inspect JDK source
<! CTGRY ><LI>use methods in order: static > final > instance > interface > synchronized
<! CTGRY ><LI>use own specialized methods instead of JDK's generalized ones
<! CTGRY ><LI>avoid synchronization
<! CTGRY ><LI>avoid new objects
<! CTGRY ><LI>reuse objects
<! CTGRY ><LI>use the original instead of overloaded constructors (give default parameters by your own)
<! CTGRY ><LI>avoid inner classes
<! CTGRY ><LI>use + for concenating 2 Strings, use Stringbuffer for concenating more Strings
<! CTGRY ><LI>use clone to create new objects (instead of new)
<! CTGRY ><LI>use instance.hashcode() to test for equality of intances
<! CTGRY ><LI>use native JDK implemented methods (as System.arraycopy())
<! CTGRY ><LI>avoid Exceptions (use Exceptions only for cases with probability < 50%, else use error flags)
<! CTGRY ><LI>combine multiple small try-catchs to one larger block
<! CTGRY ><LI>use Streams instead of Readers, use Reader and Writer only if you need internationalization
<! CTGRY ><LI>use buffering for io
<! CTGRY ><LI>use EOFException and ArrayOutOfBoundsException for terminating io reading loops
<! CTGRY ><LI>use transient fields to speedup serialisation
<! CTGRY ><LI>use externalization instead of serialisation
<! CTGRY ><LI>use multiple threads to increase perceived performance
<! CTGRY ><LI>use awt instead of swing for speed
<! CTGRY ><LI>use swing instead of awt for less memory
<! CTGRY ><LI>use super.paint() to initialiiy draw something (i.e. background) to increase perceived performance
<! CTGRY ><LI>use your own wrapper for primitives (with setter methods)
<! CTGRY ><LI>use Graphics.drawPolygon() (native implemented) instead of several Graphics.drawlines().
<! CTGRY ><LI>use low priority threads to initialize graphic components in the background
<! CTGRY ><LI>use synchronized blocks instead of synchronized methods
<! CTGRY ><LI>cache (SQL) Statements for DB access
<! CTGRY ><LI>use PreparedStatements for DB access
START
http://developer.java.sun.com/developer/technicalArticles/ebeans/EJB20CMP/
EJB2.0 Container-Managed Persistence
(Page last updated July 2001, Added 2001-08-20, Author Beth Stearns).
1
<! CTGRY ><LI>EJB 2.0 Container-Managed Persistence provides local interfaces which can avoid the performance overheads of remote interfaces.
START
http://www.sys-con.com/java/article.cfm?id=725
Optimizing JDBC
(Page last updated August 2001, Added 2001-08-20, Author John Goodson).
7
<! CTGRY ><LI>Minimize the use of Metadata: Cache all metadata as they will not change; Avoid using null arguments in metadata methods; Use a dummy query with getMetadata() rather than getColumns().
<! CTGRY ><LI>Retrieve data as efficiently as possible: Minimize the amount of data returned by the query; Don't make average users pay the same query cost of the users with extensive query requirements; Remember that users seldom want to see too much data in one go; Use setMaxRows(), setMaxFieldSize(), and SetFetchSize(); Decrease the column size; Use the smallest packet size that will meet your needs (if the driver supports packate sizing).
<! CTGRY ><LI>Use a parametrized remote procedure call (RPC) rather than passing parameters as part of the RPC call, e.g. use <CODE>Connection.prepareCall("Call getCustName (?)").setLong (1,12345)</CODE> rather than <CODE>Connection.prepareCall("Call getCustName (12345)")</CODE>
<! CTGRY ><LI>Minimize connections; try to reuse connections.
<! CTGRY ><LI>Turn autocommit off.
<! CTGRY ><LI>Avoid using distributed transactions.
<! CTGRY ><LI>Use getBestRowIndentifier() to determine the optimal set of columns to use in the <em>Where</em> clause for updating data. (The columns returned could be pseudo-columns that can provide pointers to the exact location of the data, and are not obtained by getColumns().)
START
http://www.javaworld.com/javaworld/jw-08-2001/jw-0803-extremescale2.html
J2EE clustering
(Page last updated August 2001, Added 2001-08-20, Author Abraham Kang).
4
<! CTGRY ><LI>Consider cluster-related and load balancing programming issues from the beginning of the development process.
<! CTGRY ><LI>Load balancing has two non-application options: DNS (Domain Name Service) round robin or hardware load balancers. [Article discusses the pros and cons].
<! CTGRY ><LI>To support distributed sessions, make sure: all session referenced objects are serializable; store session state changes in a central repository.
<! CTGRY ><LI>Try to keep multiple copies of objects to a minimum.
START
http://www.java-zone.com/free/articles/Kabutz01/Kabutz01-1.asp
SoftReference-based HashMap
(Page last updated August 2001, Added 2001-08-20, Author Heinz Kabutz).
3
<! CTGRY ><LI>WeakHashMaps are not ideal if you want the values to be weakly referenced rather than the keys.
<! CTGRY ><LI>SoftReferences may be better for memory sensitive caches since they are supposed to be collected in the reverse order to which they were last referenced.
<! CTGRY ><LI>Adding the capability to strongly reference some of the values ensures those objects will be retained through a garbage collection.
START
http://softwaredev.earthweb.com/java/article/0,,12082_862481,00.html
Writing a seamless audio looper
(Page last updated August 2001, Added 2001-08-20, Author Greg Travis).
2
<! CTGRY ><LI>Switching audio streams from one piece of sound to another requires some fiddly managing of the transition delay in order to avoid a gap in the audio output.
<! CTGRY ><LI>To avoid the transition delay, you need to: flush the output buffer; find out how much data was dumped; add a fudge factor; and combine these values to determine from where to start playing the new audio stream.
START
http://www.onjava.com/pub/a/onjava/synd/2001/08/15/embedded.html
Performance tuning embedded Java
(Page last updated August 2001, Added 2001-08-20, Author Vincent Perrier).
5
<! CTGRY ><LI>All the following affect embedded Java performance: hardware processor selection; (real-time) operating system selection; supported Java APIs; application reliability and scalability; graphics support; and the ability to put the application code into ROM.
<! CTGRY ><LI>Various approaches for boosting bytecode execution speed include: a JIT compiler (usually too big for embedded systems); an ahead-of-time compiler (requires more ROM, may disallow or slowdown dynamically loaded classes); a dynamic adaptive compiler (half-way house between last two options); putting the Java application code into ROM; rewriting the JVM interpretation loop in assembly; using a Java hardware accelerator. 
<! CTGRY ><LI>Use the lightweight graphical toolkit.
<! CTGRY ><LI>To keep down the memory footprint, eliminate any classes that are not used (java -v lists all classes as they are loaded), and run in interpreted mode as much as possible.
<! CTGRY ><LI>Benchmark results are not necessarily applicable to your application [article reviews the applicability of standard and proprietary benchmarks].
START
http://www.j3d.org/tutorials/quick_fix/perf_guide_1_1.html
Java 3D performance tips
(Page last updated June 2001, Added 2001-08-20, Author Doug Twilleager).
17
<! CTGRY ><LI>Once an application calls BranchGroup.compile() or SharedGroup.compile(), only objects with their capability bits set can be modified.
<! CTGRY ><LI>Use capability bits to describe which objects change at runtime, so that J3D can optimize the app. Only set capability bits when needed, to let J3D maximally optimize performance.
<! CTGRY ><LI>Set the bounds of objects so that J3D can ignore objects outside target object spatial scopes.
<! CTGRY ><LI>Reorder leaf nodes for the most efficient rendering.
<! CTGRY ><LI>When rendering check only the changes in rendering characteristics rather than all characteristics.
<! CTGRY ><LI>Minimize the number of Shape3D nodes, but don't combine while ignoring spatial locality.
<! CTGRY ><LI>Use the stripifier, or manually stripify the application: try to convert the geometry into long strips of triangles rather than fans of triangles.
<! CTGRY ><LI>Share Appearance/Texture/Material NodeComponent objects when possible.
<! CTGRY ><LI>Set the thread priorities appropriately, or use the default priority. Minimize thread activity.
<! CTGRY ><LI>Note the performance effects of the J3D threads, specifically Behaviors, Collision and Sounds.
<! CTGRY ><LI>J3D fully supports multi-processor machines. Use native threads where possible.
<! CTGRY ><LI>Use application knowledge to turn off currently non-visible Switch nodes.
<! CTGRY ><LI>Use a Switch node to animate a sprite by putting all the animation frames under one Switch node and using a SwitchValueInterpolator. This increases memory consumption in favor of smooth animations. 
<! CTGRY ><LI>Unordered groups are faster than ordered groups.
<! CTGRY ><LI>LOD Behaviors can be to reduce geometry rendering requirements with lower levels of detail.
<! CTGRY ><LI>Use bounds based picking rather than geometry based picking.
<! CTGRY ><LI>Transform the ViewPlatform rather than every object for a scene transformation.
START
http://www.theserverside.com/resources/article.jsp?l=Prepared-Statments
Optimizing JDBC Prepared Statments. Also a followup discussion at <A HREF="http://www.theserverside.com/discussion/thread.jsp?thread_id=8013">http://www.theserverside.com/discussion/thread.jsp?thread_id=8013</A>
(Page last updated July 2001, Added 2001-08-20, Author ?).
4
<! CTGRY ><LI>Databases analyze query statements to decide how to process them most optimally, then cache the resulting query plan, keyed on the full statement. Reusing identical statements reuses the query plan.
<! CTGRY ><LI>Alering the statement causes a new query plan to be generated for each new statement. However statements with parameters can have the query plan reused, so use parameters rather than regenerating the statement with different values.
<! CTGRY ><LI>Using a new connection requires a prepared statement to be recreated. Reusing connections allows a prepared statement to be reused.
<! CTGRY ><LI>Connection pools should have associated PreparedStatement caches so that the PreparedStatements are automatically reused.
START
http://www.allaire.com/Handlers/index.cfm?ID=17266&Method=Full&Cache=Off
Connection Pooling with JRun
(Page last updated June 2001, Added 2001-08-20, Author Karl Moss).
4
<! CTGRY ><LI>Establishing an initial connection is one of the most expensive database operations. Use a pool of connections that are ready and waiting for use to minimize the connection overhead.
<! CTGRY ><LI>Connection pooling is one of the largest performance improvements available for applications which are database intensive.
<! CTGRY ><LI>Connections should timeout if not used within a certain time period, to reduce unnecessary overheads. Initial and maximum pool sizes provide further mechanisms for fine-tuning the pool.
<! CTGRY ><LI>JDBC 2.0 supports connection pooling, though a particular driver may or may not use the support. If pooling is supported by the driver, it is probably more efficient than a proprietary pooling mechanism since it can leverage database specific features.
START
http://www.javaworld.com/javaworld/jw-07-2001/jw-0720-cache.html
Caching
(Page last updated July 2001, Added 2001-08-20, Author Jonathan Lurie).
2
<! CTGRY ><LI>Nice description of caching using a filing system analogy.
<! CTGRY ><LI>Nice introductory description of implementating caching, and of managing caching overheads and element expiration.
START
http://developer.java.sun.com/developer/JDCTechTips/2001/tt0807.html
BigDecimal and Enumerations
(Page last updated August 2001, Added 2001-08-20, Author Glen McCluskey).
2
<! CTGRY ><LI>BigDecimal provides arbitrary-precision floating point number arithmetic, at the cost of performance.
<! CTGRY ><LI>Type-safe enumeration is safer than using ints for enum values, and you can still use comparison by identity for fast performance. But you lose the performance potential of using the enum values directly as array indices, switch constants and bitmasks.
START
http://developer.java.sun.com/developer/J2METechTips/2001/tt0725.html
Flicker-free graphics with the Mobile Information Device Profile
(Page last updated July 2001, Added 2001-08-20, Author Eric Giguere).
7
<! CTGRY ><LI>Use double buffering: draw into an offscreen buffer, then copy into the display buffer. Copying buffers is very fast on most devices, while directly drawing to a display sometimes causes users to see a flicker, as individual parts of the display are updated. Double buffering avoids flickering by combining multiple individual drawing operations into a single copy operation.
<! CTGRY ><LI>Use the Canvas.isDoubleBuffered() method, to determine if double buffering is already automatically used: on some implementations the Canvas object's paint method is already a Graphics object of an offscreen buffer managed by the system. (The system then takes care of copying the offscreen buffer to the display.)
<! CTGRY ><LI>Use javax.microedition.lcdui.Image class to create an offscreen memory buffer, and use Graphics to draw to the offscreen buffer and to copy the contents of the offscreen buffer onto the display. The offscreen buffer is created by calling one of the Image.createImage methods.
<! CTGRY ><LI>Double buffering does have some overhead: if only making small changes to the display, it might be slower to use double buffering. 
<! CTGRY ><LI>On some systems image copying isn't very fast and flicker can can happen even with double buffering. 
<! CTGRY ><LI>Keep the number of offscreen buffers to a minimum. There is a memory penalty to pay for double buffering: the offscreen memory buffer can consume a large amount of memory.
<! CTGRY ><LI>Free the offscreen buffer whenever the canvas is hidden (use the canvas' hideNotify() and showNotify() methods.)
START
http://www.onjava.com/pub/a/onjava/2001/09/25/optimization.html
Multiprocess JVMs
(Page last updated September 2001, Added 2001-10-22, Author Jack Shirazi).
1
<! CTGRY ><LI>Using or implementing a multiprocess framework to combine Java processes into one JVM can save on memory space overheads and reduce startup time.
START
http://www.javaworld.com/javaworld/jw-10-2001/jw-1012-deadlock.html
Avoiding synchronization deadlocks
(Page last updated October 2001, Added 2001-10-22, Author Brain Goetz).
4
<! CTGRY ><LI>Deadlocks are difficult to identify from code analysis, and can occur unexpectedly.
<! CTGRY ><LI>Always acquire locks in the same order to avoid one common cause of deadlocking. If you can guarantee that all locks will always be acquired in a consistent order, then your program will not deadlock.
<! CTGRY ><LI>Try to avoid acquiring more than one lock at a time (though this is usually impractical).
<! CTGRY ><LI>Keep synchronized blocks of code as short as possible.
START
http://www.sys-con.com/java/article.cfm?id=1165
The facade pattern for internationalization
(Page last updated October 2001, Added 2001-10-22, Author David Gallardo).
1
<! CTGRY ><LI>If multiple strings will be compared using internationalized comparison, use (and reuse) CollationKeys to manage the comparisons during sorting.
START
http://www-106.ibm.com/developerworks/ibm/library/i-tuning/?open
Tuning the IBM JVM and Linux
(Page last updated May 2001, Added 2001-10-22, Authors Duc Vianney and James Phelan).
22
<! CTGRY ><LI>[Article also has detailed coverage of tuning Linux].
<! CTGRY ><LI>Use the -Xms and -Xmx parameters to set the heap size.
<! CTGRY ><LI>Use -verbosegc to measure garbage collection statistics.
<! CTGRY ><LI>Keep heap size smaller than physical memory.
<! CTGRY ><LI>Keep heap size small enough that all other necessary processes also fit into physical memory.
<! CTGRY ><LI>The IBM JVM has extra options to control JVM< heap size expansion and shrinkage.
<! CTGRY ><LI>Use -Xrunhprof to profile the application [article gives and example of using -Xrunhprof to tune].
<! CTGRY ><LI>Use local variables where possible.
<! CTGRY ><LI>Use int instead of long.
<! CTGRY ><LI>Use arrays instead of vectors.
<! CTGRY ><LI>Use primitive types such as int and double instead of objects.
<! CTGRY ><LI>Use exceptions only when necessary.
<! CTGRY ><LI>Reuse objects as much as possible.
<! CTGRY ><LI>Avoid writing to the console.
<! CTGRY ><LI>Cache frequently used objects whenever possible.
<! CTGRY ><LI>Declare methods as final. Classes and methods that aren't going to be redefined should be declared as final.
<! CTGRY ><LI>Declare constants as static final.
<! CTGRY ><LI>Limit the use of synchronized methods.
<! CTGRY ><LI>Null old object references.
<! CTGRY ><LI>Cache with soft references.
<! CTGRY ><LI>Cache information that will be reused and is expensive to generate.
<! CTGRY ><LI>Use jar files.
START
http://developer.java.sun.com/developer/qow/archive/153/index.jsp
Minimizing space taken by HTTP downloads
(Page last updated October 2001, Added 2001-10-22, Authors Gary Adams and Eric Giguere).
3
<! CTGRY ><LI>Use HttpConnection.getLength() to determine the number of bytes needed to to hold the data from a download.
<! CTGRY ><LI>Use a ByteArrayOutputStream to accumulate results if the content length is indeterminate.
<! CTGRY ><LI>The best performance is obtained from a 1.1 compliant webserver using persistent connections.
START
http://developer.java.sun.com/developer/Books/J2EETech/ch3.pdf
Rambling discussion of building J.Crew website, in Chapter 3 of "J2EE Technology in Practice"
(Page last updated September 2001, Added 2001-10-22, Authors Dao Ren, Dr. Rick Cattell and Jim Inscore).
3
<! CTGRY ><LI>Use database connection pooling
<! CTGRY ><LI>Cache Database Requests
<! CTGRY ><LI>[Statistics useful for comparison if you are building a business enterprise site: The architecture can handle 8,000 concurrent user sessions; 85 dynamic page views a second; 250,000 unique daily visitors; 8 million hits a day; 1 to 2 second average response time].
START
http://developer.java.sun.com/developer/JDCTechTips/2001/tt0925.html
Generating integer random numbers
(Page last updated September 2001, Added 2001-10-22, Author John Zukowski).
1
<! CTGRY ><LI>[Article explains why ways of generating random integers produces skewed results. Important for correctly simulating a variety of things].
START
http://www.javaworld.com/javaworld/javaqa/2001-09/02-qa-0921-double.html
String to double
(Page last updated September 2001, Added 2001-10-22, Author Tony Sintes).
1
<! CTGRY ><LI>Use <CODE>Double.parseDouble()</CODE> instead of <CODE>Double.valueOf(aString).doublevalue()</CODE>.
START
http://www.owlmountain.com/tutorials/NonBlockingIo.htm
Tutorial on non-blocking socket I/O available from JDK 1.4
(Page last updated September 2001, Added 2001-10-22, Author Tim Burns).
1
<! CTGRY ><LI>[No tips, and a rather haphazard tutorial but beggars can't be choosers].
START
http://developer.java.sun.com/developer/technicalArticles/releases/nio/
The java.nio packages
(Page last updated October 2001, Added 2001-10-22, Author John Zukowski).
2
<! CTGRY ><LI>Direct buffers have a higher creation cost than non-direct buffers because they use native system operations rather than JVM operations.
<! CTGRY ><LI>Reduce threads by multiplexing I/O using selectors.
START
http://www.sys-con.com/java/article.cfm?id=1169
Javabean component architecture
(Page last updated October 2001, Added 2001-10-22, Authors David Hardin and Mike Frerking).
3
<! CTGRY ><LI>Reusing events reduce object creation and garbage collection overheads.
<! CTGRY ><LI>Passing primitive data types directly to event handlers is the fastest way to pass event information.
<! CTGRY ><LI>Generic events reduce the number of (inner) classes required to handle the events.
START
http://developer.java.sun.com/developer/technicalArticles/Using/
The logging APIs
(Page last updated September 2001, Added 2001-10-22, Author Tom Harpin).
2
<! CTGRY ><LI>[Article gives a high level view of the logging APIs introduced in SDK 1.4. No application is adequately deployed unless it has some performance logging in place].
<! CTGRY ><LI>Formatting of log records is separate from the generation and transfer of the records, so that the formatting overhead is incurred only on demand (and possibly asynchronously).
START
http://www.sys-con.com/java/article.cfm?id=1160
Local entity beans
(Page last updated October 2001, Added 2001-10-22, Author Alex Pestrikov).
3
<! CTGRY ><LI>Local entity beans do not need to be marshalled, and do not incur any marshalling overhead for method calls either: parameters are passed by reference.
<! CTGRY ><LI>Local entity beans are an optimization for beans which it is known will be on the same JVM with their callers.
<! CTGRY ><LI>Facade objects (wrappers) allow local entity beans to be called remotely. This pattern incurs very little overhead for remote calls, while at the same time optimizing local calls between local beans which can use local calls.
START
http://www.sys-con.com/java/article.cfm?id=1171
J2EE Performance tuning
(Page last updated October 2001, Added 2001-10-22, Author James McGovern).
21
<! CTGRY ><LI>Call HttpSession.invalidate() to clean up a session when you no longer need to use it.
<! CTGRY ><LI>For Web pages that don't require session tracking, save resources by turning off automatic session creation using: &lt;%@ page session="false"%> 
<! CTGRY ><LI>Implement the HttpSessionBindingListener for all beans that are scoped as session interface and explicitly release resources implementing the method valueUnbound().
<! CTGRY ><LI>Timeout sessions more quickly by setting the timeout or using session.setMaxInactiveInterval().
<! CTGRY ><LI>Keep-Alive may be extra overhead for dynamic sites.
<! CTGRY ><LI>Use the include directive &lt;%@ include file="copyleft.html" %> where possible, as this is a compile-time directive (include action &lt;jsp:include page="copyleft.jsp" /> is a runtime directive).
<! CTGRY ><LI>Use cache tagging where possible.
<! CTGRY ><LI>Always access entity beans from session beans.
<! CTGRY ><LI>If only using an entity bean for data access, use JDBC directly instead.
<! CTGRY ><LI>Use read-only in the deployment descriptor.
<! CTGRY ><LI>Cache access to EJB homes.
<! CTGRY ><LI>Use local entity beans when beans are co-located in the same JVM.
<! CTGRY ><LI>Proprietary stubs can be used for caching and batching data.
<! CTGRY ><LI>Use a dedicated remote object to generate unique primary keys.
<! CTGRY ><LI>Follow standard JDBC optimizations: use connection pools; prefer stored procedures or direct SQL; use type 4 drivers; remove extra columns from the result set; use prepared statements when practical; have your DBA tune the query; choose the appropriate transaction levels.
<! CTGRY ><LI>Consider storing all database character data in Unicode to eliminate conversion overheads. But beware: this step will cause your database size to grow, as Unicode requires 2 bytes per character.
<! CTGRY ><LI>Use block fetches when the query will give a large ResultSet and all rows are needed. Use the Page-by-Page Iterator pattern when only some of the rows may be needed.
<! CTGRY ><LI>Consider using an in-memory database (product) for data that doesn't need to be persisted.
<! CTGRY ><LI>Use an algorithm to prune caches to stop them growing too large.
<! CTGRY ><LI>Performance is sometimes in perception: try to provide immediate feedback.
<! CTGRY ><LI>Optimizing code is one of the last things developers should consider.
START
http://developer.java.sun.com/developer/Books/EarlyJ2SE/IO.pdf
Shortened version of chapter 2, "I/O", from "Early Adopter J2SE 1.4"
(Page last updated October 2001, Added 2001-10-22, Author James Hart).
3
<! CTGRY ><LI>Non-blocking I/O can improve performance by minimizing the amount of time spent in I/O calls, though they may add complexity to the application.
<! CTGRY ><LI>The old I/O classes can now be interrupted more reliably from 1.4. 
<! CTGRY ><LI>FileChannel.transferFrom() is an efficient way to copy data between files. 
START
http://developer.java.sun.com/developer/Books/EarlyJ2SE/Using.pdf
Shortened version of chapter 5, "Utilities: The Logging Architecture", from "Early Adopter J2SE 1.4"
(Page last updated October 2001, Added 2001-10-22, Author James Hart).
2
<! CTGRY ><LI>Logging can take place asynchronously: a call to log can return before the log has been formatted and written.
<! CTGRY ><LI>The logging framework provides methods (in Logger) for recording method activity, but this may have a large overhead to use.
START
http://www.onjava.com/pub/a/onjava/2001/09/26/load.html
Load Balancing Web Applications
(Page last updated September 2001, Added 2001-10-22, Author Vivek Veek).
4
<! CTGRY ><LI>DNS round-robin sends each subsequent DNS lookup request to the next entry for that server name. This provides a simple machine-level load-balancing mechanism, but is only appropriate for session independent or shared-session servers.
<! CTGRY ><LI>DNS round-robin has no server load measuring mechanisms, so requests can still go to overloaded servers, i.e. the load balancing can be very unbalanced.
<! CTGRY ><LI>Hardware load-balancers solve many of the problems of DNS round-robin, but introduce a single point of failure.
<! CTGRY ><LI>A web server proxy can also provide load-balancing by redirecting requests to multiple backend webservers.
START
http://win-www.uia.ac.be/~s985218/professional/thesis/archief/documenten/Marktoverzicht.doc
Overview of common application servers (announced at <A HREF="http://www.theserverside.com/home/thread.jsp?thread_id=9581">http://www.theserverside.com/home/thread.jsp?thread_id=9581</A>). I've extracted the performance related features
(Page last updated October 2001, Added 2001-10-22, Author Pieter Van Gorp ).
10
<! CTGRY ><LI>Load balancing: random; minimum load; round-robin; weighted round-robin; performance-based; load-based; dynamic algorithm based; dynamic registration.
<! CTGRY ><LI>Clustering. Additionally: distributed transaction management; in-memory replication of session state information; no single point of failure.
<! CTGRY ><LI>Connection pooling. 
<! CTGRY ><LI>Caching. JNDI caching. Distributed caching with synchronization. 
<! CTGRY ><LI>Thread pooling. 
<! CTGRY ><LI>Configurable user Quality of Service. 
<! CTGRY ><LI>Analysis tools. 
<! CTGRY ><LI>Low system/memory requirements. 
<! CTGRY ><LI>Optimized subsystems (RMI, JMS, JDBC drivers, JSP tags & cacheable page fragments). 
<! CTGRY ><LI>Optimistic transaction support. 
START
http://www.onjava.com/pub/a/onjava/2001/08/22/optimization.html
Catching OutOfMemoryErrors
(Page last updated August 2001, Added 2001-10-22, Author Jack Shirazi).
4
<! CTGRY ><LI>-Xmx and -Xms (-mx and -ms) specify the heap max and starting sizes. Runtime.totalMemory() gives the current process size, Runtime.maxMemory() (available from SDK 1.4) gives the -Xmx value.
<! CTGRY ><LI>Repeatedly allocating memory by creating objects and holding onto them will expand the process to its maximum possible size. This technique can also be used to flush memory.
<! CTGRY ><LI>If a process gets too large, the operating system will start paging the process causing a severe decrease in performance.
<! CTGRY ><LI>It is reasonable to catch the OutOfMemoryError if you can restore your application to a known state that can proceed with processing. For example, daemon service threads can often do this.
START
http://java.oreilly.com/news/javaxslt_0801.html
Tips on using XSLT
(Page last updated August 2001, Added 2001-10-22, Author Eric M. Burke).
1
<! CTGRY ><LI>XSLT transformations are CPU & memory intensive, so cache results wherever possible. Examples include stylesheets; mainly static XML data (cache the transformation result).
START
http://www.onjava.com/pub/a/onjava/2001/09/18/jboss.html
Implementing clustering on a J2EE web server (JBoss+Jetty)
(Page last updated September 2001, Added 2001-10-22, Author Bill Burke).
4
<! CTGRY ><LI>Clustering includes synchronization, load-balancing, fail-over, and distributed transactions.
<! CTGRY ><LI>[article discusses implementing clustering in an environment where clustering was not previously present].
<! CTGRY ><LI>The different EJB commit options affect database traffic and performance. Option 'A' (read-only local caching) has the smallest overhead.
<! CTGRY ><LI>Hardware load balancers are a simple and fast solution to distributing HTTP requests to clustered servers.
START
http://developer.java.sun.com/developer/J2METechTips/2001/tt0917.html
Making HTTP connections using background threads.
(Page last updated September 2001, Added 2001-10-22, Author Eric Giguere).
5
<! CTGRY ><LI>The user interface must always be responsive to the user's interaction.
<! CTGRY ><LI>The application should respond to input no later than a tenth of a second after it occurs: longer delays are noticed by the user, and make the user interface seem unresponsive. So don't do more than about a tenth of a second's worth of work in the user-service thread in response to any user interface event.
<! CTGRY ><LI>Use separate threads to perform operations that will last longer than one tenth of a second.
<! CTGRY ><LI>Provide the user with the option to cancel the operation at any time.
<! CTGRY ><LI>[Article provides an example of making an HTTP connection following these suggestions].
START
http://www.theserverside.com/resources/article.jsp?l=Is-EJB-Appropriate
Deciding whether EJB is appropriate.
(Page last updated September 2001, Added 2001-10-22, Author Ed Roman).
1
<! CTGRY ><LI>An HTTP layer is not always necessary. Connecting directly to EJBs is faster and provides automatic load balancing.
START
http://www.javaworld.com/javaworld/jw-09-2001/jw-0907-merlin.html
Using nonblocking I/O and memory-mapped buffers in SDK 1.4.
(Page last updated September 2001, Added 2001-10-22, Author Michael T. Nygard).
9
<! CTGRY ><LI>Before SDK 1.4, servers had a number of perormance problems: i/o could easily be blocked; garbage was easily generated when reading i/o; many threads are needed to scale the server.
<! CTGRY ><LI>Many threads each blocked on i/o is an inefficient architecture in comparison to one thread blocked on many i/o calls (multiplexed i/o).
<! CTGRY ><LI>Truly high-performance applications must obsess about garbage collection. The more garbage generated, the lower the application throughput.
<! CTGRY ><LI>A Buffer (java.nio.*Buffer) is a reusable portion of memory. A MappedByteBuffer can map a portion of a file directly into memory.
<! CTGRY ><LI>Direct Buffer objects can be read/written directly from Channels, but nondirect Buffer objects have a data copy performed for read/writes to i/o (and so are slower and may generate garbage). Convert nondirect Buffers to direct Buffers if they will be used more than once.
<! CTGRY ><LI>Scatter/gather operations allow i/o to operate to and from several Buffers in one operation, for increased efficiency. Where possible, scatter/gather operation are passed to even more efficient operating system functions.
<! CTGRY ><LI>Channels can be configured to operate blocking or non-blocking i/o.
<! CTGRY ><LI>Using a MappedByteBuffer is more efficient than using BufferedInputStreams. The operating system can page into memory more efficiently than BufferedInputStream can do a block read.
<! CTGRY ><LI>Use Selectors to multiplex i/o and avoid having to block multiple threads waiting on i/o.
START
http://www.javaworld.com/jw-09-2001/jw-0907-rmi.html
RMI performance tuning
(Page last updated September 2001, Added 2001-10-22, Author Ashok Mathew and Mark Roulo).
9
<! CTGRY ><LI>Use netperf to measure network bandwidth.
<! CTGRY ><LI>Consider altering the TcpWindowSize parameter.
<! CTGRY ><LI>Configure RMI garbage collection by setting the properties <code>sun.rmi.dgc.client.gcInterval</code> and <code>sun.rmi.dgc.server.gcInterval</code>. 
<! CTGRY ><LI>Send groups of objects together rather than one object at a time.
<! CTGRY ><LI>Implementing <CODE>Externalize</CODE> can speed up transfers.
<! CTGRY ><LI>Pack data to reduce the number and amount of reads and writes, and the amount of data transferred.
<! CTGRY ><LI>Have object directly serialize contained objects or tell those objects to serialize themselves using Externalize methods (i.e. chain Externalize methods for all contained objects).
<! CTGRY ><LI>Use special codes to handle special cases such as singleton or reusable objects.
<! CTGRY ><LI>Don't introduce extra complications once performance targets have been met.
START
http://developer.java.sun.com/developer/technicalArticles/Threads/swing/
Multithreaded Swing Applications
(Page last updated September 2001, Added 2001-10-22, Author Monica Pawlan).
2
<! CTGRY ><LI>Use the SwingUtilities.invokeAndWait() and SwingUtilities.invokeLater() methods  to put code on the GUI event queue.
<! CTGRY ><LI>Spawn threads for long operations so that the user does not get a blocked GUI.
START
http://www.microjava.com/articles/techtalk/display?PageNo=1
Timers and low-level GUI display effects
(Page last updated September 2001, Added 2001-10-22, Author Roman Bialach).
2
<! CTGRY ><LI>You need a scheduling mechanism to perform animation, scrolling, updating the display, etc.
<! CTGRY ><LI>The paint() method on the Canvas is called by the system only if it thinks that it needs to repaint it. So we need another timer to repaint the screen on a regular basis. Use a timer to periodically call repaint().
START
http://www.javareport.com/html/from_pages/article.asp?id=4702&mon=9&yr=2001
Architecting and Designing Scalable, Multitier Systems
(Page last updated August 2001, Added 2001-10-22, Author Michael Minh Nguyen).
3
<! CTGRY ><LI>Separate the UI controller logic from the servlet business logic, and let the controllers be mobile so they can execute on the client if possible.
<! CTGRY ><LI>Validate data as close to the data entry point as possible, preferably on the client. This reduces the network and server load. Business workflow rules should be on the server (or further back than the front-end).
<! CTGRY ><LI>You can use invisible applets in a browser to validate data on the client.
START
http://www.theserverside.com/resources/articles/JSP-Performance/ProJsp.html
Performance chapter (chapter 20) from "Professional JSP 2nd Edition"
(Page last updated August 2001, Added 2001-10-22, Author Simon Brown, Robert Burdick, Darko Cokor, Jayson Falkner, Ben Galbraith, RodJohnson, Larry Kim, Casey Kochmer, Thor Kristmundsson, Sing Li, Dan Malks, Mark Nelson, Grant Palmer, Bob Sullivan, Geoff Taylor, John Timney, Sameer Tyagi, Geert Van Damme, Steve Wilkinson).
11
<! CTGRY ><LI>The user's view of the response time for a page view in his browser depends on download speed and on the complexity of the page. e.g. the number of graphics. A poorly-designed highly graphical dynamic website could be seen as 'slow' even if the web downloads are individually quite fast.
<! CTGRY ><LI>No web application can handle an unlimited number of requests; the trick in optimization is to anticipate the likely user demand and ensure that the web site can gracefully scale up to the demand while maintaining acceptable levels of speed.
<! CTGRY ><LI>Profile the server to identify the bottlenecks. Note that profiling can be done by instrumenting the code with measurement calls if a profiler is unavailable.
<! CTGRY ><LI>One stress test methodology is: determine the maximum acceptable response time for getting a page; estimate the maximum number of simultaneous users; simulate user requests, gradually adding simulated users until the web application response delay becomes greater than the acceptable response time; optimize until you reach the desired number of users.
<! CTGRY ><LI>Pay special attention to refused connections during your stress test: these indicate the servlet is overwhelmed.
<! CTGRY ><LI>There is little performance penalty to using an MVC architecture.
<! CTGRY ><LI>Use resource pools for expensive resources (like database connections).
<! CTGRY ><LI>Static pages are much faster than dynamic pages where the web server can handle static pages separately.
<! CTGRY ><LI>Servlet filtering has a performance cost. Test to see if it is an acceptable cost.
<! CTGRY ><LI>Ensure that the webserver is configured to handle the expected number of user for example: enough ready sockets; enough disk space; enough CPU.
<! CTGRY ><LI>Use the fastest JVM you have access to.
START
http://www-106.ibm.com/developerworks/java/library/j-threads2.html
Reducing thread contention
(Page last updated September 2001, Added 2001-10-22, Author Brian Goetz).
6
<! CTGRY ><LI>Thread contention impairs scalability because it forces the scheduler to serialize operations, even if a free processor is available.
<! CTGRY ><LI>Analyze your program to determine where contention is likely to occur. 
<! CTGRY ><LI>Make synchronized blocks as short as possible.
<! CTGRY ><LI>Spread synchronizations over more than one lock.
<! CTGRY ><LI>[Article provides a thread-safe hashed Map implementation with lower global contention than Hashtable.]
<! CTGRY ><LI>If you will be acquiring and releasing the same lock many times (such as in a loop), acquire the lock before the loop: it is faster to acquire a lock that you already hold than one that nobody holds.
START
http://www.sys-con.com/java/article.cfm?id=1149
Performance tuning
(Page last updated September 2001, Added 2001-10-22, Author James McGovern).
15
<! CTGRY ><LI>Often there's a trade-off between designing for reuse and designing for performance. Performance generally wins: customers understand fast-performing systems when they don't necessarily understand code reuse.
<! CTGRY ><LI>Exceptions degrade performance and should be used for error conditions only, not control flow.
<! CTGRY ><LI>Don't initialize variables twice: Java by default initializes variables to a known value.
<! CTGRY ><LI>Use the factory pattern to enable reuse or cloning of objects.
<! CTGRY ><LI>Make classes final.
<! CTGRY ><LI>Use local variables as much as possible.
<! CTGRY ><LI>Use non-blocking I/O (available from 1.4, or use www.cs.berkeley.edu/~mdw/proj/java-nbio/download.html for earlier versions).
<! CTGRY ><LI>Create/Use method interfaces that reduce overhead.
<! CTGRY ><LI>Use bit-shifting instead of multiplication or division by powers of two.
<! CTGRY ><LI>Choose the JVM that runs your application fastest.
<! CTGRY ><LI>Use clustering application servers.
<! CTGRY ><LI>Avoid stateful sessions.
<! CTGRY ><LI>Profile and tune the application (architecture and code).
<! CTGRY ><LI>Set aside at least 20% of the total project time for performance.
<! CTGRY ><LI>Make sure your QA environment mirrors your production environment, and your QA procedure tests the application at different loads, including a low and fully scaled loads.
START
http://www.sys-con.com/java/article.cfm?id=1133
Techniques to avoid deadlocks
(Page last updated September 2001, Added 2001-10-22, Author Mark Dykstra).
5
<! CTGRY ><LI>Potential deadlocks can be caused by coding styles. 
<! CTGRY ><LI>Always acquire a set of locks in the same set order. 
<! CTGRY ><LI>Don't hold a lock and wait for an event. 
<! CTGRY ><LI>Specify which thread should have access to data at any time. 
<! CTGRY ><LI>Ensure that both access and update to the same variable is synchronized on the same monitor. 
START
http://www.ddj.com/articles/2001/0109/0109a/0109a.htm
Developing Scalable Distributed Applications
(Page last updated August 2001, Added 2001-10-22, Author Mario A. Torres).
1
<! CTGRY ><LI>Use interfaces. Alot.
START
http://www.javaworld.com/javaworld/javaqa/2001-08/01-qa-0817-static.html
Inner classes
(Page last updated August 2001, Added 2001-10-22, Author Tony Sintes).
1
<! CTGRY ><LI>Nonstatic member classes must maintain a reference to the enclosing instance, which adds overhead, so use static inner classes where no acces is need to the enclosing instance.
START
http://discuss.develop.com/archives/wa.exe?A2=ind0010A&L=DOTNET&P=R28572
Microsoft discussion about csharp garbage collection (the Java clone unsurprisingly has similar issues)
(Page last updated October 2001, Added 2001-10-22, Author Brian Harry).
1
<! CTGRY ><LI>[No performance tips here. But a fascinating discussion about all the thought that has gone in to csharp GC, only to result in a what already exists in Java].
START
http://www.sys-con.com/java/article.cfm?id=1135
J2EE design optimizations
(Page last updated September 2001, Added 2001-10-22, Author Vijay S. Ramachandran).
3
<! CTGRY ><LI>For data that changes infrequently (i.e. rarely enough that a user session will not need that data updating during the session lifetime), avoid transactional access by using a cached Data Access Object rather than the transactional EJB (this is called the Fast Lane Reader pattern).
<! CTGRY ><LI>Don't transfer long lists of data to the user, transfer a page at a time (this is called the Page-by-Page Iterator pattern).
<! CTGRY ><LI>Instead of making lots of remote requests for data attributes of an object, combine the attributes into another object and send the object to the client. Then the attributes can be queried efficiently locally (this is called the Value Object pattern). Consider caching the value objects where appropriate.
START
http://www.javaworld.com/jw-09-2001/jw-0914-access.html
Customized high-speed, fine-grained access control
(Page last updated September 2001, Added 2001-10-22, Author Wally Flint).
1
<! CTGRY ><LI>[Article discusses an Access control pattern which has no performance penalty].
START
http://www.onjava.com/pub/a/onjava/2001/10/23/optimization.html
The RandomAccess interface.
(Page last updated October 2001, Added 2001-11-27, Author Jack Shirazi).
3
<! CTGRY ><LI>A java.util.List object which implements RandomAccess should be faster when using List.get() than when using Iterator.next().
<! CTGRY ><LI>Use <CODE>instanceof RandomAccess</CODE> to test whether to use List.get() or Iterator.next() to traverse a List object.
<! CTGRY ><LI>[Article describes how to guard the test to support all versions of Java].
START
http://www.javaworld.com/javaworld/javaqa/2001-11/02-qa-1109-boolean.html
Converting booleans to strings.
(Page last updated November 2001, Added 2001-11-27, Author Tony Sintes).
1
<! CTGRY ><LI>Use String.valueOf(bool) to convert booleans to strings.
START
http://www.onjava.com/pub/a/onjava/2001/11/07/atomic.html
Atomic File Transactions.
(Page last updated November 2001, Added 2001-11-27, Author Jonathan Amsterdam).
4
<! CTGRY ><LI>If you don't require powerful search capabilities, using flat files may be faster than dealing with a database.
<! CTGRY ><LI>Basic file operations (deletion, creation, renaming) are atomic. Other operations and combinations of operations are not atomic. Atomicity can be built but comes at a performance cost. You will have to determine whether the increase in robustness is worth the slowdown in your application.
<! CTGRY ><LI>Do the I/O in a background thread to mitigate the performance impact of adding atomicity to file transactions.
<! CTGRY ><LI>[Article discusses how to use a free package which provides atomicity for file transactions, and how the atomicity is provided].
START
http://www.javaworld.com/javaworld/jw-11-2001/jw-1116-dcl.html
Double-checked locking revisited.
(Page last updated November 2001, Added 2001-11-27, Author Brian Goetz).
3
<! CTGRY ><LI>Double-checked locking is not guaranteed to produce consistent results.
<! CTGRY ><LI>Using a ThreadLocal in the double-checked locking test is guaranteed to produce consistent results, but is slower than avoiding double-checked locking altogether.
<! CTGRY ><LI>ThreadLocal is faster in each SDK release through 1.2, 1.3 and 1.4. 1.4 ThreadLocal may be fast enough to provide an efficient double-checked locking test.
START
http://www.onjava.com/pub/a/onjava/2001/10/17/rmi.html
Command objects for RMI.
(Page last updated October 2001, Added 2001-11-27, Author William Grosso).
1
<! CTGRY ><LI>Use Command objects to automatically queue or retry RMI calls.
START
http://www.onjava.com/pub/a/onjava/2001/10/31/rmi.html
Caching RMI stubs.
(Page last updated October 2001, Added 2001-11-27, Author William Grosso).
5
<! CTGRY ><LI>Remote method calls are much slower than local calls, at least 1000 times slower.
<! CTGRY ><LI>Reduce the number of remote calls made by an application to improve performance.
<! CTGRY ><LI>Cache remote objects locally where possible, rather than repeatedly fetching them.
<! CTGRY ><LI>Use Command objects to transparently add a remote stub cache to an RMI application.
<! CTGRY ><LI>Caching stubs keeps them from being garbage collected, and may prevent an RMI server from closing. Use a policy to expire stubs and delete them from the cache.
START
http://intranetjournal.com/articles/200110/gb_10_24_01a.html
Website performance.
(Page last updated October 2001, Added 2001-11-27, Author Gordon Benett).
8
<! CTGRY ><LI>Some e-commerce consultants cite an attention span on the order of eight seconds as the threshold for abandoning a slow retail site.
<! CTGRY ><LI>Where broadband connections are the norm, pages that don't appear instantly stand a good chance of never being seen: slow pages might as well be no pages.
<! CTGRY ><LI>Systems can only be designed to meet performance goals if those goals have been identified. Determine what range of response times will be acceptable.
<! CTGRY ><LI>Try to understand the performance impacts of your design decisions. However the performance of some design choices can be hard to predict and may remain unclear before testing.
<! CTGRY ><LI>Test the system under conditions that simulate real patterns of use.
<! CTGRY ><LI>Intermittent hard to repeat performance problems are not worth addressing unless they are in a business critical part of the website which provides corporate revenue.
<! CTGRY ><LI>Use a rapid, iterative development process in combination with frequent performance testing.
<! CTGRY ><LI>Try to plan up-front rather than have to rely on late-phase tuning.
START
http://www-106.ibm.com/developerworks/webservices/library/ws-testsoap/
Scaling SOAP-based web services.
(Page last updated November 2001, Added 2001-11-27, Author Frank Cohen).
7
<! CTGRY ><LI>Cache the web services description language (WSDL) in a centralized database and periodically check for newer versions.
<! CTGRY ><LI>Cache schema definitions for scalability.
<! CTGRY ><LI>Use simple SOAP data types (String, Int, Float, NegativeInteger).
<! CTGRY ><LI>Each new data type introduces a serializer to convert from the XML value into a Java value and back again, which may cause performance problems.
<! CTGRY ><LI>SOAP messages move much more data than the average HTTP GET or POST call, adversely impacting network performance.
<! CTGRY ><LI>Transactional SOAP calls need to cache the state of sessions.
<! CTGRY ><LI>[Article dicusses a free open-source utility called Load to stress test SOAP-based web services].
START
http://java.sun.com/docs/books/performance/1st_edition/html/JPPerformance.fm.html
Chapter 1, "What Is Performance?" of "Java Platform Performance".
(Page last updated 2000, Added 2001-11-27, Author Steve Wilson and Jeff Kesselman).
4
<! CTGRY ><LI>Design your software with the target configuration (e.g. RAM) in mind.
<! CTGRY ><LI>If your program consumes all of your user's memory resources, they probably won't be happy.
<! CTGRY ><LI>Measure performance under loads comparable to expected deployed loads.
<! CTGRY ><LI>Perceived performance is a highly important aspect of performance. How fast a program feels is more important than how fast it really is.
START
http://java.sun.com/docs/books/performance/1st_edition/html/JPProcess.fm.html
Chapter 2, "The Performance Process" of "Java Platform Performance".
(Page last updated 2000, Added 2001-11-27, Author Steve Wilson and Jeff Kesselman).
11
<! CTGRY ><LI>It's nearly impossible to achieve good performance through optimizations alone, without considering performance in analysis and design stages.
<! CTGRY ><LI>Creating clear system and performance requirements is the key to evaluating the success of your project.
<! CTGRY ><LI>Use cases provide excellent specifications for building benchmarks.
<! CTGRY ><LI>Specify the limitations of the application: well-defined boundaries on the application scope can provide big optimization opportunities.
<! CTGRY ><LI>Specifications should include system and performance requirements, including all supported hardware configurations (RAM/CPU/Disk/Network) and other software that normally executes concurrently.
<! CTGRY ><LI>You should specify quantifiable performance requirements, for example "a response time of two seconds or less".
<! CTGRY ><LI>Scalability is more dependent on good design decisions than optimal coding techniques.
<! CTGRY ><LI>Encapsulation leads to slowdowns from increased levels of indirection, but is essential in large, scalable, high-performance systems. For example, using a java.util.List object may be slower than using a raw array, but allows you to change very easily from ArrayList to LinkedList when that is faster.
<! CTGRY ><LI>Meeting or exceeding your performance requirements should be part of the shipping criteria for your product.
<! CTGRY ><LI>Once you've determined that a performance problem exists, you need to begin profiling. Profilers are most useful for identifying computational performance and RAM footprint issues.
<! CTGRY ><LI>Performance tuning is an iterative process. Data gathered during profiling needs to be fed back into the development process.
START
http://java.sun.com/docs/books/performance/1st_edition/html/JPMeasurement.fm.html
Chapter 3, "Measurement Is Everything" of "Java Platform Performance".
(Page last updated 2000, Added 2001-11-27, Author Steve Wilson and Jeff Kesselman).
18
<! CTGRY ><LI>Benchmarks are typically time-related, but can also measure quantities such as how much memory is used.
<! CTGRY ><LI>A stopwatch is a versatile benchmarking tool.
<! CTGRY ><LI>System.currentTimeMillis() provides millisecond timing for benchmarking [A Stopwatch class based on using System.currentTimeMillis() is presented].
<! CTGRY ><LI>Use benchmarks to: Compare the performance of alternative solutions; Profile performance; Track performance changes.
<! CTGRY ><LI>Micro-benchmarks (repeatable sections of code) can be useful but may not represent real-world behavior. Factors that can skew micro-benchmark performance include Java virtual machine warm-up time, and global code interactions.
<! CTGRY ><LI>Macro-benchmarks (repeatable test sequences from the user point of view) test your system as actual end users will see it.
<! CTGRY ><LI>Extract minima, maxima and averages from repeated benchmark data for analysis. Use these to compare progress of benchmarks during tuning. [I like to add the 90th-centile value too].
<! CTGRY ><LI>Profilers help you find bottlenecks in applications, and should show: the methods called most often; the methods using the largest percentage of time; the methods calling the most-used methods; and the methods allocating a lot of memory.
<! CTGRY ><LI>The Sun JVM comes with the hprof profiler.
<! CTGRY ><LI>Bottlenecks can be tuned by making often-used methods faster; and by calling slow methods less often.
<! CTGRY ><LI>Backtrace methods to understand the context of the bottleneck. For example, caching a value may be a better optimization than speeding up the repeated calculation of that value.
<! CTGRY ><LI>Memory usage is often of critical importance to the overall application performance. Excessive memory allocation is often one of the first things that an experienced developer looks for when tuning a Java program.
<! CTGRY ><LI>Examine bottlenecks for memory allocation. For example you may be able to replace a repeated object allocation in a loop with a reusable object allocated once outside the loop.
<! CTGRY ><LI>Memory leaks (not releasing objects for the garbage collector to reclaim) can lead to a large memory footprint.
<! CTGRY ><LI>You identify memory leaks by: determining that there is a leak; then identifying the objects that are not being garbage colleted; then tracing the references to those leaking objects to determine what is holding them in memory.
<! CTGRY ><LI>If your program continues to use more and more memory then it has a memory leak. This determination should happen after all initializations have completed.
<! CTGRY ><LI>Identify memory leak objects by marking/listing the objects in some known state, then cycling through other states and back to that known state and seeing which extra objects are now present.
<! CTGRY ><LI>When there are obvious bottlenecks, the method profile should show these. A <em>flat</em> method profile is one where there are no obvious bottlenecks, no methods taking vastly more time than others. In this case you should look at cumulative method profiles, which show the relative times taken by a method and all the methods it calls (the <em>call tree</em>). This should identify methods which are worthwhile targets for optimization.
START
http://www.onjava.com/pub/a/onjava/2001/12/05/optimization.html
Measuring JDBC performance
(Page last updated December 2001, Added 2001-12-26, Author Jack Shirazi).
7
<! CTGRY ><LI>Effectively profiling distributed applications can be difficult. I/O can show up as significant in profiling, simply because of the nature of a distributed application.
<! CTGRY ><LI>It can be unclear whether threads blocking on reads and writes are part of a significant bottleneck or simply a side issue.
<! CTGRY ><LI>When profiling, it is usually worthwhile to have separate measurements available for the communication subsystems.
<! CTGRY ><LI>Wrapping the JDBC classes provides an effective technique for measuring database calls.
<! CTGRY ><LI>[Article discusses how to create JDBC wrapers to measure the performance of database calls].
<! CTGRY ><LI>If more than a few rows of a query are being read, then the ResultSet.next() method can spend a significant amount of time fetching rows from the database, and this time should be included in measurements of database access.
<! CTGRY ><LI>JDBC wrappers are simple and robust, and require very little alteration to the application using them (i.e, are low maintenance), so they are suitable to be retained within a deployed application.
START
http://www.onjava.com/pub/a/onjava/2001/12/19/oraclejdbc.html
Oracle JDBC tips
(Page last updated December 2001, Added 2001-12-26, Author Donald Bales).
7
<! CTGRY ><LI>Although Oracle recommend using the OCI driver for optimal client side access, the writer finds the Thin driver to have have better performance.
<! CTGRY ><LI>Turn off autocommit, Connection.setAutoCommit(false).
<! CTGRY ><LI>From the client side, Statement is faster than PreparedStatement (except if you are batching statements) when using dynamic SQL.
<! CTGRY ><LI>Use PreparedStatements for all, except dynamic, SQL statements.
<! CTGRY ><LI>Use PreparedStatements for batching repetitive inserts or updates.
<! CTGRY ><LI>OraclePreparedStatement.setExecuteBatch() (proprietary method) is the fastest way to execute batch statements.
<! CTGRY ><LI>Use SQL's set based processing capabilities to operate on multiple rows simultaneuosly, rather than blindly operating on one row at a time as the simplest Java-RDB architectural mapping will produce.
START
http://www.oreilly.com/catalog/jorajdbc/chapter/ch19.html
Chapter 19, "Performance" of Java Programming with Oracle JDBC
(Page last updated December 2001, Added 2001-12-26, Author Donald Bales).
8
<! CTGRY ><LI>Performance should be considered at the start of a project.
<! CTGRY ><LI>Use the EXPLAIN PLAN facility to explain how the database's optimizer plans to execute your SQL statements, to identify performance improvements such as additional indexes.
<! CTGRY ><LI>If more than one SQL statement is executed by your program, you can gain a small performance increase by turning off auto-commit.
<! CTGRY ><LI>It takes about 65 iterations of a prepared statement before its total time for execution catches up with a statement, because of prepared statement initialization overheads.
<! CTGRY ><LI>Use PreparedStatements to batch statements for optimal performance.
<! CTGRY ><LI>The Thin driver is faster than the OCI driver. This is contrary to Oracle's recommendation.
<! CTGRY ><LI>A SELECT statement makes two round trips to the database, the first for metadata, the second for data. Use OracleStatement.defineColumnType() to predefine the SELECT statement, thus providing the JDBC driver with the column metadata which then doesn't require the first database trip.
<! CTGRY ><LI>Given a simple SQL statement and a stored procedure call that accomplishes the same task, the simple SQL statement will always execute faster because the stored procedure executes the same SQL statement but also has the overhead of the procedure call itself. On the other hand complex tasks requiring several SQL statements can be faster using stored procedures as fewer network trips and data transfers will be needed.
START
http://www.fawcette.com/javapro/2002_01/magazine/columns/weblication/
Database performance
(Page last updated December 2001, Added 2001-12-26, Author Peter Varhol).
6
<! CTGRY ><LI>Thoughtful page design makes for a better user experience by enabling the application to seem faster than it really is.
<! CTGRY ><LI>Use the flush method associated with the out object to display static text and graphics on the browser page before the database query returns, to prevent the user from having to look at a blank page for a long time.
<! CTGRY ><LI>ResultSet types affect updates. TYPE_FORWARD_ONLY: no updating allowed; TYPE_SCROLL-SENSITIVE: update immediately; TYPE_SCROLL_INSENSITIVE: update when the connection is closed. (Concurrency type must be set to CONCUR-UPDATABLE to allow the table to be updated.)
<! CTGRY ><LI>Performance can be better if changes to the database are batched: turn off autocommit; add multiple SQL statements using the Statement.addBatch() method; execute Statement.executeBatch().
<! CTGRY ><LI>Scaled systems need optimized SQL calls, querying the right amount of data, and displaying pages before the query is complete.
<! CTGRY ><LI>Prepared statements also speed up database access, and should be used if a statement is to be executed more than once.
START
http://www-105.ibm.com/developerworks/education.nsf/java-onlinecourse-bytitle/56A6275393F0BE5786256AFD004DBBB4?OpenDocument
JDBC tutorial (requires free registration)
(Page last updated November 2001, Added 2001-12-26, Author Robert J. Brunner).
13
<! CTGRY ><LI>Type 1 (JDBC-ODBC-DB) drivers incur a performance penalty because of the bridging needed to reach the database.
<! CTGRY ><LI>[Type 2 (JDBC-clientDBAgent-DB) drivers seem to have middling performance].
<! CTGRY ><LI>Type 3 (JDBC-Middleware-DB) drivers incur a performance penalty because of the bridging needed to reach the database, but does introduce optimization potential from the location of the middleware.
<! CTGRY ><LI>Type 4 (JDBC-DB) drivers typically provide optimum driver performance.
<! CTGRY ><LI>The higher the level of transaction protection, the higher the performance penalty. Transaction levels in order of increasing level are: TRANSACTION_NONE, TRANSACTION_READ_UNCOMMITTED, TRANSACTION_READ_COMMITTED, TRANSACTION_REPEATABLE_READ, TRANSACTION_SERIALIZABLE. Use Connection.setTransactionIsolation() to set the desired tansaction level.
<! CTGRY ><LI>The default autocommit mode imposes a performance penalty by making every database command a separate transaction. Turn off autocommit (Connection.setAutoCommit(false)), and explicitly specify transactions.
<! CTGRY ><LI>Batch operations by combining them in one transaction, and in one statement using Statement.addBatch() and Statement.executeBatch().
<! CTGRY ><LI>Savepoints (from JDBC3.0) require expensive resources. Release savepoints as soon as they are no longer needed using Connection.releaseSavepoint().
<! CTGRY ><LI>Each request for a new database connection involves significant overhead. This can impact performance if obtaining new connections occurs frequently. Reuse connections from connection pools to limit the cost of creating connections. [The tutorial lists all the overheads involved in creating a database connection].
<! CTGRY ><LI>The ConnectionPoolDataSource (from JDBC3.0) and PooledConnection interfaces provide built-in support for connection pools.
<! CTGRY ><LI>Use setLogWriter() (from Driver, DataSource, or ConnectionPooledDataSource; from JDBC3.0)  to help trace JDBC flow.
<! CTGRY ><LI>Use Connection.setReadOnly(true) to optimize read-only database interactions.
<! CTGRY ><LI>Use Connection.nativeSQL() to see how the SQL query will execute in the database to help ensure that the SQL is optimized.
START
http://www-105.ibm.com/developerworks/education.nsf/java-onlinecourse-bytitle/975BFD2C367CFFD686256B0500581B3B?OpenDocument
Advanced JDBC tutorial (requires free registration).
(Page last updated November 2001, Added 2001-12-26, Author Robert J. Brunner).
2
<! CTGRY ><LI>PreparedStatement objects are compiled (prepared) by the JDBC driver or database for faster performance, and accept input parameters so they can be reused with different data.
<! CTGRY ><LI>Stored procedures are functions that execute inside a database which provides faster performance than plain SQL. Java supports stored procedures from CallableStatement objects.
START
http://developer.java.sun.com/developer/technicalArticles/J2EE/J2EEpatterns/
Performance optimizing design patterns for J2EE
(Page last updated December 2001, Added 2001-12-26, Author Vijay Ramachandran).
3
<! CTGRY ><LI>For read-only access to a set of data that does not change rapidly, use the Fast Lane Reader pattern which bypasses the EJBs and uses a (possibly non-transactional) data access object which encapsulates access to the data. Use the Fast Lane Reader to read data from the server and display all of them in one shot.
<! CTGRY ><LI>When you need to access a large remote list of objects, use the Page-by-Page Iterator pattern which sends smaller subsets of the data as requested until the client no longer want any more data. Use the Page-by-Page Iterator to send lists of simple objects from EJBs to clients. 
<! CTGRY ><LI>When the client would request many small data items which would require many remote calls to satisfy, combine the multiple calls into one call which results in a single Value Object which holds all the data required to be transferred. Use the Value Object to send a single coarse-grained object from the server to the client(s).
START
http://www.onjava.com/pub/a/onjava/2001/12/19/eejbs.html
EJBs are wonderful
(Page last updated December 2001, Added 2001-12-26, Author Tyler Jewell).
3
<! CTGRY ><LI>The out-of-the-box configuration for Entity EJB engines, such as WebLogic, are designed to handle read-write transactional data with the best possible performance.
<! CTGRY ><LI>There are studies that demonstrate entity EJBs with CMP have lackluster performance when compared with a stateless session bean (SLSB) with JDBC. [Author points out however that SLSB/JDBC combination is less robust, less configurable, and less maintainable].
<! CTGRY ><LI>Configure separate deployments for each entity bean for different usage patterns (e.g. typical 85% read-only, 10% read-write, 5% batch update), and partition the presentation layer to use the appropriate corresponding deployment (e.g. read requests use the read-only deployment).
START
http://www.fawcette.com/javapro/2001_12/magazine/features/kkothapalli/
EJB performance tips
(Page last updated December 2001, Added 2001-12-26, Author Krishna Kothapalli and Raghava Kothapalli).
11
<! CTGRY ><LI>Design coarse-grained EJB remote interfaces to reduce the number of network calls required.
<! CTGRY ><LI>Combine remote method calls into one call, and combine the data required for the calls into one transfer.
<! CTGRY ><LI>Reduce the number of JNDI lookups: cache the home handles.
<! CTGRY ><LI>Use session bean wrapper for returning multiple data rows from an entity bean, rather than returning one row at a time.
<! CTGRY ><LI>Use session beans for database batch operations, entity beans typically operate only one row at a time.
<! CTGRY ><LI>Use container-managed persistence (CMP) rather than bean-managed persistence (BMP).
<! CTGRY ><LI>Use entity beans when only a few rows are required for the entity, and when rows need to be frequently updated.
<! CTGRY ><LI>Use the lowest impact isolation (transaction) level consistent with maintaining data coherency. Highest impact down: TRANSACTION_SERIALIZABLE, TRANSACTION_REPEATABLE_READ, TRANSACTION_READ_COMMITED, TRANSACTION_READ_UNCOMMITED.
<! CTGRY ><LI>Correctly simulate the production environment to tune the application, and use profiling and other monitroing tools to identify bottlenecks.
<! CTGRY ><LI>Tune the underlying system, e.g. TCP/IP parameters, file limits, connection pool parameters, EJB pools sizes, thread counts, number of JVMs, JVM heap size, shared pool sizes, buffer sizes, indexes, SQL queries, keep/alive parameters, connection backlogs.
<! CTGRY ><LI>Use clustering to meet higher loads or consider upgrading the hardware.
START
http://www.onjava.com/pub/a/onjava/2001/12/12/jms_not.html
JMS & CORBA
(Page last updated December 2001, Added 2001-12-26, Author Steve Trythall).
1
<! CTGRY ><LI>Asynchronous messaging is a proven communication model for developing large-scale, distributed enterprise integration solutions. Messaging provides more scalability because senders and receivers of messages are decoupled and are no longer required to execute in lockstep.
START
http://www.javaworld.com/javaworld/jw-12-2001/jw-1207-hprof.html
The hprof profiler
(Page last updated December 2001, Added 2001-12-26, Author Bill Pierce).
3
<! CTGRY ><LI>Use the hprof profiler with the startup command "java -Xrunhprof[:help][:&lt;suboption>=&lt;value>,...] MyMainClass".
<! CTGRY ><LI>[Article describes using hprof and reading the resultant profile files to profile an application for memory leaks, cpu-bottlenecks and thread contention].
<! CTGRY ><LI>hprof can be used to profile object allocation (heap option), method bottlnecks (cpu option) and thread contention (monitor option).
START
http://www.onjava.com/pub/a/onjava/excerpt/JavaRMI_10/index.html
Chapter 10, "Serialization" from "Java RMI"
(Page last updated November 2001, Added 2001-12-26, Author William Grosso).
7
<! CTGRY ><LI>Use transient to avoid sending data that doesn't need to be serialized.
<! CTGRY ><LI>Serialization is a generic marshalling mechanism, and generic mechanisms tend to be slow.
<! CTGRY ><LI>Serialization uses reflection extensively, and this also makes it slow.
<! CTGRY ><LI>Serialization tends to generate many bytes even for small amounts of data.
<! CTGRY ><LI>The Externalizable interface is provided to solve Serialization's performance problems.
<! CTGRY ><LI>Externalizable objects do not have their superclass state serialized, even if the superclass is Serializable. This can be used to reduce the data written out during serialization.
<! CTGRY ><LI>Use Serializable by default, then make classes Externalizable on a case-by-case basis to improve performance.
START
http://developer.java.sun.com/developer/community/chat/JavaLive/2001/jl1113.html
Sun community chat on iPlanet
(Page last updated November 2001, Added 2001-12-26, Author Edward Ort).
1
<! CTGRY ><LI>Optimal result caching (caching pages which have been generated) needs tuning, especially the timeout setting. Make sure the timeout is not too short.
START
http://www.javaworld.com/javaworld/jw-12-2001/jw-1207-java101.html
Article about garbage collection and finalization.
(Page last updated December 2001, Added 2001-12-26, Author Jeff Friesen).
1
<! CTGRY ><LI>[No specific performance tips, but its always helpful to know about GC].
START
http://www.fawcette.com/javapro/2002_01/magazine/features/rgrehan/
How to Climb a B-tree
(Page last updated December 2001, Added 2001-12-26, Author Rick Grehan).
3
<! CTGRY ><LI>A B-tree outperforms a binary tree when used for external sorting (for example, when the index is stored out on disk) because searching a binary tree cuts the number of keys that need searching in half for every node searched, whereas B-tree searching cuts the number of keys that have to be searched by approximately 1/n, where n is the number of keys on a node.
<! CTGRY ><LI>B-tree variants provide faster searching at the cost of slower insertions and deletions. Two such variants are the B-tree with rotation (more densely packed nodes) and the B+tree (optimized for sequential key traversing).
<! CTGRY ><LI>[Article discusses building a B-tree class, and persisting it to provide a disk-based searchable index].
START
http://developer.java.sun.com/developer/technicalArticles/releases/nio/
The java.nio packages (updated)
(Page last updated December 2001, Added 2001-10-22, Author John Zukowski).
3
<! CTGRY ><LI>Direct buffers have a higher creation cost than non-direct buffers because they use native system operations rather than JVM operations.
<! CTGRY ><LI>Direct buffers optimize access operations by using the system's native I/O operations.
<! CTGRY ><LI>Reduce threads by multiplexing I/O using selectors: The new I/O capabilities, allow you to create a Web server that does not require one thread per connection.
START
http://www.javaworld.com/javaworld/jw-12-2001/jw-1214-jylog.html
JyLog logger
(Page last updated December 2001, Added 2001-12-26, Author Sanjay Dahiya).
1
<! CTGRY ><LI>Using JyLog (which uses the JPDA) slows down the JVM executuion time: use standard logging, not JyLog, for deployed applications.
START
http://www.devx.com/premier/mgznarch/javapro/2001/01dec01/sl0112/sl0112-1.asp
Creating Web-based, interactive graphics.
(Page last updated December 2001, Added 2001-12-26, Author Steve Lloyd).
2
<! CTGRY ><LI>If an applet parameter's [tags in the webpage] length is too long, the Web page's responsiveness begins to bog down. Move all but the essential parameters from the APPLET tag to a dedicated HTTP link between the applet and the servlet. This allows page loading and applet initialization to occur at the same time over separate connections.
<! CTGRY ><LI>Close java.sql.Statements when finished with.
START
http://www.javaworld.com/javaworld/javaqa/2001-12/01-qa-1207-ziprmi.html
Data compression
(Page last updated December 2001, Added 2001-12-26, Author Tony Sintes).
1
<! CTGRY ><LI>[Article covers how to add zip compression to RMI communications].
START
http://www.precisejava.com/javaperf/j2ee/EJB.htm
EJB performance tips
(Page last updated November 2001, Added 2001-12-26, Authors Ravi Kalidindi and Rohini Datla).
35
<! CTGRY ><LI>EJB calls are expensive. A method call from the client could cover all the following: get Home reference from the NamingService (one network round trip); get EJB reference (one or two network roundtrips plus remote creation and initialization of Home and EJB objects); call method and return value on EJB object (two or more network rountrips: client-server and [mutliple] server-db; several costly services used such as transactions, persistence, security, etc; multiple serializations and deserializations).
<! CTGRY ><LI>If you don't need EJB services for an object, use a plain Java object and not an EJB object.
<! CTGRY ><LI>Use Local interfaces (from EJB2.0) if you deploy both EJB Client and EJB in the same JVM. (For EJB1.1 based applications, some vendors provide pass-by-reference EJB implementations that work like Local interfaces).
<! CTGRY ><LI>Wrap multiple entity beans in a session bean to change multiple EJB remote calls into one session bean remote call and several local calls (pattern called SessionFacade).
<! CTGRY ><LI>Change multiple remote method calls into one remote method call with all the data combined into a parameter object.
<! CTGRY ><LI>Control serialization by modifying unnecessary data variables with  'transient' key word to avoid unnecessary data transfer over network.
<! CTGRY ><LI>Cache EJBHome references to avoid JNDI lookup overhead (pattern called ServiceLocator).
<! CTGRY ><LI>Declare non-transactional methods of session beans with 'NotSupported' or 'Never' transaction attributes (in the ejb-jar.xml deployment descriptor file).
<! CTGRY ><LI>Transactions should span the minimum time possible as transactions lock database rows.
<! CTGRY ><LI>Set the transaction time-out (in the ejb-jar.xml deployment descriptor file).
<! CTGRY ><LI>Use clustering for scalability.
<! CTGRY ><LI>Tune the EJB Server thread count.
<! CTGRY ><LI>Use the HttpSession object rather than a Stateful session bean to maintain client state.
<! CTGRY ><LI>Use the ECperf benchmark to help differentiate EJB server performances.
<! CTGRY ><LI>Tune the Stateless session beans pool size to minimize the creation and destruction of beans.
<! CTGRY ><LI>Use the setSessionContext() or ejbCreate() method to cache bean specific resources. Release acquired resources in the ejbRemove() method.
<! CTGRY ><LI>Tune the Stateful session beans cache size to and time-out minimize activations and passivations.
<! CTGRY ><LI>Allow stateful session beans to be removed from the container cache by explicitly using the remove() method in the client.
<! CTGRY ><LI>Tune the entity beans pool size to minimize the creation and destruction of beans.
<! CTGRY ><LI>Tune the entity beans cache size to minimize the activation and passivation of beans (and associated database calls).
<! CTGRY ><LI>Use the setEntityContext() method to cache bean specific resources and release them from the unSetEntityContext() method.
<! CTGRY ><LI>Use Lazy loading to avoid unnecessary pre-loading of child data.
<! CTGRY ><LI>Choose the lowest cost transaction isolation level that avoids corrupting the data. Transaction levels in increasing cost are: TRANSACTION_READ_UNCOMMITED, TRANSACTION_READ_COMMITED, TRANSACTION_REPEATABLE_READ, TRANSACTION_SERIALIZABLE.
<! CTGRY ><LI>Use the lowest cost locking available from the database that is consistent with any transaction.
<! CTGRY ><LI>Create read-only entity beans for read only operations.
<! CTGRY ><LI>Use a dirty flag where supported by the EJB server to avoid writing unchanged EJBs to the database.
<! CTGRY ><LI>Commit the data after the transaction completes rather than after each method call (where supported by EJB server).
<! CTGRY ><LI>Do bulk updates to reduce database calls.
<! CTGRY ><LI>Use CMP rather than BMP to utilize built-in performance optimization facilities of CMP.
<! CTGRY ><LI>Use ejbHome() methods for global operations (from EJB2.0).
<! CTGRY ><LI>Tune the connection pool size to minimize the creation and destruction of database connections.
<! CTGRY ><LI>Use JDBC directly rather than using entity beans when dealing with large amounts of data such as searching a large database.
<! CTGRY ><LI>Combine business logic with the entity bean that holds the data needed for that logic to process.
<! CTGRY ><LI>Tune the Message driven beans pool size to optimize the concurrent processing of messages.
<! CTGRY ><LI>Use the setMesssageDrivenContext() or ejbCreate() method to cache bean specific resources, and release those resources from the ejbRemove() method.
START
http://www.precisejava.com/javaperf/j2ee/JDBC.htm
JDBC performance tips
(Page last updated November 2001, Added 2001-12-26, Authors Ravi Kalidindi and Rohini Datla).
14
<! CTGRY ><LI>Use the fastest driver available to the database: normally type 4 (preferably) or type 3.
<! CTGRY ><LI>Tune the defaultPrefetch and defaultBatchValue settings.
<! CTGRY ><LI>Get database connections from a connection pool: use javax.sql.DataSource for optimal configurability. Use the vendor's connection pool; or ConnectionPoolDataSource and PooledConnection from JDBC2.0; or a proprietary connection pool.
<! CTGRY ><LI>Batch your transactions. Turn off autocommit and explicitly commit a set of statements.
<! CTGRY ><LI>Choose the fastest transaction isolation level consistent with your application requirements. Levels from slowest to fastest are: TRANSACTION_NONE, TRANSACTION_READ_UNCOMMITED, TRANSACTION_READ_COMMITED, TRANSACTION_REPEATABLE_READ, TRANSACTION_SERIALIZABLE.
<! CTGRY ><LI>Close resources (e.g. connections) when finished with them.
<! CTGRY ><LI>Use a PreparedStatement when you execute the same statement more than once.
<! CTGRY ><LI>Use CallableStatement to execute stored procedures. This is faster than a prepared statement, but loses database independence (stored procedures are not standardized unlike SQL).
<! CTGRY ><LI>Batch updates and accesses with Statements and ResultSets (with executeBatch() and setFetchSize()).
<! CTGRY ><LI>Set up the proper direction for processing rows.
<! CTGRY ><LI>Use the proper getXXX() methods.
<! CTGRY ><LI>Write SQL queries that minimize the data returned.
<! CTGRY ><LI>Cache read-only and read-mostly tables data.
<! CTGRY ><LI>Use the Page-by-Page Iterator pattern to repeatedly pass small amounts of data rather than huge chunks.
START
http://www.precisejava.com/javaperf/j2ee/Servlets.htm
Servlet performance tips
(Page last updated November 2001, Added 2001-12-26, Authors Ravi Kalidindi and Rohini Datla).
15
<! CTGRY ><LI>Use the servlet init() method to cache static data, and release them in the destroy() method.
<! CTGRY ><LI>Use StringBuffer rather than using + operator when you concatenate multiple strings.
<! CTGRY ><LI>Use the print() method rather than the println() method.
<! CTGRY ><LI>Use a ServletOutputStream rather than a PrintWriter to send binary data.
<! CTGRY ><LI>Initialize the PrintWriter with the optimal size for pages you write.
<! CTGRY ><LI>Flush the data in sections so that the user can see partial pages more quickly.
<! CTGRY ><LI>Minimize the synchronized block in the service method.
<! CTGRY ><LI>Implement the getLastModified() method to use the browser cache and the server cache.
<! CTGRY ><LI>Use the application server's caching facility.
<! CTGRY ><LI>Session mechanisms from fastest to slowest are: HttpSession, Hidden fields, Cookies, URL rewriting, the persistency mechanism.
<! CTGRY ><LI>Remove HttpSession objects explicitly in your program whenever you finish the session.
<! CTGRY ><LI>Set the session time-out value as low as possible.
<! CTGRY ><LI>Use transient variables to reduce serialization overheads.
<! CTGRY ><LI>Disable the servlet auto reloading feature.
<! CTGRY ><LI>Tune the thread pool size.
START
http://www.precisejava.com/javaperf/j2ee/JSP.htm
JSP performance tips
(Page last updated November 2001, Added 2001-12-26, Authors Ravi Kalidindi and Rohini Datla).
20
<! CTGRY ><LI>Use the jspInit() method to cache static data, and release them in the jspDestroy() method.
<! CTGRY ><LI>Use the jspInit() method to cache static data.
<! CTGRY ><LI>Use StringBuffer rather than using + operator when you concatenate multiple strings.
<! CTGRY ><LI>Use the print() method rather than the println() method.
<! CTGRY ><LI>Use a ServletOutputStream rather than a PrintWriter to send binary data.
<! CTGRY ><LI>Initialize the PrintWriter with the optimal size for pages you write.
<! CTGRY ><LI>Flush the data in sections so that the user can see partial pages more quickly.
<! CTGRY ><LI>Minimize the synchronized block in the service method.
<! CTGRY ><LI>Avoid creating a session object with the directive &lt;%@ page session="false" %>
<! CTGRY ><LI>Increase the buffer size of System.out with the directive &lt;%@ page buffer="12kb" %>
<! CTGRY ><LI>Use the include <em>directive</em> instead of the include <em>action</em> when you want to include another page.
<! CTGRY ><LI>Minimize the scope of the 'useBean' action.
<! CTGRY ><LI>Custom tags incur a performance overhead. Use as few as possible.
<! CTGRY ><LI>Use the application server's caching facility, and the session and application objects (using getAttribute()/setAttribute()). There are also third-party caching tags available.
<! CTGRY ><LI>Session mechanisms from fastest to slowest are: session, Hidden fields, Cookies, URL rewriting, the persistency mechanism.
<! CTGRY ><LI>Remove 'session' objects explicitly in your program whenever you finish the session.
<! CTGRY ><LI>Reduce the session time-out as low as possible.
<! CTGRY ><LI>Use 'transient' variables to reduce serialization overheads.
<! CTGRY ><LI>Disable the JSP auto reloading feature.
<! CTGRY ><LI>Tune the thread pool size.
START
http://www.precisejava.com/javaperf/j2ee/JMS.htm
JMS performance tips
(Page last updated November 2001, Added 2001-12-26, Authors Ravi Kalidindi and Rohini Datla).
11
<! CTGRY ><LI>Start the consumer before you start the producer so that the initial messages do not need to queue.
<! CTGRY ><LI>Use a ConnectionConsumer to process messages concurrently with a ServerSessionPool.
<! CTGRY ><LI>Close resources (e.g. connections, session objects, producers, consumers) when finished with them.
<! CTGRY ><LI>DUPS_OK_ACKNOWLEDGE and AUTO_ACKNOWLEDGE perform better than CLIENT_ACKNOWLEDGE.
<! CTGRY ><LI>Use separate transactional sessions and non-transactional sessions for transactional and non-transactional messages.
<! CTGRY ><LI>Tune the Destination parameters: a smaller capacity increases message throughput; a higher redelivery delay and lower redelivery limit reduces the overhead.
<! CTGRY ><LI>Choose non-durable (NON_PERSISTENT) messages wherever appropriate to avoid the persistency overhead.
<! CTGRY ><LI>Set the TimeToLive value as low as feasible (default is for messages to never expire).
<! CTGRY ><LI>Receive messages asynchronously with a MessageListener implementation.
<! CTGRY ><LI>Choose the message type that minimizes memory overheads.
<! CTGRY ><LI>Use 'transient' variables to reduce serialization overheads.
START
http://www.precisejava.com/javaperf/j2ee/Patterns.htm
Pattern performance tips
(Page last updated November 2001, Added 2001-12-26, Authors Ravi Kalidindi and Rohini Datla).
7
<! CTGRY ><LI>The ServiceLocator/EJBHomeFactory Pattern reduces the expensive JNDI lookup process by caching EJBHome objects.
<! CTGRY ><LI>The SessionFacade Pattern reduces network calls by combining accesses to multiple Entity beans into one access to the facade object.
<! CTGRY ><LI>The MessageFacade/ServiceActivator Pattern moves method calls into a separate object which can execute asynchronously.
<! CTGRY ><LI>The ValueObject Pattern combines remote data into one serializable object, thus reducing the number of network transfers required to access multiple items of remote data.
<! CTGRY ><LI>The ValueObjectFactory/ValueObjectAssembler Pattern combines remote data from multiple remote objects into one serializable object, thus reducing the number of network transfers required to access multiple items of remote data.
<! CTGRY ><LI>The ValueListHandler Pattern: avoids using multiple Entity beans to access the database, using Data Access Objects which explicitly query the database; and returns the data to the client in batches (which can be terminated) rather than in one big chunk, according to the Page-by-Page Iterator pattern.
<! CTGRY ><LI>The CompositeEntity Pattern reduces the number of actual entity beans by wrapping multiple java objects (which could otherwise be Entity beans) into one Entity bean.
START
http://java.sun.com/docs/books/performance/1st_edition/html/JPIOPerformance.fm.html
Chapter 4, "I/O Performance" of "Java Platform Performance: Strategies and Tactics."
(Page last updated 2000, Added 2001-12-27, Author Steve Wilson and Jeff Kesselman).
5
<! CTGRY ><LI>Buffer i/o operations.
<! CTGRY ><LI>Custom buffering (using your own array of bytes/chars) is quicker than using a Buffered class.
<! CTGRY ><LI>Application specific i/o can be tuned, e.g. caching in memory frequently served pages of a HTTP server.
<! CTGRY ><LI>Deafault Serialization is slow.
<! CTGRY ><LI>Use the <CODE>transient</CODE> keyword to define fields to avoid having those fields serialized. Examine serialized objects to determine which fields do not need to be serialized for the application to work.
START
http://java.sun.com/docs/books/performance/1st_edition/html/JPRAMFootprint.fm.html
Chapter 5, "RAM Footprint" of "Java Platform Performance: Strategies and Tactics."
(Page last updated 2000, Added 2001-12-27, Author Steve Wilson and Jeff Kesselman).
9
<! CTGRY ><LI>Virtual memory is many times slower than RAM: try to fit the application into available RAM on the target platform.
<! CTGRY ><LI>Runtime.totalMemory() and Runtime.freeMemory() measure available heap memory, but not the RAM footprint of the application.
<! CTGRY ><LI>Use operating system monitoring tools to determine the RAM footprint of the application: e.g. task manager on Windows NT, pmap -x and ps on Solaris.
<! CTGRY ><LI>Small GUI apps need several hundred classes to be loaded just to start the app. Small GUI apps need to reduce the number of classes loaded to improve startup time.
<! CTGRY ><LI>You can approximate sizes of objects based on the number of fields and their types: byte-1 byte; char-2 bytes; short-2 bytes; int-4 bytes; float-4 bytes; long-8 bytes; double-8 bytes; references-4 bytes. JVMs will impose additional overheads.
<! CTGRY ><LI>You can determine actual object sizes for a particular JVM by measuring the heap space taken by multiple instances of a class.
<! CTGRY ><LI>Use profiling to determine the overal size cost of a class of objects, to determine whether it is worth reducing the size cost of the class.
<! CTGRY ><LI>Some JVM/OS combinations can impose a significant memory overhead on each thread.
<! CTGRY ><LI>Use 'java -verbose <MyMainClass>' to identify all classes that are loaded.
START
http://java.sun.com/docs/books/performance/1st_edition/html/JPClassLoading.fm.html
Chapter 6, "Controlling Class Loading" of "Java Platform Performance: Strategies and Tactics."
(Page last updated 2000, Added 2001-12-27, Author Steve Wilson and Jeff Kesselman).
4
<! CTGRY ><LI>To avoid loading unnecessary classes (e.g. when the JIT compiles methods which refer to unused classes), use Class.forName() instead of directly naming the class in source. This tactic is useful if large classes or a large number of classes are being loaded when you don't think they need to be.
<! CTGRY ><LI>Combine listener functionality into one class to avoid an explosion of generated inner classes. This technique increases maintenance costs.
<! CTGRY ><LI>Use a Generic ActionListener which maps instances to method calls to avoid any extra listener classes. This has the drawback of losing compile-time checks. java.lang.reflect.Proxy objects can be used to generalize this technique to multiple interfaces.
<! CTGRY ><LI>Run multiple applications in the same JVM. [Chapter discusses how to do this, but see <A HREF="http://www.onjava.com/pub/a/onjava/2001/09/25/optimization.html">Multiprocess JVMs</A> and <A HREF="http://www.javagroup.org/echidna/">Echidna</A> for more comprehensive solutions].
START
http://www.sys-con.com/java/article.cfm?id=1268
EJB design
(Page last updated January 2002, Added 2002-01-25, Author Boris Lublinsky).
8
<! CTGRY ><LI>Some application server implementations (e.g., WebSphere) automatically convert remote communications to local communications to make them faster.
<! CTGRY ><LI>Low granularity (i.e. fine-grained) methods in an EJB typically leads to poor performance of the overall system.
<! CTGRY ><LI>Local interfaces in EJB 2.0 is one attempt to improve overall performance: local interfaces provide for beans in the same container to interact locally without involving RMI.
<! CTGRY ><LI>The most effective way to improve the overall performance of EJB-based applications is to minimize the amount of method invocations, making the communications overhead negligible compared with the execution time. This can be achieved by implementing coarse-grained methods.
<! CTGRY ><LI>Entity beans should not be simply mapped to database tables. Treating entity beans as such fine-grained objects which are effectively wrappers on table rows leads to increased network communications and heavier database communications than if entity beans are treated as coarse-grained components.
<! CTGRY ><LI>For optimal performance, entity beans should be designed to: have large granularity, which usually means they should contain multiple Java classes and support multiple database tables; be associated with a certain amount of persistent data, typically multiple database tables, one of which should define the primary key for the whole bean; support meaningful business methods and encapsulate business rules to access the data.
<! CTGRY ><LI>Don't use client transactions in the EJB environment since long-running transactions that can cause database lockup.
<! CTGRY ><LI>Entity beans are transactional resources due to their stateful nature, but application server vendors often rely on the underlying database to lock and resolve access appropriately. Although this approach greatly improves performance, it provides the potential for database lockup. 
START
http://developer.java.sun.com/developer/technicalArticles/J2EE/despat/
Design Patterns
(Page last updated January 2002, Added 2002-01-25, Author Vijay Ramachandran).
4
<! CTGRY ><LI>[Article discusses several design patterns: Model-View-Controller, Front Controller, Session Facade, Data Access Object].
<! CTGRY ><LI>Use the Front Controller pattern to channel all client requests through a single decision point, which allows the application to be balanced at runtime.
<! CTGRY ><LI>Use a Session Facade to provide a simple interface to a complex subsystem of enterprise beans, and to reduce network communication requirements.
<! CTGRY ><LI>Use Data Access Objects to decouple the business logic from the data access logic, allowing data access optimizations to be decoupled from other types of optimizations.
START
http://www.onjava.com/pub/a/onjava/2002/01/16/patterns.html
J2EE Design Patterns for the presentation tier
(Page last updated January 2002, Added 2002-01-25, Author Sue Spielman).
1
<! CTGRY ><LI>[Article discusses several design patterns: Intercepting Filter, Front Controller, View Helper, Composite View, Service To Worker, Dispatch View. Performance is not explicitly covered, but at least a couple are relevant to getting good performance].
START
http://www.devx.com/upload/free/Features/Javapro/2002/02feb02/kr0202/kr0202-1.asp
Thread programming
(Page last updated January 2002, Added 2002-01-25, Author Karthik Rangaraju).
5
<! CTGRY ><LI>Use Djikstra semaphores (synchronized acquire()/release()) to control access to a finite pool of resources.
<! CTGRY ><LI>Conditional events provide a more sophisticated version of the wait()/notify() mechanism which avoids some potential problems of that mechanism.
<! CTGRY ><LI>Blocking queues provides a mechanism for reliably distributing requests to multiple server threads.
<! CTGRY ><LI>A dispatcher-worker model consists of a dispatcher which hands requests of to multiple worker threads.
<! CTGRY ><LI>A pipeline model consists of a dispatcher which iteratively hands a particular request to one worker thread after another, with each worker thread completing part of the overall request.
START
http://softwaredev.earthweb.com/java/article/0,,12082_951051,00.html
Multithreading and read-write locks
(Page last updated January 2002, Added 2002-01-25, Author Nasir Khan).
1
<! CTGRY ><LI>When a thread passes through a synchronized block, <em>all</em> variables throughout the thread are synchronized with main memory, not just the set of variables in the current method.
START
http://softwaredev.earthweb.com/java/article/0,,12082_951051,00.html
Multithreading and read-write locks, part 2
(Page last updated January 2002, Added 2002-01-25, Author Nasir Khan).
2
<! CTGRY ><LI>Operations on primitive variables are atomic (except double and long), but a combination of two atomic operations is not atomic, and it is easy to make a mistake about this.
<! CTGRY ><LI>Volatile variables are always synchronized with the main memory copy.
START
http://www.onjava.com/pub/a/onjava/2002/01/09/dataexp1.html
Expiring cached data
(Page last updated January 2001, Added 2002-01-25, Author William Grosso).
7
<! CTGRY ><LI>Caching data on the client can improve performance, reduce communication overheads and increase the scalability of an application.
<! CTGRY ><LI>Be careful when caching information that cache doesn't contain out-of-date or incorrect information.
<! CTGRY ><LI>Servlet sessions expire after a settable timeout, but screens that automatically refresh can keep a session alive indefinitely, even when the screen is no longer in use.
<! CTGRY ><LI>Database connection pools can take one of two strategies: a limited size pool, where attempts to make connections beyond the pool size must wait for a connection to become idle; or a flexible sized pool with a preferred size which removes idle connections as soon as the preferred size is exceeded (i.e. temporarily able to exceed the preferred size). The fixed size pool is generally considered to be the better choice.
<! CTGRY ><LI>A time-based expiration strategy is appropriate for most types of cache elements. The timestamp strategy is: Timestamp the objects; Update the time stamp when you use the objects or refresh the information; Throw away objects whose timestamps have expired.
<! CTGRY ><LI>Only data that must be always totally up to date cannot effectively use a time-based expiration strategy.
<! CTGRY ><LI>[Article implements a time-based expiration framework].
START
http://www.sys-con.com/java/article.cfm?id=1280
Benchmarking
(Page last updated January 2002, Added 2002-01-25, Author Glenn Coates & Carl Barratt).
7
<! CTGRY ><LI>A benchmark should exhaustively exercise the platform being tested and produce a numerical result corresponding to the speed of the benchmark.
<! CTGRY ><LI>Benchmarks can be simplistic, made up of simple routines executed successively. Each routine should run for a reasonable amount of time.
<! CTGRY ><LI>Ensure that performance statistics are not lost within start-up overheads.
<! CTGRY ><LI>Don't rely on standard third-party benchmarks, as these may not apply to your application characteristics.
<! CTGRY ><LI>Benchmarks could include looking at the speed of code execution; the response time of the user interface; implementation of the garbage collector; and memory issues.
<! CTGRY ><LI>In J2ME, software accelerators may improve speed, but they may also consume excessive power compared to a processor that executes Java as its native language.
<! CTGRY ><LI>No benchmark can replace the actual user application. At the earliest possible stage in the design process, application developers must run their own code on the proposed hardware.
START
http://www.javaworld.com/javaworld/jw-01-2002/jw-0111-hotspotgc.html
Hotspot garbage collection in detail
(Page last updated January 2002, Added 2002-01-25, Author Ken Gottry).
7
<! CTGRY ><LI>HotSpot garbage collection default parameters are effective for most small applications, but can be tuned to improve throughput for large, server-side applications.
<! CTGRY ><LI>The most straightforward garbage collection algorithms iterate over every reachable object: this takes an amount of time proportional to the number of living objects.
<! CTGRY ><LI>Throughput (the percentage of total time not spent in GC) is normally the relevant metric for a server process since GC pauses may be tolerable or simply obscured by network latency.
<! CTGRY ><LI>Pauses (the times during GC when an application is unresponsive) is the more relevant metric for interactive graphical programs and other programs where short pauses may upset the user experience.
<! CTGRY ><LI>On systems with limited physical memory, footprint (the working set of a process, usually measured in pages) may dictate scalability.
<! CTGRY ><LI>[Article dicusses various parameters available to tuning HotSpot heap space].
<! CTGRY ><LI>Use verbosegc to capture garnage collection statistics.
START
http://www.javaworld.com/javaworld/jw-01-2002/jw-0104-java101.html
Reference objects
(Page last updated January 2002, Added 2002-01-25, Author Jeff Friesen).
3
<! CTGRY ><LI>Cache objects such as images in memory for quicker presentation after the first display request.
<! CTGRY ><LI>Use Reference objects to hold cached objects so that the garbage collector can free space when required.
<! CTGRY ><LI>[Article discusses in detail the various Reference object types].
START
http://www-106.ibm.com/developerworks/java/library/j-jtctips/j-jtc0117b.html
The Garbage Collector
(Page last updated January 2002, Added 2002-01-25, Author Phil Vickers).
2
<! CTGRY ><LI>In most current JVMs (prior to 1.4) GC starts off by locking out all other threads in the JVM. GC is a stop-the-world, synchronous operation. Non-generationl GC requires scanning the stacks of every thread and the entire Java heap.
<! CTGRY ><LI>Calling System.gc() explicitly is not good for performance, as it can be called when GC is not necessary, but will still result in a long pause of all JVM operations.
START
http://www-106.ibm.com/developerworks/java/library/j-jtctips/j-jtc0117e.html
Object management
(Page last updated January 2002, Added 2002-01-25, Author Mark Bluemel).
4
<! CTGRY ><LI>Avoid retaining objects accidentally, by holding references beyond an appropriate time for their release.
<! CTGRY ><LI>Use profiling tools to identify unintentionally retained objects.
<! CTGRY ><LI>Garbage collection is not free; other processing will be paused during GC.
<! CTGRY ><LI>Try to reuse objects in preference to discarding and re-creating them.
START
http://www-106.ibm.com/developerworks/java/library/j-jtctips/j-jtc0117a.html
JViewport scrolling performance
(Page last updated January 2002, Added 2002-01-25, Author Heather Brailsford).
1
<! CTGRY ><LI>JViewport.BLIT_SCROLL_MODE is the default scrolling mode for JViewport in SDK 1.3 (available since 1.2.2). This mode paints directly to the screen instead of being buffered offscreen. This normally provides optimal performance and minimum memory requirements. However complex images may display some intermediate paint operations if the painting is not fast enough, giving jerky or flashing images. If this is unacceptable, try the alternate modes: setScrollMode(BACKINGSTORE_SCROLL_MODE) (intermediate performance, higher memory requirements); or setScrollMode(JViewport.SIMPLE_SCROLL_MODE) (slowest).
START
http://www-106.ibm.com/developerworks/java/library/j-jtctips/j-jtc0117d.html
Using JNI Get* calls
(Page last updated January 2002, Added 2002-01-25, Author Mark Bluemel).
1
<! CTGRY ><LI>If you use JNI Get* calls (for example, GetStringCritical), you must always use the corresponding Release* call (for example, ReleaseStringCritical) when you have finished with the data, even if the isCopy parameter indicates that no copy was taken.
START
http://www.javaworld.com/javaworld/javatips/jw-javatip122.html
Typesafe Enumeration gotchas
(Page last updated January 2002, Added 2002-01-25, Author Vladimir Roubtsov).
2
<! CTGRY ><LI>Implement readResolve() for Serializable Enumeration classes to maintain object identity.
<! CTGRY ><LI>Ensure that the same Classloader always loads the Enumeration class to maintain object identity.
START
http://www.devx.com/upload/free/Features/Javapro/2002/02feb02/bk0202/bk0202-1.asp
Servlet 2.3 events
(Page last updated January 2002, Added 2002-01-25, Author Budi Kurniawan).
1
<! CTGRY ><LI>The Servlet 2.3 specification adds application and session events. [Event driven applications can often be scaled more easily than process driven applications].
START
http://java.sun.com/blueprints/patterns/j2ee_patterns/catalog.html
Design patterns catalog
(Page last updated 2001, Added 2002-01-25, Author ?).
7
<! CTGRY ><LI>[Page lists some patterns with summaries and links to detailed info. Patterns are: Data Access Object; Fast-Lane Reader; Front Controller; Page-by-Page Iterator; Session Facade; Value Object].
<! CTGRY ><LI>Use the Data Access Object pattern to decouple business logic from data access logic, allowing for optimizations to be made in how data is managed.
<! CTGRY ><LI>Use the Fast-Lane Reader pattern to accelerate read-only data access by not using enterprise beans.
<! CTGRY ><LI>Use the Front Controller pattern to centralize incoming client requests, allowing optimizations to be made in aggregating the resulting view.
<! CTGRY ><LI>Use the Page-by-Page Iterator pattern to efficiently access a large, remote list by retrieving its elements one sublist of value objects at a time.
<! CTGRY ><LI>Use the Session Facade pattern to provide a unified, workflow-oriented interface to a set of enterprise beans, thus minimizing client calls to server EJBs.
<! CTGRY ><LI>Use the Value Object pattern to efficiently transfer remote, fine-grained data by sending a coarse-grained view of the data.
START
http://www.ddjembedded.com/resources/articles/2001/0112g/0112g.htm
Balancing Network Load with Priority Queues
(Page last updated December 2001, Added 2002-02-22, Author Frank Fabian).
8
<! CTGRY ><LI>Hardware traffic managers redirect user requests to a farm of servers based on server availability, IP address, or port number.  All traffic is routed to the load balancer, then requests are fanned out to servers based on the balancing algorithm.
<! CTGRY ><LI>Popular load-balancing algorithms include: server availability (find a server with available processing capability); IP address management (route to the nearest server by IP address); port number (locate different types of servers on different machines, and route by port number); HTTP header checking (route by URI or cookie, etc).
<! CTGRY ><LI>Web hits should cater for handling peak hit rate, not the average rate.
<! CTGRY ><LI>You can model hit rates using gaussian distribution to determine the average hit rate per time unit (e.g. per second) at peak usage, then a poisson probability gives the probability of a given number of users simulatneously hitting the server within that time unit. [Article gives an example with gaussian fitted to peak traffic of 4000 users with a standard deviation of 20 minutes resulting in an average of 1.33 users per second at the peak, which in turn gives the probabilities that 0, 1, 2, 3, 4, 5, 6 users hitting the server within one second as 26%, 35%, 23%, 10%, 3%, 1%, 0.2%. Service time was 53 milliseconds, which means that the server can service 19 hits per second without the service rate requiring requests being queued.]
<! CTGRY ><LI>System throughput is the arrival rate divided by the service rate. If the ratio becomes greater than one, requests exceed the system capability and will be lost or need to be queued.
<! CTGRY ><LI>If requests are queued because capacity is exceeded, the throughput must drop sufficiently to handle the queued requests or the system will fail (the service rate must increase or arrival rate decrease). If the average throughput exceeds 1, then the system will fail. 
<! CTGRY ><LI>Sort incoming requests into different priority queues, and service the requests according to the priorities assigned to each queue. [Article gives the example where combining user and automatic requests in one queue can result in a worst case user wait of 3.5 minutes, as opposed to less than 0.1 seconds if priority queues are used].
<! CTGRY ><LI>[Note that Java application servers often do not show a constant service time. Instead the service time often decreases with higher concurrency due to non-linear effects of garbage collection].
START
http://www.smotricz.com/kabutz/Issue038a.html
Counting object creation
(Page last updated December 2001, Added 2002-02-22, Author Heinz M. Kabutz).
1
<! CTGRY ><LI>Add a counter in to the Object constructor to trace object creation. Doesn't trace arrays [nor objects created from deserialization].
START
http://www.microjava.com/articles/techtalk/recylcle2
Object recycling part 2
(Page last updated February 2002, Added 2002-02-22, Author Angus Muir and Roman Bialach).
2
<! CTGRY ><LI>The efficiency of pooling objects compared to creating and disposing of objects is highly dependent on the size and complexity of the objects.
<! CTGRY ><LI>Object pools have deterministic access and reclamation costs for both CPU and memory, whereas object creation and garbage collection can be less deterministic.
START
http://www.messageq.com/communications_middleware/timberlake_1.html
Multicasting efficiency
(Page last updated January 2002, Added 2002-02-22, Author Paul Timberlake).
3
<! CTGRY ><LI>When dealing with large numbers of active listeners, multicast publish/subscribe is more efficient than broadcast or multiple individual connections (unicast).
<! CTGRY ><LI>When dealing with large numbers of listeners with only a few active, or if dealing with only a few listeners, multicasting is inefficient. This scenario is common in enterprise application integration (EAI) systems. Inactive listeners require all missed messages to be resent to them in order when the listener becomes active.
<! CTGRY ><LI>A unicast-based message transport, such as message queuing organized into a hub-and-spoke model, is more efficient than multicast for most application integration (EAI) scenarios.
START
http://www.fawcette.com/javapro/2002_03/magazine/columns/proshop/default.asp
NIO
(Page last updated February 2002, Added 2002-02-22, Author Daniel F. Savarese).
3
<! CTGRY ><LI>GatheringByteChannel lets you to write a sequence of bytes from multiple buffers, and ScatteringByteChannel allows you to read a sequence of bytes into multiple buffers. Both let you minimize the number of system calls meade by combining operations that might otherwise require multiple system calls.
<! CTGRY ><LI>Selector allows you to multiplex I/O channels, reducing the number of threads required for efficient concurrent I/O operations.
<! CTGRY ><LI>FileChannels allow files to be memory mapped, rather than reading into a buffer. This can be more efficient. [But note that both operations bring the file into memory in different ways, so which is faster will be system and data dependent].
START
http://developer.java.sun.com/developer/technicalArticles/Programming/compression/
Compression in Java
(Page last updated February 2002, Added 2002-02-22, Author Qusay H. Mahmoud and Konstantin Kladko).
5
<! CTGRY ><LI>Compression techniques have efficiencies that vary depending on the data being compressed. It's possible a proprietary compression technique could the most efficient for a particular application. For example, instead of transmitting a compressed picture, the component objects that describe how to draw the picture may be a much smaller amount of data to transfer.
<! CTGRY ><LI>ZIPOutputStream and GZIPOutputStream use internal buffer sizes of 512. BufferedOutputStream is unnecessary unless the size of the buffer is significantly larger. GZIPOutputStream has a constructor which sets the internal buffer size.
<! CTGRY ><LI>Zip entries are not cached when a file is read using ZipInputStream and FileInputStream, but using ZipFile does cache data, so creating more than one ZipFile object on the same file only opens the file once.
<! CTGRY ><LI>In UNIX, all zip files opened using ZipFile are memory mapped, and therefore the performance of ZipFile is superior to ZipInputStream. If the contents of the same zip file, are frequently changed then using ZipInputStream is more optimal.
<! CTGRY ><LI>Compressing data on the fly only improves performance when the data being compressed are more than a couple of hundred bytes.
START
http://www.microjava.com/articles/techtalk/kvmprogramming
Porting to KVM
(Page last updated February 2002, Added 2002-02-22, Author Shiuh-Lin Lee).
12
<! CTGRY ><LI>Minimize program runtime size. Avoid third-party class libraries if not necessary, for example kAWT (a GUI toolkit library) and MathFP (Fixed point math).
<! CTGRY ><LI>Store big lookup tables in the user database rather than as part of the program.
<! CTGRY ><LI>Call GC functions manually.
<! CTGRY ><LI>Dispose of Objects; close the database and the network connections as soon as they are no longer needed.
<! CTGRY ><LI>Only load or transfer minimal required data structures and records into memory.
<! CTGRY ><LI>Avoid float and double calculations.
<! CTGRY ><LI>Avoid data conversions: store and use the data in the final required format, or execute conversions on the server.
<! CTGRY ><LI>Use client caching.
<! CTGRY ><LI>Data compression has to be tuned to minimize both client CPU impact as well as transfer size.
<! CTGRY ><LI>Use tabbed panels to hold different groups of information. Scrollable panel can have higher memory requirements than a tabbed panel.
<! CTGRY ><LI>Avoid some KVM user components (like ScrollTextBox), because they are runtime memory hogs.
<! CTGRY ><LI>Use selection lists rather than manual entry to speed up user data entry.
START
http://www.onjava.com/pub/a/onjava/2002/02/06/atomic.html
Atomic File Transactions, Part 2
(Page last updated February 2002, Added 2002-02-22, Author Jonathan Amsterdam).
3
<! CTGRY ><LI>[Article continues implementation of a framework for atomic file transactions].
<! CTGRY ><LI>If a transaction creates a file and then performs several other actions on it, there is no need to undo the actions -- it is enough to delete the file.
<! CTGRY ><LI>If a backup copy of a file is made, then it is unnecessary to roll back all subsequent actions on the file: recovery can simply restore the backup.
START
http://www-106.ibm.com/developerworks/webservices/library/ws-quality.html
Quality of service for web services
(Page last updated January 2002, Added 2002-02-22, Author Anbazhagan Mani, Arun Nagarajan).
14
<! CTGRY ><LI>Quality of service requirements for web services are: availability (is it running); accessiblity (can I run it now); integrity/reliability (will it crash while I run/how often); throughput (how many simultaneous requests can I run); latency (response time); regulatory (conformance to standards); security (confidentiality, authentication).
<! CTGRY ><LI>HTTP is a best-effort delivery service. This means any request could simply be dropped. Web services have to handle this and retry.
<! CTGRY ><LI>Web service latencies are measured in the tens to thousands of milliseconds.
<! CTGRY ><LI>Asynchronous messaging can improve throughput, at the cost of latency.
<! CTGRY ><LI>SOAP overheads include: extracting the SOAP envelope; parsing the contained XML information; XML data cannot be optimized very much; SOAP requires typing information in every SOAP message; binary data gets expanded (by an average of 5-fold) when included in XML, and also requires encoding/decoding.
<! CTGRY ><LI>Most existing XML parsers support type checking and conversion, wellformedness checking, or ambiguity resolution, making them slower than optimal. Consider using of stripped down XML parser which only pe4rforms essential parsing. 
<! CTGRY ><LI>DOM based parsers are slower than SAX based ones.
<! CTGRY ><LI>Compress the XML when the CPU overhead required for compression is less than the network latency.
<! CTGRY ><LI>Other factors affecting web service performance are: web server response time and availability; web application execution time (like EJB/Servlets in Web application server); back-end database or legacy system performance.
<! CTGRY ><LI>Requests results should be cached where possible.
<! CTGRY ><LI>Requests should be load balanced, prioritized according to the business value it represents.
<! CTGRY ><LI>Carry out capacity planning to enable the performance to be maintained in the future.
<! CTGRY ><LI>Extreme care should be taken to make sure that resources are not locked for long periods of time, to avoid serious scalability problems.
<! CTGRY ><LI>Measure the performance of your web services by adding code measuring elapsed time to the generated service proxy (and recompiling). [Article gives an example].
START
http://www.onjava.com/pub/a/onjava/2002/01/30/dataexp2.html
Data expiration in caches
(Page last updated January 2002, Added 2002-02-22, Author William Grosso).
1
<! CTGRY ><LI>[Article discusses and implements a framework for a cache with built in element expiration handling].
START
http://www.javaworld.com/javaworld/jw-01-2002/jw-0125-overpower.html
Wrapping PreparedStatement
(Page last updated January 2002, Added 2002-02-22, Author Bob Byron and Troy Thompson).
2
<! CTGRY ><LI>With Statement, the same SQL statement with different parameters must be recompiled by the database each time. But PreparedStatements can be parametrized, and these do not need to be recompiled by the database for use with different parameters.
<! CTGRY ><LI>[Article discusses a PreparedStatement wrapper class useful for debugging.]
START
http://www.xml.com/pub/a/2002/01/16/deviant.html
Webservices SOAP communications overheads
(Page last updated January 2002, Added 2002-02-22, Author Leigh Dodds).
4
<! CTGRY ><LI>Generating XML produces a large amount of data during communications, but this does not mean that the communication will be the bottleneck.
<! CTGRY ><LI>Webservices have all the same limitations of every other remote procedure calling (RPC) methodology. Requiring synchronous communications across a WAN is a heavy overhead regardless of the protocol.
<! CTGRY ><LI>If "Web services" tend to be chatty, with lots of little round trips and a subtle statefulness between individual communications, they will be slow. That's a function of failing to realize that the API call model isn't well-suited to building communicating applications where caller and callee are separated by a medium (networks!) with variable and unconstrained performance characteristics/latency.
<! CTGRY ><LI>Asynchronous messaging may be required for efficient webservices.
START
http://lists.xml.org/archives/xml-dev/200201/msg00477.html
Email summarizing best practices for Promoting Scalable Web Services
(Page last updated January 2002, Added 2002-02-22, Author Roger L. Costello).
7
<! CTGRY ><LI>Web services best practices are mainly the same as guidelines for developing other distributed systems.
<! CTGRY ><LI>Stay away from using XML messaging to do fine-grained RPC, e.g. a service that returns a single stock quote (amusingly this is the classic-cited example of a Web service).
<! CTGRY ><LI>Do use course-grained RPC, that is, use Web services that "do a lot of work, and return a lot of information".
<! CTGRY ><LI>When the transport may be slow and/or unreliable, or the processing is complex and/or long-running, consider an asynchronous messaging model.
<! CTGRY ><LI>Always take the overall system performance into account. Don't optimize until you know where the bottlenecks are, i.e., don't assume that XML's "bloat" or HTTP's limitations are a problem until they are demonstrated in your application.
<! CTGRY ><LI>Take the frequency of the messaging into account. Replicate data as necessary.
<! CTGRY ><LI>For aggregation services, try to retrieve data during off-hours in large, course-grained transactions.
START
http://www.aceshardware.com/read.jsp?id=45000251
Report of how Ace's Hardware made their SPECmine tool blazingly fast
(Page last updated December 2001, Added 2002-02-22, Author Chris Rijk).
12
<! CTGRY ><LI>Tranform your data to minimize the costs of searching it.
<! CTGRY ><LI>If your dataset is small enough, read it all into memory or use an in-memory database (keeping the primary copy on disk for recovery).
<! CTGRY ><LI>An in-memory datavase avoids the following overheads: no need to pass data in from a separate process; less memory allocation by avoiding all the data copies as it's passed between processes and layers; no need for data conversion; fine-tuned sorting and filtering possible; other optimizations become simpler.
<! CTGRY ><LI>Pre-calculation makes some results faster by making the database data more efficient to access (by ordering it in advance for example), or by setting up extra data in advance, generated from the main data, to make calculating the results for a query simpler.
<! CTGRY ><LI>Pre-determine possible data values in queries, and use boolean arrays to access the chosen values.
<! CTGRY ><LI>Pre-calculate all formatting that is invariant for generated HTML pages. Cache all reused HTML fragments.
<! CTGRY ><LI>Caching many strings may consume too much memory. IF memory is limited, it may be more effective to generate strings as needed.
<! CTGRY ><LI>Write out strings individually, rather than concatenating them and writing the result.
<! CTGRY ><LI>Extract common strings into an identical string object.
<! CTGRY ><LI>Compress generated html pages to send to the user, if their browser supports compressed html. This is a heavier load on the server, but produces a significantly faster transfer for limited bandwidth clients.
<! CTGRY ><LI>Some pages are temporarily static. Ccahe these pages, and only re-generate them when they change.
<! CTGRY ><LI>Caching can significantly improve the responsiveness of a website.
START
http://www.devx.com/premier/mgznarch/Javapro/2002/03mar02/kj0302/kj0302-1.asp
JMS vs RMI
(Page last updated February 2002, Added 2002-02-22, Author Kevin Jones).
6
<! CTGRY ><LI>RMI calls marshall and demarshall parameters, adding major overhead.
<! CTGRY ><LI>Every network communication has several overheads: the distance between the sender and the receiver adds a minimum latency (limited by the speed the signal can travel along the wire, about two-thirds of the speed of light: London to New York would take about 3 milliseconds); each network router and switch adds time to respond to data, on the order of 0.1 milliseconds per device per packet.
<! CTGRY ><LI>Part of most network communications consists of small control packets, adding significant overhead.
<! CTGRY ><LI>One RMI call does not generally cause a noticeable delay, but even tens of RMI calls can be noticeable to the users.
<! CTGRY ><LI>Beans written with many getXXX() and setXXX() methods can incur an RMI round trip for every data attribute.
<! CTGRY ><LI>Messaging is naturally asynchronous, and allows an application to decouple network communications from ongoing processing, potentially avoiding threads from being blocked on communications.
START
http://www.sys-con.com/java/article.cfm?id=1308
Proxy code generation
(Page last updated February 2002, Added 2002-02-22, Author Paul McLachlan).
5
<! CTGRY ><LI>Generative programming is a class of techniques that allows for more flexible designs without the performance overhead often encountered when following a more traditional programming style. JSP engines are one example. java.lang.reflect.Proxy is another.
<! CTGRY ><LI>More advanced code obfuscations (such as control-flow obfuscation) can produce slower programs as the obfuscated bytecode is more difficult to optimize by the JIT or HotSpot compiler.
<! CTGRY ><LI>A reflective lookup [obtaining the method reference from its name] is much slower than a reflective invoke [invoking the method from the reference] once you have a method reference.
<! CTGRY ><LI>[Article provides an implementation of the JNI call using the JVM_OnLoad() function to trap class bytecodes as they are loaded].
<! CTGRY ><LI>A generated Proxy class uses the Reflection API to look up the interface methods once in its static initializer, and generates wrappers and access methods to handle passing primitive data between methods. [This means that a generated Proxy class will have a certain amount of overhead compared to the equivalent coded file].
START
http://www.sys-con.com/java/article.cfm?id=1307
Generating code dynamically
(Page last updated February 2002, Added 2002-02-22, Author Norman Richards).
8
<! CTGRY ><LI>Compiling code into classes at runtime, such as for JSP pages, provides excellent flexibility with almost no performance overhead.
<! CTGRY ><LI>XSLTC can compile XSL stylesheets to speed up transforming XML input files.
<! CTGRY ><LI>If a complex interpreted procedure is expected to be used more than once, it can be more efficient to convert the procedure into an expression tree which will apply the procedure optimally.
<! CTGRY ><LI>Converting a complex interpreted procedure into code that can be compiled, then using a compiled version normally results in the fastest execution times for the procedure.
<! CTGRY ><LI>Sun's javac is not a very efficient compiler. Faster compilers are available, such as jikes.
<! CTGRY ><LI>Compiling code at runtime can take a significant amount of time. If the compile time needs to be minimized, it is important to use the fastest compiler available.
<! CTGRY ><LI>An in-memory compiler is significantly faster than compiling code using an external out-of-process Java compiler.
<! CTGRY ><LI>Generating bytecode directly in-process is significantly faster than compiling code using an external out-of-process Java compiler, and is also faster than using an in-memory compiler. <A HREF="http://bcel.sourceforge.net/">BCEL, the Bytecode Engineering Library</A>, is one possible bytecode generator.
START
http://www.sys-con.com/java/article.cfm?id=1301
JMS & JCACHE
(Page last updated February 2002, Added 2002-02-22, Author Steve Ross-Talbot).
5
<! CTGRY ><LI>Asynchronous messaged communications allows subsystems to decouple and work more efficiently in parallel, more closely reflecting actual workflows.
<! CTGRY ><LI>Read-only caches are a simple way of reducing communication overheads and improving the performance and scalability of distributed systems.
<! CTGRY ><LI>Event-driven systems tend to be more scalable.
<! CTGRY ><LI>Hierarchical caching replicates data across n-tiers, using finer and finer grained replication as the data approaches the requesting tier.
<! CTGRY ><LI>Read-write caching is an efficient technique when the number of [write-write transaction] conflicts it produces is low.
START
http://www.java-zone.com/free/articles/Liotta01/Liotta01-1.asp
Notated keys to access elements of nested Maps.
(Page last updated January 2002, Added 2002-02-22, Author Matt Liotta).
1
<! CTGRY ><LI>Use dot separated, concatenated strings to optimize access to elements of nested Maps by caching elements in the top level Map.
START
http://www.devx.com/upload/free/features/Javapro/2002/03mar02/jt0302/jt0302-1.asp
Optimizing Java for intensive numeric calculations
(Page last updated January 2002, Added 2002-02-22, Author James W. Cooper).
5
<! CTGRY ><LI>Allocating on the heap (as with object creation) is much slower than allocating on the stack.
<! CTGRY ><LI>Making numbers into first-class objects imposes a significant overhead on calculations.
<! CTGRY ><LI>Hand applied optimizations may be superceded by future compiler optimizations.
<! CTGRY ><LI>Use specialized subtypes to reduce dynamic dispatching.
<! CTGRY ><LI>Replace objects with their data held and passed as local variables.
START
http://www-106.ibm.com/developerworks/ibm/library/i-signalhandling/
OS Signal handling in Java
(Page last updated January 2002, Added 2002-02-22, Author Chris White).
1
<! CTGRY ><LI>[Article describes how to handle operating system signals from within Java. Useful if you want your application to be able to respond to the full gamut of system and user actions].
START
http://www-106.ibm.com/developerworks/java/library/j-native.html
Natively compiled code from Java source
(Page last updated January 2002, Added 2002-02-22, Author Martyn Honeyford).
3
<! CTGRY ><LI>Natively compiled code generated from Java source might be faster and might require less memory and disk resources. [But this articles show some JVMs can be faster].
<! CTGRY ><LI>When you include the disk size of the JVM libraries, a natively compiled Java application is significantly smaller in disk size.
<! CTGRY ><LI>When considering compiling Java applications to native code determine exactly what problem (or problems) you are hoping to solve with native compilation, and try all the available native compilers.
START
http://www.javareport.com/html/from_pages/article.asp?id=5769&mon=12&yr=2001
RMI arguments
(Page last updated December 2001, Added 2002-02-22, Author Scott Oaks).
1
<! CTGRY ><LI>Some application servers can automatically pass parameters by reference if the communicating EJBs are in the same JVM. To ensure that this does not break the application, write EJB methods so that they don't modify the parameters passed to them.
START
http://www.fawcette.com/javapro/2002_01/online/online_eprods/j2ee_sspielman1_25/
Choosing an application server
(Page last updated January 2002, Added 2002-02-22, Author Sue Spielman).
4
<! CTGRY ><LI>A large-scale server with lots of traffic should make performance its top priority.
<! CTGRY ><LI>Performance factors to consider include: connection pooling; types of JDBC drivers; caching features, and their configurability; CMP support.
<! CTGRY ><LI>Inability to scale with reliable performance means lost customers.
<! CTGRY ><LI>Scaling features to consider include failover support, clustering capabilities, and load balancing.
START
http://java.sun.com/docs/books/performance/1st_edition/html/JPMutability.fm.html
Chapter 7, "Object Mutability: Strings and other things" of "Java Platform Performance: Strategies and Tactics."
(Page last updated 2000, Added 2002-02-22, Author Steve Wilson and Jeff Kesselman).
9
<! CTGRY ><LI>The allocation, initialization, and collection of many short-lived useless objects can cause major inefficiencies in your software, even when running on an advanced runtime such as the HotSpot VM.
<! CTGRY ><LI>Be cautious when the number of objects you're allocating becomes very high-for example, when allocating objects inside loops.
<! CTGRY ><LI>For heavy-duty text processing, however, some uses of the String class can become major performance bottlenecks.
<! CTGRY ><LI>StringBuffer can be used to improve the performance of common text processing operations. 
<! CTGRY ><LI>Avoid creating new strings in compute intensive parts of code. Be careful of the concatenation operators '+' and '+=' when used with strings.
<! CTGRY ><LI>To avoid spurious object creation, create methods which return primitive data for multiple data items, rather than one method returning an object holding multiple data items.
<! CTGRY ><LI>Use immutable objects to prevent the need to copy objects to pass information between methods.
<! CTGRY ><LI>Object pooling small objects is often counterproductive. The overhead of managing the object pool is often greater than the small object penalty. Pooling can also increase a program's memory footprint.
<! CTGRY ><LI>Pooling large objects (e.g. large bitmaps or arrays) or objects that work with native resources (e.g. Threads or Graphics) can be efficient. 
START
http://java.sun.com/docs/books/performance/1st_edition/html/JPAlgorithms.fm.html
Chapter 8, "Algorithms and data structures" of "Java Platform Performance: Strategies and Tactics."
(Page last updated 2000, Added 2002-02-22, Author Steve Wilson and Jeff Kesselman).
13
<! CTGRY ><LI>Choosing the best algorithm or data structure for a particular task is one of the keys to writing high-performance software.
<! CTGRY ><LI>The optimal algorithm for a task is highly dependent on the data and data size.
<! CTGRY ><LI>Special-purpose algorithms usually run faster than general-purpose algorithms.
<! CTGRY ><LI>Testing for easy-to-solve subcases, and using a faster algorithm for those cases, is a mainstay of high-performance programming. 
<! CTGRY ><LI>Collection features such as ordering and duplicate elimination have a performance cost, so you should select the collection type with the fewest features that still meets your needs.
<! CTGRY ><LI>Most of the time ArrayList is the best List choice, but for some tasks LinkedList is more efficient.
<! CTGRY ><LI>HashSet is much faster than TreeSet.
<! CTGRY ><LI>Choosing a capacity for HashSet that's too high can waste space as well as time. Set the initial capacity to about twice the size that you expect the Set to grow to.
<! CTGRY ><LI>The default hash load factor (.75) offers a good trade-off between time and space costs. Higher values decrease the space overhead, but increase the time it takes to look up an entry. (When the number of entries exceeds the product of the load factor and the current capacity, the capacity is doubled).
<! CTGRY ><LI>Programs pay the costs associated with thread synchronization even when they're used in a single-threaded environment.
<! CTGRY ><LI>The Collections.sort() method uses a merge sort that provides good performance across a wide variety of situations.
<! CTGRY ><LI>When dealing with collections of primitives, the overhead of allocating a wrapper for each primitive and then extracting the primitive value from the wrapper each time it's used is quite high. In performance-critical situations, a better solution is to work with plain array structures when you're dealing with collections of primitive types.
<! CTGRY ><LI>Random number generation can take time. If possible you can pre-generate the random number sequence into an array, and use the elements when required.
START
http://www.onjava.com/pub/a/onjava/2002/03/20/optimization.html
Microtuning
(Page last updated March 2002, Added 2002-03-25, Author Jack Shirazi).
19
<LI>Performance is dependent on data as well as code. Different data can make identical code perform very differently.
<LI>Always start tuning with a baseline measurement.
<LI>The System.currentTimeMillis() method is the most basic measuring tool for tuning.
<LI>You may need to repeatedly call a method in order to reliably measure its average execution time.
<LI>Minimize the possibility that CPU time will be allocated to anything other than the test while it is running by ensuring no other processes are runing during the test, and that the test remains in the foreground.
<LI>Baseline measurements normally show some useful information, e.g. the average execution time for one call to a method.
<LI>Multiplying the average time taken to execute a method or sequence of methods, by the number of times that sequence will be called in a time period, gives you an estimate of the fraction of the total time that the sequence takes.
<LI>There are three routes to tuning a method: Consider unexpected differences in different test runs; Analyze the algorithm; Profile the method.
<LI>Creating an exception is a costly procedure, because of filling in stack trace.
<LI>A profiler should ideally be able to take a snapshot of performance between to arbitrary points.
<LI>Tuning is an iterative process: you normally find one bottleneck, make changes that improve performance, test those changes, and then start again.
<LI>Algorithm changes usually provide the best speedup, but can be difficult to find.
<LI>Examining the code for the causes of the differences in speed between two variations of test runs can be useful, but is restricted to those tests for which you can devise alternatives that show significant timing variations.
<LI>Profiling is always an option and almost always provides something that can be speeded up. But the law of diminishing returns kicks in after a while, leaving you with bottlenecks that are not worth speeding up, because the potential speedup is too small for the effort required.
<LI>Generic integer parsing (as with the Integer constructors and methods) may be overkill for converting simple integer formats.
<LI>Simple static methods are probably best left to be inlined by the JIT compiler rather than by hand.
<LI>String.equals() is expensive if you are only testing for an empty string. It is quicker to test if the length of the string is 0.
<LI>Set a target speedup to reach. With no target, tuning can carry on for much longer than is needed.
<LI>A generic tuning procedure is: Identify the bottleneck; Set a performance target; Use representative data; Measure the baseline; Analyze the method; Test the change; Repeat.
START
http://www.javaworld.com/javaworld/jw-03-2002/jw-0315-jms.html
JMS redelivery
(Page last updated March 2002, Added 2002-03-25, Author Prakash Malani).
2
<LI>Both auto mode (Session.AUTO_ACKNOWLEDGE) and duplicate delivery mode (Session.DUPS_OK_ACKNOWLEDGE) guarantee delivery of messages, but duplicate okay mode can have a higher throughput, at the cost of the occasionally duplicated message.
<LI>The redelivery count should be specified to avoid messages being redelivered indefinitely.
START
http://www.javaworld.com/javaworld/jw-03-2002/jw-0308-soap.html
Caching SOAP services
(Page last updated March 2002, Added 2002-03-25, Author Ozakil Azim and Araf Karsh Hamid).
2
<LI>Repeated SOAP-client calls to access server state can choke a network and degrade the server performance. Cache data on the client whenever possible to avoid requests to the server.
<LI>Ensure the client data remains up to date by using a call to a server service which blocks until data is changed.
START
http://developer.java.sun.com/developer/JDCTechTips/2002/tt0305.html
String concatenation, and IO performance.
(Page last updated March 2002, Added 2002-03-25, Author Glen McCluskey).
8
<LI>String concatenation '+' is implemented by the Sun compiler using StringBuffer, but each concatenation creates a new StringBuffer so is inefficient for multiple concatenations.
<LI>Immutable objects should cache their string value since it cannot change.
<LI>Operating systems can keep files in their own file cache in memory, and accessing such a memory-cached file is much faster than accessing from disk. Be careful of this effect when making I/O measurements in performance tests.
<LI>Fragmented files have a higher disk access overhead because each disk seek to find another file fragment takes 10-15 milliseconds.
<LI>Keep files open if they need to be repeatedly accessed, rather than repeatedly opening and closing them.
<LI>Use buffering when accessing file contents.
<LI>Explicit buffering (reading data into an array) gives you direct access to the array of data which lets you iterate over the elements more quickly than using a buffered wrapper class.
<LI>Counting lines can be done faster using explicit buffering (rather than the readLine() method), but requires line-endings to be explicitly identified rather than relying on the library method determining line-endings system independently.
START
http://developer.java.sun.com/developer/community/chat/JavaLive/2002/jl0305.html
Sun community chat on EJBs with Pravin Tulachan
(Page last updated March 2002, Added 2002-03-25, Author Edward Ort).
6
<LI>CMP (container managed persistence) is generally faster than BMP (bean managed persistence).
<LI>BMP can be faster with proprietary back-ends; with fine-grained transaction or security requirements; or to gain complete detailed persistency control.
<LI>Scalability is improved by passing primary keys rather than passing the entities across the network.
<LI>EJB 2.0 CMP is far faster than EJB 1.1 CMP. EJB 1.1 CMP was not necessarily capable of scaling to high transaction volumes.
<LI>If EJBs provide insufficient performance, session beans should be used in preference.
<LI>Don't make fine-grained method calls across the network. Use value object and session facade design patterns instead.
START
http://www-106.ibm.com/developerworks/java/library/j-jtctips/j-jtc0219a.html
Double-if on multi-CPU
(Page last updated February 2002, Added 2002-03-25, Author Phil Vickers).
1
<LI>Double-if logic fails on multiple CPU machines. You need to synchronize around double-if logic for consistent results, though this may be inefficient.
START
http://www.onjava.com/pub/a/onjava/excerpt/bldgjavaent_8/index3.html
Stateful to Stateless Bean
(Page last updated February 2002, Added 2002-03-25, Author Brett McLaughlin).
4
<LI>Stateless session beans are much more efficient than stateful session beans.
<LI>Stateless session bean have no state. Most containers have pools of stateless beans. Each stateless bean instance can serve multiplw clients, so the bean pool can be kept small, and doesn't need to change in size avoiding the main pooling overheads.
<LI>A separate stateful bean instance must exist for every client, making bean pools larger and more variable in size.
<LI>[Article discusses how to move a stateful bean implementation to stateless bean implementtaion].
START
http://www.ddj.com/documents/ddj0204a/
Alternatives to using 'new'.
(Page last updated March 2002, Added 2002-03-25, Author Jonathan Amsterdam).
10
<LI>The 'new' operator is not object oriented, and prevents proper polymorphic object creation.
<LI>Constructors must be made non-public and preferably private to limit the number of objects of a class.
<LI>The Singleton pattern and the Flyweight (object factory) pattern are useful to limit numbers of objects of various types and to assist with object reuse and reduce garbage collection.
<LI>The real-time specification for Java allows 'new' to allocate objects in a 'current memory region', which may be other than the heap. Each such region is a type of MemoryArea, which can manage allocation.
<LI>Using variables to provide access to limited numbers of objects is efficient, but a maintenance problem if you need to change the object access pattern, for example from a global singleton to a ThreadLocal Singleton.
<LI>A non-static factory method is polymorphic and so provides many advantages over static factory methods.
<LI>The Abstract Factory design pattern uses a single class to create more than one kind of object.
<LI>An alternative to the Flyweight pattern is the Prototype pattern, which allows polymorphic copies of existing objects. The Object.clone() method signature provides support for the Prototype pattern.
<LI>Prototypes are useful when object initialization is expensive, and you anticipate few variations on the initialization parameters. Then you could keep already-initialized objects in a table, and clone an existing object instead of expensively creating a new one from scratch.
<LI>Immutable objects can be returned directly when using Prototyping, avoiding the copying overhead.
START
http://www.eweek.com/article/0,3658,s=708&a=23125,00.asp
Tuning JVMs for servers.
(Page last updated February 2002, Added 2002-03-25, Author Timothy Dyck).
3
<LI>Multiple JVMs are often available for a particular platform. Choose the JVM that best suits your needs.
<LI>The test here found setting min and max heaps to the same value provided the best performance.
<LI>Limiting each Sun 1.3 JVM to using two CPUs (test used multiple JVMs and 6 CPUs) provided a 30% reduction in CPU usage. IBM JVMs did not require (or benefit from) this optimization.
START
http://www.ociweb.com/jnb/jnbMar2002.html
Object Resource Pooling
(Page last updated March 2002, Added 2002-03-25, Author Paul King).
10
<LI>If the overhead associated with creating a sharable resource is expensive, that resource is a good candidate for pooling.
<LI>Pooled objects create a resource in advance and store it away so it can be reused over-and-over.
<LI>Pooling may be necessary if a limited number of shared resources are available.
<LI>Pooling supports strategies such as load balancing, all-resources-busy situations, and other policies to optimize resource utilization.
<LI>[Article discusses pooling characteristics].
<LI>Load balancing is possible by varying how pooled objects are handed out.
<LI>Pool size can be tuned using low-water and high-water marks.
<LI>Waiting time when accessing empty pools can be tuned using a timeout parameter.
<LI>Unusable pooled objects may be recovered when most efficient, not necessarily when the underlying resource fails.
<LI>The Recycler pattern fixes only the broken parts of a failed object, to minimize the replacement cost.
START
http://www-106.ibm.com/developerworks/java/library/j-javaio/
Using NIO
(Page last updated March 2002, Added 2002-03-25, Author Aruna Kalagnanam and Balu G.).
3
<LI>A server that caters to hundreds of clients simultaneously must be able to use I/O services concurrently. Prior to 1.4, an almost one-to-one ratio of threads to clients made servers written in Java susceptible to enormous thread overhead, resulting in both performance problems and lack of scalability.
<LI>The Reactor design pattern demultiplexes events and dispatches them to registered object handlers. (The Observer pattern is similar, but handles only a single source of events where the Reactor pattern handles multiple event sources).
<LI>[Articles covers the changes needed to use java.nio to make a server efficiently muliplex non-blocking I/O from SDK 1.4].
START
http://www.hpmiddleware.com/newsletters/webservicesnews/features/
J2EE best practices.
(Page last updated February 2002, Added 2002-03-25, Author Chris Peltz).
2
<LI>Executing a search against the database calls one of the methods. finder() methods must return a collection of remote interfaces, not ValueObjects. Consequently the client would need to make a separate remote call for each remote interface received, to acquire data. The SessionFacade pattern suggests using a session bean to encapsulate the query and return a collection of ValueObjects, thus making the request a single transfer each way.
<LI>The Value Object Assembler pattern uses a Session EJB to aggregate all required data as various types of ValueObjects. This pattern is used to satisfy one or more queries a client might need to execute in order to display multiple data types.
START
http://www.onjava.com/pub/a/onjava/excerpt/wirelessjava_ch5/index3.html
MIDP GUI programming
(Page last updated March 2002, Added 2002-03-25, Author Qusay Mahmoud).
7
<LI>Applications with high screen performance needs, like games, need finer control over MIDP screens and should use the javax.microedition.lcdui package which provides the low-level API for handling such cases.
<LI>Always check the drawing area dimensions using Canvas.getHeight() and Canvas.getWidth() [so that you don't draw unnecessarily off screen].
<LI>Not all devices support color. Use Display.isColor() and Display.numColors( ) to determine color support and avoid color mapping [overheads].
<LI>Double buffering is possible by using an offscreen Image the size of the screen. Creating the image: <CODE>i = Image.createImage(width, height);</CODE> Getting the Graphics context for drawing: <CODE>i.getGraphics();</CODE> Copying to the screen <CODE>g.drawImage(i, 0, 0, 0);</CODE>
<LI>Check with Canvas.isDoubleBuffered(), and don't double-buffer if the MIDP implementation already does it for you.
<LI>To avoid deadlock paint() should not synchronize on any object already locked when serviceRepaints() is called.
<LI>Entering alphanumeric data through a handheld device can be tedious. If possible, provide a list of choices from which the user can select.
START
http://java.sun.com/people/jag/Fallacies.html
The Eight Fallacies of Distributed Computing
(Page last updated 2000, Added 2002-03-25, Author Peter Deutsch).
3
<LI>The network can fail to deliver at any time.
<LI>Latency is significant.
<LI>Bandwidth is always limited.
START
http://www.smotricz.com/kabutz/Issue042.html
Inverting booleans
(Page last updated February 2002, Added 2002-03-25, Author Heinz M. Kabutz).
2
<LI>The fastest way to invert a boolean is to XOR it (bool ^= true).
<LI>Be careful when making performance measurements with HotSpot because the optimizing compiler can kick in to adjust results.
START
http://www.javaworld.com/javaworld/jw-02-2002/jw-0222-designpatterns.html
The Proxy design pattern.
(Page last updated February 2002, Added 2002-03-25, Author David Geary).
7
<LI>Creating images is expensive.
<LI>ImageIcon instances create their images when they are constructed.
<LI>If an application creates many large images at once, it could cause a significant performance hit.
<LI>If the application does not use all of its images, it's wasteful to create them upfront.
<LI>Using a proxy, you can delay image loading until the image is required.
<LI>The Proxy pattern often instantiates its real object, the Decorator pattern (which can also use proxy objects) rarely does.
<LI>The java.lang.reflect package provides three classes to support the Proxy and Decorator patterns: Proxy, Method, and InvocationHandler.
START
http://www-106.ibm.com/developerworks/java/library/j-jtp0305.html
Java Transaction Service
(Page last updated March 2002, Added 2002-03-25, Author Brian Goetz).
4
<LI>Writing every data block to disk when any part of it changes would be bad for system performance. Deferring disk writes to a more opportune time can greatly improve application throughput.
<LI>Transactional systems achieve durability with acceptable performance by summarizing the results of multiple transactions in a single transaction log. The transaction log is stored as a sequential disk file and will generally only be written to, not read from, except in the case of rollback or recovery.
<LI>Writing an update record to a transaction log requires less total data to be written to disk (only the data that has changed needs to be written) and fewer disk seeks.
<LI>Changes associated with multiple concurrent transactions can be combined into a single write to the transaction log, so multiple transactions per disk write can be processed, instead of requiring several disk writes per transaction.
START
http://java.sun.com/products/java-media/2D/perf_graphics.html
High performance graphics
(Page last updated February 2002, Added 2002-03-25, Author ?).
16
<LI>The large number extra features and increased cross-platform compatibility added to the Java Graphics framework in SDK 1.2 made the graphics slower than the 1.1 Graphics. SDK 1.4 targeted these performance issues head on.
<LI>VolatileImage allows you to create hardware-accelerated offscreen images, resulting in better performance of Swing and gaming applications in particular and faster offscreen rendering.
<LI>When filling a shape with a complex paint, Java 2D must query the Paint object every time it needs to assign a color to a pixel whereas a simple color fill only requires iterating through the pixels and assigning the same color to all of them.
<LI>The graphics pipeline (from SDK 1.4) only gets invalidated when an attribute is changed to a different type of value, rather than when an attribute is changed to a different value of the same type. For example rendering one opaque color is the same rendering another opaque color, so this would not invalidate the pipeline. But changing an opaque color to a transparent color would invalidate the pipeline.
<LI>Smaller font is rendered faster than larger font.
<LI>Hardware-accelerated scaling is currently (1.4.0 release) disabled on Win32 because of quality problems, but you can enable it with a runtime flag, -Dsun.java2d.ddscale=true.
<LI>From SDK 1.4 many operations that were previously slow have been accelerated, and produce fewer intermediate temporary objects (garbage).
<LI>Alpha blending and anti aliasing adversely affect performance.
<LI>Only opaque images or images with 1-bit transparency can be hardware accelerated currently (1.4.0).
<LI>Use 1-bit transparency to make the background color of a sprite rectangle transparent so that the character rendered in the sprite appears to move through the landscape of your game, rather than within the sprite box.
<LI>Create images with the same depth and type of the screen to avoid pixel format conversions. Use either Component.createImage() or GraphicsConfiguration.createCompatibleImage(), or use a BufferedImage created with the ColorModel of the screen.
<LI>Rectangular fills--including horizontal and vertical lines--tend to perform better than arbitrary or non-rectangular shapes whether they are rendered in software or with hardware acceleration.
<LI>If your application must repeatedly render non-rectangular shapes, draw the shapes into 1-bit transparency images and copy the images as needed.
<LI>If you experience low frame rates, try commenting out pieces of your code to find the particular operations that are causing problems, and replace these problem operations with something that might perform better.
<LI>Various flags are available that affect performance, but may affect quality in some environments. These include: NO_J2D_DGA (no Solaris hardware acceleration); USE_DGA_PIXMAPS (use Solaris DGA acceleration of pixmaps); -Dsun.java2d.noddraw=true (turn off DirectDraw); -Dsun.java2d.ddoffscreen=false (disable DirectDraw offscreen acceleration); -Dsun.java2d.ddscale=true (enable hardware acceleration in Win32); -Dsun.java2d.pmoffscreen=true/false (store images in pixmaps under Unix); 
<LI>You can trace graphics performance using the flag <CODE>-Dsun.java2d.trace=<optionname>,<optionname>,...</CODE> where the options are <CODE>log</CODE> (print primitives on execution); <CODE>timestamp</CODE> (timestamp log entries); <CODE>count</CODE> (print total calls of each primitive used); <CODE>out:<filename></CODE> (send logs to filename); <CODE>verbose</CODE> (whatever); <CODE>help</CODE> (help);
START
http://developer.java.sun.com/developer/J2METechTips/2002/tt0226.html
Minimizing bytecode size for J2ME
(Page last updated February 2002, Added 2002-03-25, Author Eric Giguere).
6
<LI>Eliminate unnecessary features.
<LI>Avoid inner classes: make the main class implement the required Listener interfaces and handle the callbacks there.
<LI>Use built-in classes if functionality is close enough, and work around their limitations.
<LI>Collapse inheritence hierarchies, even if this means duplicating code.
<LI>Shorten all names (packages, classes, methods, data variables). Some obfuscators can do this automatically. MIDP applications are completely self-contained, so you can use the default package with no possible name-clash.
<LI>Convert array initialization from code to extract data from a binary string or data file. Array initialization generates many bytecodes as each element is separately initialized.
START
http://dcb.sun.com/practices/devnotebook/gc_perspective.jsp
GC performance tuning
(Page last updated February 2002, Added 2002-03-25, Author Alka Gupta and Michael Doyle).
13
<LI>The point when garbage collection kicks in is out of the control of the application. This can cause a sequential overhead on the application, as the garbage collector suspends all application threads when it runs, causing inconsistent and unacceptable application pauses, leading to high latency and decreased application efficiency.
<LI>verbosegc provides detailed logs of the garbage collector activities
<LI>The  live "transient memory footprint" of an application is the <CODE>(Garbage generated per call) * (duration of the call) * (number of calls per second)</CODE>.
<LI>GC pause time caused by two-space collection of short-lived objects is directly proportional to the size of the memory space allocated to holding short-lived objects. But smaller available space can mean more frequent GCs.
<LI>Higher frequency GC of short-lived objects can inadvertently promote short-lived objects to "old" space where longer lived objects reside [because if the the object is in short-lived object area for several GCs, then GC decides it's long-lived.] The promoteAll option will force the GC to assume that any object surviving GC of young space is long-lived, and is immediately promoted to old space..
<LI>The short-lived object space needs to be configured so that GC pause time is not too high, but GCs are not run so often that many short-lived objects are considered long-lived and so promoted to the more expensively GCed long-lived object space.
<LI>The long-lived object space needs to be large enough to avoid an out-of-memory error, but not so high that a full GC of old space pauses the JVM for too long.
<LI>[Article covers 1.2 and 1.3 GC memory space models].
<LI>A significant GC value to focus on is the GC sequential overhead, which is the the percentage of the system time during which GC is running and application threads are suspended: <CODE>(Sequential GC pause time added together) * (100) / (Total Application run time)</CODE>.
<LI>The concurrent garbage collector runs only most of the "old" space GC concurrently. Some of the "old" space GC and all the "young" space GC is sequential.
<LI>GC activity can take hours to settle down to its final pattern. Fragmentation of old space can cause GC times to degrade, and it may take a long time for the old space to become sufficiently fragmented to show this behavior.
<LI>GC options which can reduce fragmentation (such as bestFitFirst).
<LI>The promoteAll option produced a significant improvement in performance [which I find curious].
START
http://www.sys-con.com/java/article.cfm?id=1408
Combining apps in one JVM
(Page last updated April 2002, Added 2002-04-26, Author Kirk Pepperdine).
3
<! CTGRY ><LI>Loading multiple applications in the same JVM allows resource sharing and reduce system memory requirements.
<! CTGRY ><LI>Classloaders allow multiple applications to run in the same JVM without interfering with each other.
<! CTGRY ><LI>[Article discusses the resource sharing problems of running multiple applications in the same JVM].
START
http://www.onjava.com/pub/a/onjava/2002/04/03/javaenterprise_tips.html
J2EE worst practices
(Page last updated April 2002, Added 2002-04-26, Author Brett McLaughlin).
3
<! CTGRY ><LI>The choice of data store type (RDB, ODB, XML-DB, directory-server, etc) affects performance, and should not be made without performance considerations.
<! CTGRY ><LI>Directory servers are optimized for frequent reads, with few writes. If you frequently add data to a directory server, performance degrades.
<! CTGRY ><LI>Stateless session beans are soooo much faster.
START
http://www.sys-con.com/java/article.cfm?id=1412
Mobile & wireless devices
(Page last updated April 2002, Added 2002-04-26, Author James White).
10
<! CTGRY ><LI>Prototype to determine the performance of your device. Wireless transmissions require testing to determine if the transfer rates and processing times are acceptable.
<! CTGRY ><LI>Attempt to create applications that can accomplish 80% or more of their operations through the touch of a single key/button or the "tap" or touch of the stylus to the screen.
<! CTGRY ><LI>Trying to manipulate a very small scroll bar on a small screen can be an exercise in hand-eye coordination. Horizontal scrolling should be avoided at all costs. Use "jump-to" buttons rather than scrollbars.
<! CTGRY ><LI>Try to avoid having the user remember any data, or worse, having to compare data across screens.
<! CTGRY ><LI>Performance will always be a concern in J2ME.
<! CTGRY ><LI>Avoid garbage generation: Use StringBuffer for mutable strings;  Pool reusable instances of objects like DateFormat; Use System.gc() to jump-start or push the garbage collection process.
<! CTGRY ><LI>Compile the code with debugging information turned off using the -g:none switch. This increases performance and reduces its footprint.
<! CTGRY ><LI>Avoid deep hierarchies in your class structure.
<! CTGRY ><LI>Consider third-party JVMs, many are faster than the Sun ones.
<! CTGRY ><LI>Small XML parsers and micro databases are available for purchase where necessary.
START
http://www.eweek.com/article/0,3658,s=708&a=23115,00.asp
Database comparison
(Page last updated February 2002, Added 2002-04-26, Author Timothy Dyck).
6
<! CTGRY ><LI>SQLServer has driver problems that slow access to it.
<! CTGRY ><LI>Connection memory requirements vary dramatically between databases, and affect how much memory can be allocated to other resources.
<! CTGRY ><LI>In-memory query result caches (such as with mySQL) improves performance significantly. (Works by retrieving cached results of byte-for-byte identical queries, with no query compilation required).
<! CTGRY ><LI>Add extra indexes.
<! CTGRY ><LI>Arrange the stored order of rows to best satisfy the queries.
<! CTGRY ><LI>Some drivers store the entire result set in memory when using bidirectional cursors - which does not scale.
START
http://www.sys-con.com/weblogic/article.cfm?id=58
Why CMP is better than BMP
(Page last updated April 2002, Added 2002-04-26, Author Tyler Jewell).
2
<! CTGRY ><LI>Use CMP except in specific cases when BMP is necessary: fields use stored procedures; persistence is not simple JDBC (e.g. JDO); One bean maps to multiple tables; non-standard SQL is used.
<! CTGRY ><LI>CMP can make many optimizations: optimal locking; optimistic transactions; efficient lazy loading; efficiently combining multiple queries to the same table (i.e. multiple beans of the same type can be handled together); optimized multi-row deletion to handle deletion of beans and their dependents.
START
http://www.sys-con.com/websphere/article.cfm?id=40
JDBC optimizing for DB2
(Page last updated April 2002, Added 2002-04-26, Author John Goodson).
13
<! CTGRY ><LI>Use the same connection to execute multiple statements.
<! CTGRY ><LI>Keep connection objects open, and reuse them, rather than repeatedly connecting and disconnecting.
<! CTGRY ><LI>Turn off autocommit, but don't leave transactions open for too long.
<! CTGRY ><LI>Avoid distributed transactions (transactions that span mutliple connections).
<! CTGRY ><LI>Minimize the data retrieved from the database, both columns and rows. Use setMaxRows, setMaxFieldSize, and SetFetchSize.
<! CTGRY ><LI>Use the most efficiently handled data type: character strings are faster than integers, which are in turn more efficient than floating-point and timestamps.
<! CTGRY ><LI>Use programmatic updates: updateXXX() calls on updatable resultsets. The resultset is already postioned at a row, so eliminating the usual overhead of finding the row to be updated when using an UPDATE statement.
<! CTGRY ><LI>Cache any required metadata and use metadata methods as rarely as possible as they are quite slow.
<! CTGRY ><LI>Avoid using null parameters in metadata queries.
<! CTGRY ><LI>Use a dummy query to get the metadata for a column, rather than use the getcolumns() 
<! CTGRY ><LI>Use parameter markers with stored procedures, rather than embedding data literally in the statement, to minimize parsing overheads.
<! CTGRY ><LI>Use prepared statements for repeatedly executing SQL statements
<! CTGRY ><LI>Choose the optimal cursor: forward-only for sequential reads; insensitive for two-way scrolling. Avoid insenstive cursors for queries that only returns one row.
START
http://www-106.ibm.com/developerworks/java/library/j-jtctips/j-jtc0319a.html
Finalizers
(Page last updated March 2002, Added 2002-04-26, Author Phil Vickers).
2
<! CTGRY ><LI>Adding finalizers to your code makes GC much more expensive and unpredictable.
<! CTGRY ><LI><! CTGRY ><LI>Finalizers are not executed at a predictable time.
START
http://www.messageq.com/systems_management/currie_1.html
Monitoring Networked Applications
(Page last updated March 2002, Added 2002-04-26, Author Russ Currie).
1
<! CTGRY ><LI>Use network probes to break down how the network is being used by the various networked applications on it.
START
http://java.sun.com/features/2002/03/swinggui.html
Accelerating GUI apps (after 1.4)
(Page last updated March 2002, Added 2002-04-26, Author Dana Nourie).
8
<! CTGRY ><LI>To add many items to a JComboBox, add them in one go using a Model on a vector, e.g. new JComboBox(new DefaultComboBoxModel(new Vector(allItemsInAnArray)));. This generates only one changed event.
<! CTGRY ><LI>Perform GUI operations in bulk to minimize the events generated.
<! CTGRY ><LI>When initializing or totally replacing the contents of a model, construct a new one instead of reusing the existing one to minimize generated events.
<! CTGRY ><LI>Use threads other then the GUI handling thread for long, indeterminate, or repetitive tasks.
<! CTGRY ><LI>VolatileImage allows you to create a hardware-accelerated offscreen image and manage the contents of that image.
<! CTGRY ><LI>From 1.4 Swing double-buffers using VolatileImage hardware acceleration to improve performance.
<! CTGRY ><LI>Repaint small regions instead of entire sections or screens. For instance, when using tables, repaint a single table cell as needed instead of repainting the entire screen or table. 
<! CTGRY ><LI>EventHandler provides support for dynamically generating event listeners that have a small footprint and can be saved automatically by the persistence scheme.
START
http://developer.java.sun.com/developer/J2METechTips/2002/tt0325.html
MIDP tips
(Page last updated March 2002, Added 2002-04-26, Author Eric Giguere).
3
<! CTGRY ><LI>Make HTTP requests in a background thread.
<! CTGRY ><LI>Use an asynchronous messaging model.
<! CTGRY ><LI>Use WBXML to compress XML messages.
START
http://portals.devx.com/Intel/Article/6441
Some (Intel chip) optimization myths debunked.
(Page last updated March 2002, Added 2002-04-26, Author George Walsh).
2
<! CTGRY ><LI>If optimization and performance tools are used throughout development rather than tacked on at the end as a final "optimization phase," time to market and costs can actually be decreased by speeding up the process of locating problems and bottlenecks in code.
<! CTGRY ><LI>Not taking advantage of new optimized interfaces will ultimately put you at a competitive disadvantage.
START
http://dev2dev.bea.com/articlesnews/discussion/thread.jsp?forum=1&thread=33
EJB Clustering
(Page last updated February 2002, Added 2002-04-26, Author Tyler Jewell).
1
<! CTGRY ><LI>Four locations that can provide clustering logic for an EJB are: the JNDI naming server where the home stub is bound, the container, the home stub, and the remote stub.
START
http://developer.java.sun.com/developer/JDCTechTips/2002/tt0409.html
Assertions
(Page last updated April 2002, Added 2002-04-26, Author Glen McCluskey).
3
<! CTGRY ><LI>Disabled assertions add a cost of one check of a global state flag
<! CTGRY ><LI>Enabled assertions add a cost of a check of a global state flag and evaluating the boolean expression. Also the cost of throwing a new exception is added if the assertion fails.
<! CTGRY ><LI>Use the conditional compilation idiom applied to assertions to remove assertions completely from the bytecode.
START
http://www-106.ibm.com/developerworks/java/library/j-jtp0410/?loc=j
Java transaction management (JTS)
(Page last updated April 2002, Added 2002-04-26, Author Brian Goetz).
1
<! CTGRY ><LI>A container managing transactions can identify communications to the same database, and automatically convert a two-phase transaction into a more efficient single-phase commit.
START
http://portals.devx.com/datadirect/Article/6338
JDBC Drivers
(Page last updated March 2002, Added 2002-04-26, Author Barrie Sosinsky).
14
<! CTGRY ><LI>Type 1 drivers are JDBC-ODBC bridges, plus an ODBC driver. Recommended only for prototyping, not for production. Not suitable for high-transaction environments. Not well supported, and limited in functionality.
<! CTGRY ><LI>Type 2 drivers use a native API, and are part-Java drivers. Have a binary-code client loading overhead, and may not be fully-featured.
<! CTGRY ><LI>Type 3 drivers are a pure Java driver which connects to database middleware. Can be server-based which is frequently faster than types 1 and 2.
<! CTGRY ><LI>Type 4 drivers are pure Java drivers for direct-to-database communications. This can minimize overheads, and generally provides the fastest driver.
<! CTGRY ><LI>JDBC 3.0 has additional features to improve performance such as advancements in connection pooling, statement pooling, RowSet objects.
<! CTGRY ><LI>Opening a connection is the most resource-expensive step in database transactions. Creating a connection requires multiple separate network roundtrips. However, once the connection object has been created, there is little penalty in leaving the connection object in place and reusing it for future connections. 
<! CTGRY ><LI>Connection pooling, keeps open a cache of database connection objects, making them available for immediate use. Instead of performing expensive network roundtrips to the database server to open a connection, a connection attempt results in the re-assignment of a connection from the local cache. 
<! CTGRY ><LI>RowSet objects are similar to ResultSet objects, but can provide access to database data while being disconnected. This allows data to be efficiently cached in its simplest form.
<! CTGRY ><LI>Prepared statement pooling (available from JDBC 3.0) caches SQL queries that have been previously optimized and run so that, should they be needed again, they do not have to go through optimization pre-processing again (avoiding optimization steps, such as checking syntax, validating addresses, and optimizing access paths and execution plans). Statement pooling can be a significant performance booster.
<! CTGRY ><LI>Statement pooling and connection pooling in JDBC 3.0 can cooperate to share statement pools, so that connections that can use a cached statement from another connection, thus incurring statement preparation overheads only once on the first execution of some SQL by any connection.
<! CTGRY ><LI>Database drivers developed by vendors other than the the database vendor can be better performing and more feature full. (Driver vendors concentrate on the driver, database vendors have many other things to consider).
<! CTGRY ><LI>Type 3 and type 4 third-party drivers can provide better performance than the database vendor's native-API (type 2) driver.
<! CTGRY ><LI>Try to use a driver that supports JDBC 3.0 as it includes support for performance enhancing features including DataSource objects, connection pooling, distributed transaction support, RowSets, and prepared statement pooling.
<! CTGRY ><LI>Type 3 and Type 4 drivers are the drivers to use when performance is important.
START
http://www.smotricz.com/kabutz/Issue001.html
Deadlocks
(Page last updated November 2000, Added 2002-04-26, Author Heinz M. Kabutz).
3
<! CTGRY ><LI>Use CTRL+BREAK to get a thread dump when a deadlock occurs, to find where the deadlock is.
<! CTGRY ><LI>Use SwingUtlities.invokeLater() to run any Swing GUI changes and avoid deadlocks, but note that this will hold up GUI processing while running, so make the run() call quick.
<! CTGRY ><LI>Use SwingUtilities.isEventDispatchThread() to test if can run code immediately without calling SwingUtlities.invokeLater().
START
http://www.smotricz.com/kabutz/Issue002.html
Anonymous inner classes
(Page last updated December 2000, Added 2002-04-26, Author Heinz M. Kabutz).
1
<! CTGRY ><LI>Accessing private data members of an outer class, is done using a generated method, which is slower than normal field access. Though HotSpot can inline the access.
START
http://developer.java.sun.com/developer/community/chat/JavaLive/2002/jl0423.html
Sun community chat on High Performance GUIs with the JFC/Swing, with Steve Wilson, Scott Violet, and Chet Haase
(Page last updated April 2002, Added 2002-05-19, Author Edward Ort).
6
<! CTGRY ><LI>[Some discussion of performance improvents in 1.4]
<! CTGRY ><LI>Multi-threading with swing must be done correctly, using invokeAndWait() and invokeLater()
<! CTGRY ><LI>Default models have performance limitations. Create dedicated models for high performance. Consider using a custom RepaintManager for very large tables.
<! CTGRY ><LI>Don't use a MouseListener with a renderer
<! CTGRY ><LI>BufferedImage is treated more optimally than MemoryImageSource
<! CTGRY ><LI>Try using createImage(w,h), which returns an image in the same format as the screen, which allows faster copies from that image to the screen (important for copying speed issues).
START
http://portals.devx.com/Nokia/Article/6218
J2ME game building
(Page last updated April 2002, Added 2002-05-19, Author Dale Crowley).
6
<! CTGRY ><LI>J2ME device memory and speeds are very limited which affects everything from the data-loading speed to the frame/refresh rate, and seriously limits the ability to animate characters or otherwise rapidly change the screen.
<! CTGRY ><LI>Smart graphics is important: you need to draw clear, concise images at extremely low resolutions and with very small palettes. Animated characters need dynamic, easily-read poses which avoid kicks looking like a dance steps, or punches looking like an arm waves.
<! CTGRY ><LI>Use public variables in your classes, rather than using accessors. This is technically bad programming practice but it saves bytecode space.
<! CTGRY ><LI>Be extra careful to place things in memory only when they are in use. For example, discard an introduction splash screen after display. 
<! CTGRY ><LI>Try to reduce the number of classes used. Combine classes into one if they vary only slightly in behavior. Every class adds size overheads.
<! CTGRY ><LI>Remember that loading and installing applications into J2ME phones is a relatively slow process.
START
http://www.nature.com/Physics/Physics.taf?g=&file=/physics/highlights/6882-2.html&filetype=&_UserReference=C0A804EE46B4E669A2A54F7523EA3CC1CE04
Optimizing Searches via Rare Events
(Page last updated April 2002, Added 2002-05-19, Authors ANDREA MONTANARI & RICCARDO ZECCHINA).
1
<! CTGRY ><LI>Re-starting a search algorithm at random times can improve the average time required to reach the solution.
START
http://developer.java.sun.com/developer/JDCTechTips/2002/tt0507.html
File Channels, StackTraceElements,
(Page last updated May 2002, Added 2002-05-19, Author Glen McCluskey).
2
<! CTGRY ><LI>File Channels (from the 1.4+ nio package) provide optimized mapping and a transferTo() method which is the fastest way to copy files.
<! CTGRY ><LI>StackTraceElement provides access to the stack from excception objects, useful for analyzing stack elements.
START
http://www.onjava.com/pub/a/onjava/2002/07/10/jboss.html
Clustering with JBoss
(Page last updated July 2002, Added 2002-07-24, Authors Bill Burke, Sacha Labourey).
5
<LI>A hardware- or software-based HTTP load-balancer usually sits in front of the application servers within a cluster. The load balancer can decrypt HTTPS requests and distribute load.
<LI>HTTP session replication is expensive for a J2EE application server. If you can live with forcing a user to log in again after a server failure, then an HTTP load-balancer probably provides all of the fail-over and load-balancing functionality you need.
<LI>If you are storing things other than EJB Home references in your JNDI tree, then you may need clustered JNDI.
<LI>24/7 availability needs the ability to hot-deploy and undeploy new applications and new versions, and to apply patches, without bringing down the application server for maintenance.
<LI>Smart proxies can be used to implement load-balancing and fail-over for EJB remote clients. These proxies manage a list of available RMI connections one of which it will use to service an invocation.
START
http://wireless.java.sun.com/midp/ttips/memory/
MIDP memory tuning
(Page last updated June 2002, Added 2002-07-24, Author Jonathan Knudsen).
6
<LI>Use an obfuscator to minimize the size of classes.
<LI>Minimize resource sizes by using as few images as possible, and using fewer colors in the images you do use.
<LI>Use as few objects as possible. 
<LI>Dereference objects (set them to null) when they're no longer useful so they will be garbage-collected.
<LI>Catch OutOfMemoryErrors on all allocations, or at least the large ones. Don't let an OutOfMemoryError take your application by surprise.
<LI>MIDlets use three types of memory: program memory, heap, and persistent storage. Each of these may be scarce and they should all be treated with respect.
START
http://www.informit.com/content/index.asp?product_id={11E331A5-5A08-4FFD-B018-2A7E24D0359B}
Application performance tuning
(Page last updated July 2002, Added 2002-07-24, Author Baya Pavliashvili and Kevin Kline).
6
<LI>Application performance problems can be caused and mitigated with any combination of the following areas: Network topology and throughput;  Server hardware configuration; client application code; middle-tier components; database communication code; database configuration settings; logical and physical database design; operating system settings; client hardware; overall application architecture.
<LI>Monitor the application. Primary statistics worth analyzing are: the number of concurrent users; number of transactions per unit of time; duration of the longest and shortest transactions; and the average response time.
<LI>Specify the performance targets.
<LI>Consider using "eye candy" to distract attention during acceptable short waits.
<LI>Identify which application tier contains the bottleneck and fix that. It might be hardware or software; low-level or architecture.
<LI>Prioritize which problems to fix according to the resources available.
START
http://www.sys-con.com/weblogic/article.cfm?id=101
HTTP sessions vs. stateful EJB
(Page last updated July 2002, Added 2002-07-24, Author Peter Zadrozny).
2
<LI>The comparative costs of storing data in an HTTP session object are roughly the same as storing the same data in a stateful session bean.
<LI>Failure to remove an EJB that should have been removed (from the HTTP session) carries a very high performance price: the EJB will be passivated which is a very expensive operation.
START
http://www.sys-con.com/weblogic/article.cfm?id=102
Precompiling JSPs
(Page last updated July 2002, Added 2002-07-24, Author Steve Mueller, Scot Weber).
1
<LI>Precompile your JSPs one way or another to avoid the first user having a slow experience.
START
http://www7b.boulder.ibm.com/dmdd/library/techarticle/0204pooloth/0204pooloth.html
High performance inserts with DB2 and JDBC
(Page last updated April 2002, Added 2002-07-24, Author Krishnakumar Pooloth).
1
<LI>Use SQLJ to get the use of buffered inserts, and modify the code generated from SQLJ to reuse the RTStatement object.
START
http://javazoid.com/OptimizingSqlView.html
Optimizing padded string display
(Page last updated June 2002, Added 2002-07-24, Author Gervase Gallant).
1
<LI>Avoid copying individual string characters. Use the same underlying char array, by using methods like String.substring().
START
http://www.onjava.com/pub/a/onjava/2002/07/17/web.html
High load web servlets
(Page last updated July 2002, Added 2002-07-24, Author Pier Fumagalli).
7
<LI>Hand off requests for static resources directly to the web server by specifying the URL, not by redirecting from the servlet.
<LI>Use separate webservers to deliver static and dynamic content.
<LI>Cache as much as possible. Make sure you know exactly how much RAM you can spare for caches, and have the right tools for measuring memory.
<LI>Load balance the Java application using multiple JVMs.
<LI>Use ulimit to monitor the number of file descriptors available to the processes. Make sure this is high enough.
<LI>Logging is more important than the performance saved by not logging.
<LI>Monitor resources and prepare for spikes.
START
http://cin.earthweb.com/public/article/0,,10493_1145241,00.html
Website usability metrics
(Page last updated May 2002, Added 2002-07-24, Author Sharon Gaudin).
3
<LI>A website must be easy to navigate and have a quick display and response time.
<LI>Bad navigation metrics include: abandoned shopping carts; first time visitors look at one or two pages and disappear; dead ends require the "back" button; less than 5% buy something; any broken links.
<LI>Good navigation metrics include: three pages or less from wesbite entry to desired information; no streaming video or Flash introductions; multiple ways to reach the required information; up to date search engines; basic compancy and contact info one click away from the homepage.
START
http://itmanagement.earthweb.com/ecom/article/0,,11952_1370691,00.html
Common issues affecting Web performance
(Page last updated June 2002, Added 2002-07-24, Author Drew Robb).
9
<LI>Symptoms of network problems include slow response times, excessive database table scans, database deadlocks, pages not available, memory leaks and high CPU usage. 
<LI>Causes of performance problems can include the application design, incorrect database tuning, internal and external network bottlenecks, undersized or non-performing hardware or Web and application server configuration errors.
<LI>Root causes of performance problems come equally from four main areas: databases, Web servers, application servers and the network, with each area typically causing about a quarter of the problems.
<LI>The most common database problems are insufficient indexing, fragmented databases, out-of-date statistics and faulty application design. Solutions include tuning the index, compacting the database, updating the database and rewriting the application so that the database server controls the query process.
<LI>The most common network problems are undersized, misconfigured or incompatible routers, switches, firewalls and load balancers, and inadequate bandwidth somewhere along he communication route.
<LI>The most common application server problems are poor cache management, unoptimized database queries, incorrect software configuration and poor concurrent handling of client requests.
<LI>The most common web server problems are poor design algorithms, incorrect configurations, poorly written code, memory problems and overloaded CPUs.
<LI>Having a testing environment that mirrors the expected real-world environment is very important in achieving good performance.
<LI>The deployed system needs to be tested and continually monitored.
START
http://developer.java.sun.com/developer/JDCTechTips/2002/tt0709.html
LinkedHashMap and RandomAccess
(Page last updated July 2002, Added 2002-07-24, Author Glen McCluskey).
2
<LI>LinkedHashMap preserves various ordering information, optionally including access ordering which makes LinkedHashMap appropriate for a least recently used (LRU) cache.
<LI>ArrayList has fast random access of elements, LinkedList has slow random access of elements. List classes that implement the RandomAccess interface have fast random access and using get() to iterate their elements is efficient. If RandomAccess is not implemented, use an Iterator to iterate the elements.
START
http://www.sys-con.com/java/article.cfm?id=1534
Emulating another system (a ZX Spectrum)
(Page last updated July 2002, Added 2002-07-24, Author Razvan Surdulescu).
2
<LI>Painting pixel by pixel by repeatedly calling fillRect() is slow. Instead create the offscreen image as a decorator for a java.awt.image.MemoryImageSource object containing a byte array in RGB format with the pixel data. The rendering code updates the byte array and then calls MemoryImage-Source.newPixels() to notify the object that the data has been updated.
<LI>Pre-render common images or pixel combination, retain them as Image objects and use java.awt.Graphics.drawImage() (Java 1) or java.awt.image.BufferedImage.setRGB() (Java 2) to render the image to the graphics buffer.
START
http://www.sys-con.com/java/article.cfm?id=1533
The smallest "Hello World"
(Page last updated July 2002, Added 2002-07-24, Author Norman Richards).
6
<LI>[Brilliantly amusing search to make the smallest "Hello World" program.]
<LI>Use the -g:none option to strip debugging bytes from classfiles.
<LI>Most bytes in Java class files are from the constant pool, then the method declarations. The constant pool includes class and method names as well as strings.
<LI>The Java compiler will insert a default constructor if you don't specify one, but the constructor is only needed if you will create instances. You can remove the constructor if you will not be creating instances.
<LI>Most variables and class references used by the code generate entries in the constant pool.
<LI>Reusing already existing constant pool entries for class/method/variable names reduces the class file size.
START
http://java.ittoolbox.com/pub/SC071902/httprevealer_servlets_itx.htm
Speeding web page downloads using compression
(Page last updated July 2002, Added 2002-07-24, Author Steven Chau, Publication HttpRevealer.com).
2
<LI>Browsers sending "Accept-Encoding: gzip" will accept gziped compressed pages. Return the page compressed with "Content-Encoding: gzip" using GZIPOutputStream.
<LI>Use a servlet filter to transparently compress pages to browsers that accept compressed pages.
START
http://www.javaworld.com/javaworld/jw-07-2002/jw-0703-service.html
The Verified Service Locator pattern
(Page last updated July 2002, Added 2002-07-24, Author Paulo Caroli, Publication JavaWorld).
2
<LI>The Service Locator pattern improves performance by caching service objects that have a high-lookup cost.
<LI>The Service Locator pattern has a problem in that cached objects may become invalid without the service locator knowing. The Verified Service Locator pattern periodically tests the validity of the caches objects to avoid providing invalid service objects to requestors.
START
http://www.javaworld.com/javaworld/jw-12-2000/jw-1229-traps.html
Runtime.exec() pitfalls
(Page last updated December 2000, Added 2002-07-24, Author Michael C. Daconta).
2
<LI>Runtime.waitFor blocks until the spawned process terminates.
<LI>Avoid blocking the Java thread because the spawned process is waiting on I/O. Make sure you read and write the spawned process's I/O as required.
START
http://www.theserverside.com/resources/article.jsp?l=J2EEPerformance
Improving J2EE performance
(Page last updated May 2002, Added 2002-07-24, Author Scott Marlow).
16
<LI>Set performance goals before development starts.
<LI>If supporting clients with slow connections, consider compressing data for network communication.
<LI>Minimize the number of network round trips required by the application.
<LI>For applications to scale to many users, minimize the amount of shared memory that requires updating.
<LI>Cache data to minimize lookup time, though this can reduce scalability if locks are required to access the cache.
<LI>If there are more accesses than updates to a cache, share the access lock amongst all the accessors, though be aware that this reduces the window for updators to lock the cache.
<LI>For optimum performance, zero shared memory provides a cache per user.
<LI>Be methodical to ensure that changes for performance do actually improve performance.
<LI>Eliminate memory leaks before tuning execution speed.
<LI>Use a test environment that correctly simulates the expected deployment environment.
<LI>Simulate the expected client activity, and compare the performance against your expected goals.
<LI>Consider which metrics to measure, such as: Max response time under heavy load; CPU utilization under heavy load; How the application scales as additional users are added.
<LI>Profile the application to find the bottlenecks. Correct bottlenecks by making one change at a time and testing for improvement.
<LI>Generate stack traces to look for bottlenecks which are multi-thread conflicts (waiting for locks).
<LI>Improving the performance of a method that is called 1000 times and takes a tenth of a second on average each call, is better than improving the performance of a method that is only called 10 times but takes 1 second each call.
<LI>Don’t cache data unless you know how and when to invalidate the cached entries.
START
http://www.theserverside.com/resources/article.jsp?l=Building-Sclable-Recoverable-Applications
Scalable recoverable applications
(Page last updated May 2002, Added 2002-07-24, Author Billy Newport).
12
<LI>[Article describes several approaches to building a scalable recoverable system]
<LI>Split the application into a transactional part and a non-transactional part. The non-transactional part can be replicated.
<LI>Using a single machine limits both reliability and scalability. Scalability is completely dependent on how powerful the single machine can become.
<LI>Multiple front-end machines with http request load balancing is more reliable, but the database machine is still a single point of failure.
<LI>A database caching layer in the servlet helps performance. An EJB caching layer is difficult to achieve.
<LI>Oracle 9i includes queryable snapshots of the main database which can offload the query to run against the clients local snapshot.
<LI>An in-memory database (such as TimesTen) is very, very fast and can act as a queryable cache for a back end database.
<LI>Database instances on each machine, with replication increases reliability and access speed. But updates now need to be handled differently. Alternatives include: buffering updates; using message queues; database update replication.
<LI>Partitioning the database across multiple machines adds scalability, but must be done with care.
<LI>If you want very reliable systems then everything has to be controlled.
<LI>A load balancing message queue may be needed for a high rate of messages (>500/sec).
<LI>Note that reliable systems should ensure that all duplicated data have no single points of failure in the software or hardware chain behind the data (different controllers, UPSs, etc).
START
http://developer.java.sun.com/developer/community/chat/JavaLive/2002/jl0515.html
Sun Community chat on Java BluePrints
(Page last updated May 2002, Added 2002-07-24, Author Edward Ort, Publication Sun Developer).
3
<LI>For very large transactions, use transaction attribute TX_REQUIRED for EJB methods to have all the method calls in a call chain use the same transaction.
<LI>Make tightly coupled components local to each other. Put remote beans primarily as facades across subsystems.
<LI>The page-by-page pattern is designed to handle cases where the result set is large, and the end-user is not interested in seeing all of the results. There is really no upper threshold for the size of result set in the pattern.
START
http://www.informit.com/content/index.asp?product_id={B7B69E41-7E73-4BC1-A796-94D1C0855251}
Example of developing CMP 2.0 Entity Beans
(Page last updated September 2002, Added 2002-09-30, Author Pravin Tulachan, Publication InformIT).
1
<! CTGRY ><LI>CMP implementations are often written to support particular databases, allowing them to use optimal performance features for that database.
START
http://www.sdtimes.com/cols/javawatch_062.htm
JDBC drivers
(Page last updated September 2002, Added 2002-09-30, Author Steven J. Vaughan-Nichols, Publication SDTimes).
2
<! CTGRY ><LI>Use a JDBC 3.0 compliant driver
<! CTGRY ><LI>Sun's JDBC-ODBC bridge doesn't support concurrent access, but also allows deadlocks.
START
http://www-106.ibm.com/developerworks/web/library/x-hipersis2.html
Benchmarking XML parsing
(Page last updated September 2002, Added 2002-09-30, Author Cameron Laird, Publication IBM).
5
<! CTGRY ><LI>The performance of two functionally identical programs can often vary by orders of magnitude.
<! CTGRY ><LI>It's often less costly to tune a technology that an organization can accept, rather than impose an unfamiliar technology, even if the latter option provides more speed.
<! CTGRY ><LI>Managing DOM instances in memory taxes memory allocation schemes, so the overall speed of an XML parser is often quite sensitive to the memory allocation patterns of the parser.
<! CTGRY ><LI>Java-coded DOM parsers are particularly expensive in memory costs, with a total run-time footprint of up to five times the size of an XML document instance. SAX parsers are more efficient.
<! CTGRY ><LI>Special purpose parsers are often faster (the article mentions some).
START
http://www-106.ibm.com/developerworks/java/library/us-j2d/
Changing icon look with composition
(Page last updated September 2002, Added 2002-09-30, Authors Joe Winchester, Renee Schwartz, Publication IBM).
1
<! CTGRY ><LI>Icons (and other graphics) which are changed in color or shading can use two sets of graphics, but can also use composition for example with XORing or pixel manipulation, as described in the article.
START
http://softwaredev.earthweb.com/java/article/0,,12082_1464821,00.html
Processing Stack Trace Data
(Page last updated September 2002, Added 2002-09-30, Author Richard G. Baldwin, Publication Earthweb).
1
<! CTGRY ><LI>From 1.4, Throwable.getStackTrace() and StackTraceElement objects are available to examine indiviual elements of the runtime stack.
START
http://developer.java.sun.com/developer/JDCTechTips/2002/tt0910.html
ArrayList/LinkedList/HashMap performance
(Page last updated September 2002, Added 2002-09-30, Author Glen McCluskey, Publication Sun).
7
<! CTGRY ><LI>ArrayList is faster than LinkedList for random access and for algorithms that follow a random access pattern, such as binary searching.
<! CTGRY ><LI>LinkedList is faster than ArrayList for repeated insertions to the front of the list.
<! CTGRY ><LI>HashMap lookup is faster than binary search on an ArrayList.
<! CTGRY ><LI>Appending elements to the end of a list has a fixed averaged cost for both ArrayList and LinkedList. For ArrayList, appending typically involves setting an internal array location to the element reference, but occasionally results in the array being reallocated. For LinkedList, the cost is uniform and involves allocating an internal Entry object.
<! CTGRY ><LI>Inserting or deleting elements in the middle of an ArrayList implies that the rest of the list must be moved. Inserting or deleting elements in the middle of a LinkedList has fixed cost.
<! CTGRY ><LI>A LinkedList does not support efficient random access.
<! CTGRY ><LI>An ArrayList has space overhead in the form of reserve capacity at the end of the list. A LinkedList has significant space overhead per element.
START
http://java.sun.com/features/2002/08/j2se-network.html
New 1.4 network features
(Page last updated September 2002, Added 2002-09-30, Author Qusay H. Mahmoud, Publication Sun).
2
<! CTGRY ><LI>1.4 now directly supports setting timeouts for socket connections with a parameter to the connect() method. This differs from the SO_TIMEOUT connection configuration parameter, which only affects subsequent reads on the established connection.
<! CTGRY ><LI>1.4 improved connected handling of datagram sockets so that the OS level can test address access, which is faster than previously.
START
http://softwaredev.earthweb.com/java/article/0,,12082_1468351,00.html
Creating a JDBC Log Handler
(Page last updated September 2002, Added 2002-09-30, Author Jeff Heaton, Publication Earthweb).
1
<! CTGRY ><LI>Logging data to a database can be useful. Article describes how to create a log handler for the logging API which logs to a database.
START
http://www-106.ibm.com/developerworks/java/library/j-jtp0924.html
Managing thread death
(Page last updated September 2002, Added 2002-09-30, Author Brian Goetz, Publication IBM).
1
<! CTGRY ><LI>Use the ThreadGroup uncaughtException handler to handle restarting or logging threads dieing unexpectedly.
START
http://www-106.ibm.com/developerworks/java/library/j-ebb0917a.html
equals() versus ==
(Page last updated September 2002, Added 2002-09-30, Author Sreekanth Iyer, Publication IBM).
1
<! CTGRY ><LI>intern() is expensive and slow, but can be used to internalize strings which can reduce duplicate strings and allows comparsion by the faster identity (==) operator rather than the equality method.
START
http://www-106.ibm.com/developerworks/java/library/j-ejb0924.html
Industrial-strength JNDI optimization
(Page last updated September 2002, Added 2002-09-30, Author Brett McLaughlin, Publication IBM).
3
<! CTGRY ><LI>Cache the context objects.
<! CTGRY ><LI>EJB applications can spend a significant proportion of time on remote EJB home lookups. Cache the home objects.
<! CTGRY ><LI>Use an EJBHomeFactory (pattern) to manage lookups and cached home objects.
START
http://java.sun.com/j2se/1.4.1/changes.html
1.4.1 Changes
(Page last updated September 2002, Added 2002-09-30, Author Sun, Publication Sun).
2
<! CTGRY ><LI>-XX:+UseConcMarkSweepGC - This flag turns on concurrent garbage collection. This collector executes mostly concurrently with the application. It trades the utilization of processing power that would otherwise be available to the application for shorter garbage collection pause times.
<! CTGRY ><LI>-XX:+UseParallelGC - This flag enables garbage collection to occur on multiple threads for better performance on multiprocessor machines.
START
http://www.onjava.com/pub/a/onjava/2002/09/04/nio.html
Non-blocking sockets
(Page last updated September 2002, Added 2002-09-30, Author Giuseppe Naccarato, Publication OnJava).
1
<! CTGRY ><LI>Use non-blocking sockets to optimize asynchronous high-performance read/write operations.
START
http://www.devx.com/free/tips/tipview.asp?content_id=3662
Yet another "use StringBuffer not String concatenation" tip
(Page last updated September 2002, Added 2002-09-30, Author Ramneek Handa, Publication DevX).
1
<! CTGRY ><LI>Use StringBuffer not String concatenation.
START
http://builder.com.com/article.jhtml?id=u00220020917R4B01.htm
Buffered Iterator
(Page last updated September 2002, Added 2002-09-30, Author Ryan Brase, Publication Builder.com).
1
<! CTGRY ><LI>Use a buffered iterator to access elements of a collection while that collection is being built [article discusses building such a buffered iterator].
START
http://www.devx.com/dbzone/articles/dd_top7/top7.asp
Choosing a JDBC driver
(Page last updated August 2002, Added 2002-09-30, Author DataDirect, Publication DevX).
3
<! CTGRY ><LI>Make sure the driver closes associated resources, like closing ResultSets when the generating Statement has been closed.
<! CTGRY ><LI>Make sure the driver supports the load you expect to put on it.
<! CTGRY ><LI>Does the driver have a tracing mode or utility.
START
http://www.devx.com/java/free/articles/brunner01/rb080502-1.asp
JDBC tuning
(Page last updated September 2002, Added 2002-09-30, Author Robert Brunner, Publication DevX).
4
<! CTGRY ><LI>Using autocommit mode every SQL statement is in its own transaction, which is bad for performance.
<! CTGRY ><LI>Batch processing and updateable ResultSets can improve performance.
<! CTGRY ><LI>Type 4 JDBC drivers generally offer the highest performance.
<! CTGRY ><LI>A "spy" utility helps to trace JDBC communications.
START
http://www.devx.com/dbzone/articles/dd_jdbc/sosinsky-1.asp
Choosing a JDBC driver
(Page last updated August 2002, Added 2002-09-30, Author Barrie Sosinsky, Publication DevX).
5
<! CTGRY ><LI>You can optimize data access performance through batching.
<! CTGRY ><LI>Type 3 and Type 4 JDBC drivers are both pure Java drivers, and therefore, offer the best performance (Driver types: 1, JDBC-ODBC bridge, plus an ODBC driver; 2, native API, part-Java driver; 3, pure Java driver for database middleware; 4, pure Java driver for direct-to-database).
<! CTGRY ><LI>Connection pooling is an important performance feature.
<! CTGRY ><LI>A disconnected RowSet can be used to cache rows.
<! CTGRY ><LI>PreparedStatement pooling is good for performance, especially when it works with connection pooling.
START
http://www.sys-con.com/webservices/article.cfm?id=356
Monitoring web services
(Page last updated September 2002, Added 2002-09-30, Authors Gunjan Samtani & Dimple Sadhwani, Publication Web Services Journal).
7
<! CTGRY ><LI>Types of web service performance monitoring: Availability test (Checks whether a Web service is present and ready for immediate use); Performance test (Measures the throughput i.e. requests/second, and latency i.e. response time; Stress test (Determines the maximum load the web service can manage).
<! CTGRY ><LI>Web services invocation operations are expensive. Use corase-grained services i.e., where a lot of work is to be done and a lot of information has to be returned.
<! CTGRY ><LI>Asynchronous messaging can improve throughput at the cost of latency.
<! CTGRY ><LI>Cache wherever possible.
<! CTGRY ><LI>Avoid real-time data aggregation from other web services.
<! CTGRY ><LI>Use a stripped down XML parser that only performs essential parsing.
<! CTGRY ><LI>Avoid chaining Web services.
START
http://www.sys-con.com/java/article.cfm?id=1600
EJB primary keys
(Page last updated August 2002, Added 2002-09-30, Author Saad Rehmani, Publication Java Developers Journal).
1
<! CTGRY ><LI>Integer keys have better performance than String keys. Author recommends using an container-generated unique integer key.
START
http://www.adtmag.com/article.asp?id=6674
EJBs or plain Servlets?
(Page last updated September 2002, Added 2002-09-30, Author Michael Bardash, Gerhard Bayer, Max Dolgicer, Publication ATDmag).
3
<! CTGRY ><LI>If an application is presentation-centric and does not require support for high-end middleware services such as distributed transactions, persistence, application-level load balancing, state management and asynchronous messaging, then plain servlets are sufficient. If an application requires at least a partial list of such high-end middleware services, then EJBs are required.
<! CTGRY ><LI>Server clustering, DB connection pooling and location transparency facilitate scalability.
<! CTGRY ><LI>Servlet scalability is not stipulated by the servlet API, but is based mostly on proprietary, vendor-created implementations of servlet pools and load-balancing mechanisms. EJB architecture was designed for scalability. Put another way, servlets can scale at the server level, EJBs can scale at the architecture level. 
START
http://softwaredev.earthweb.com/java/article/0,,12082_1453021,00.html
Stylesheet execution optimization TRaX
(Page last updated September 2002, Added 2002-09-30, Author Jeff Ryan, Publication Earthweb).
1
<! CTGRY ><LI>TRaX can compile stylesheets and hold them in memory, dramatically improving performance.
START
http://www.fawcette.com/javapro/2002_10/magazine/columns/weblication/
Profiling and performance analysis
(Page last updated October 2002, Added 2002-09-30, Author Peter Varhol, Publication Java Pro).
1
<! CTGRY ><LI>[Article discusses profiling as timing methods, performance analysis as more in-depth, and the difference between sampling and full execution logging for profilers].
START
http://www-106.ibm.com/developerworks/java/library/j-io2/
Opimizing I/O
(Page last updated September 2002, Added 2002-09-30, Author Merlin Hughes, Publication IBM).
7
<! CTGRY ><LI>ByteArrayOutputStream.toByteArray() returns a copy of the underlying array, which can be an inefficient use of memory.
<! CTGRY ><LI>StringBuffer controls write access to its internal array. It can can export the array to a String and copies the array only when necessary; that is, when it has exported a String and a caller subsequently modifies the StringBuffer. If no such modification occurs, then no unnecessary copying will be performed.
<! CTGRY ><LI>[Article discusses a variant of the ByteArrayOutputStream class which can export access to the internal byte array with a read-only InputStream].
<! CTGRY ><LI>The internal 1024-byte buffer of piped streams is inflexible for different usage scenarios; it is just too small for large volumes of data.
<! CTGRY ><LI>Array-based operations of piped streams simply call through to an inefficient byte-by-byte copy operation. This operation is itself synchronized, resulting in extremely heavy lock contention.
<! CTGRY ><LI>If a piped stream becomes empty or full and a thread is blocked on this state changing, the thread is awakened even if just a single byte is read or written. In many cases, it will use this single byte and immediately block again, resulting in little useful work being done.
<! CTGRY ><LI>[Article discusses improved piped streams which avoid some performance problems of SDK piped streams].
START
http://www-3.ibm.com/software/webservers/appserv/doc/v40/ws_40_tuning.pdf
WebSphere performance tuning
(Page last updated August 2002, Added 2002-10-30, Author Gennaro (Jerry) Cuomo Srini Rangaswamy, Publisher IBM).
15
<! CTGRY ><LI>There is no magic configuration in which the systm will provide best performance. It has to be configured and tuned by considering the components involved in an application, incoming traffic (load) and required throughput.
<! CTGRY ><LI>Understanding object usage and tuning the JVM heap size is an important element of overall performance.
<! CTGRY algorithms app_server analysis_and_design a_d:mmry a_d:ldbalnc distributed ><LI>A size restricted queue (closed queue) allows system resources to be more tightly managed than an open queue.
<! CTGRY algorithms app_server analysis_and_design a_d:ldbalnc distributed ><LI>The network provides a front-end queue. A server should be configured to use the network queue as its bottleneck, i.e. only accept a request from the network when there are sufficient resources to process the request. This reduces the load on an app server. However, sufficient requests should be accepted to ensure that the app server is working at maximum capacity, i.e. try not to let a component sit idle while there are still requests that can be accepted even if other components are fully worked.
<! CTGRY app_server analysis_and_design a_d:ldbalnc distributed ><LI>Try to balance the workload of the various components.
<! CTGRY profiling app_server ><LI>Throughput has three zones: light load (spare capacity is available, the system can accept further users with no response-time degradation); heavy load (no spare capacity, system working at maximum potential, throughput is constant and extra users can only be served by degrading response times of all users); buckle zone (a bottleneck appears which causes the system to run below maximum potential, both througput and response times decrease). [Paper shows a nice throughput curve giving recommended scaling behavior for an server]. The point where light load becomes heavy load is the saturatiuon point, and you should aim to tune the application until this corresponds to the target user concurrency level.
<! CTGRY profiling app_server ><LI>The desirable target bottleneck is the CPU, i.e. a server should be tuned until the CPU is the remaining bottleneck. Adding CPUs is a simple remedy to this.
<! CTGRY app_server jdbc java.sql caching java.sql.PreparedStatement jdbc:conn_pool jdbc:prepared ><LI>Use connection pools and cached prepared statements for database access.
<! CTGRY ><LI>Ensure that the application is not leaking or over-utilizing objects; and that your Java heap parameters are set to handle your object utilization.
<! CTGRY profiling app_server ><LI>Object memory management is particularly important for server applications. Typically garbage collection could take between 5% and 20% of the server execution time. Garbage collection statistics provide a useful monitor to determine the server's "health". Use the verbosegc flag to collect basic GC statistics.
<! CTGRY profiling app_server ><LI>GC statistics to monitor are: total time spent in GC (target less than 15% of execution time); average time per GC; average memory collected per GC; average objects collected per GC.
<! CTGRY app_server ><LI>For long lived server processes it is particularly important to eliminate memory leaks (references retained to objects and never released).
<! CTGRY app_server ><LI>Use -ms and -mx to tune the JVM heap. Bigger means more space but GC takes longer. Use the GC statistics to determine the optimal setting, i.e the setting which provides the minimum average overhead from GC. After 1.2, set the -mx and -ms to be different to give the garbage collector a chance to adapt to the application working set size.
<! CTGRY app_server analysis_and_design a_d:class ><LI>The ability to reload classes is typically achieved by testing a filesystem timestamp. This check should be done at set intermediate periods, and not on every request as the filesystem check is an expensive operation.
<! CTGRY ><LI>Use the most efficient transaction isolation level
START
http://www7b.boulder.ibm.com/wsdd/library/techarticles/0209_draeger/draeger.html
WebSphere HTTP session best practices
(Page last updated August 2002, Added 2002-10-30, Author David Draeger, Publisher IBM).
9
<! CTGRY ><LI>Using one database row for a session is more efficient than using multiple rows.
<! CTGRY ><LI>Using in-memory writable caches with periodic data writes of changes to the database is recommended for maximum efficiency.
<! CTGRY ><LI>Don't store large Object graphs in HttpSession. Keep the amount of data stored in the session as small as possible.
<! CTGRY ><LI>Release HttpSessions when finished.
<! CTGRY ><LI>Create a session before accessing multi-framed pages that utilize JSPs.
<! CTGRY ><LI>Use &lt;% @ page session="false" %> to turn off the automatic session creation from the JSPs that won't update the session. Use &lt;%HttpSession session = javax.servlet.http.HttpServletRequest.getSession(false);%> to get the already existing session.
<! CTGRY ><LI>Update session data using only one frame.
<! CTGRY ><LI>Do not use multi-framed JSPs where the frames point to different Web applications.
<! CTGRY ><LI>Use a dedicated database for the session database to avoid contention for JDBC connections and get better database performance.
START
http://www.martinfowler.com/articles/yetOptimization.pdf
Optimization
(Page last updated September 2002, Added 2002-10-30, Author Martin Fowler, Publisher martinfowler.com).
10
<! CTGRY ><LI>It is difficult to make decisions about performance from just looking at the design. You have to actually run the code and measure performance using a profiler.
<! CTGRY ><LI>Use automated test suites which simulate actual conditions.
<! CTGRY ><LI>Multiuser systems have very different bottlenecks from single user systems, often focused around transaction interactions.
<! CTGRY ><LI>Once you’ve found your bottlenecks, you have two choices: speed up the slow things or do the slow things less often.
<! CTGRY ><LI>It’s much easier to optimize cohesive, loosely coupled modules.
<! CTGRY ><LI>If you make an optimization and don’t measure to confirm the performance increase, all you know for certain is that you’ve made your code harder to read.
<! CTGRY ><LI>After upgrading your compiler or VM, the optimization you did six months ago could be your bottleneck today.
<! CTGRY ><LI>Most performance issues are resolved by profiling and optimizing code. But the effects of architectural issues need to be measured early on.
<! CTGRY ><LI>Remote calls are orders of magnitude slower than in-process calls, so it’s important to minimize them.
<! CTGRY ><LI>Performance is not an absolute. Getting a program to run faster costs money, and it’s a business decision whether to invest in a quicker program.
START
http://www.messageq.com/systems_management/freshwater_1a.html
Web server monitoring
(Page last updated September 2002, Added 2002-10-30, Author Freshwater.com, Publisher Freshwater.com).
3
<! CTGRY ><LI>A Web site that fails to deliver its content in a timely manner will cause visitors to quickly lose interest.
<! CTGRY ><LI>Monitors check components on a periodic basis, frequently enough to catch failures in a timely manner, but not so frequently as to significantly impact system resources such as CPU or network bandwidth.
<! CTGRY ><LI>Common monitors include: Ping Monitor (Tests whether a machine is reachable over the network); Process Monitor (Ensures that a process is still active); Disk Space Monitor (Measures the percentage of disk used to prevent full disks); CPU Monitor (Measures the utilization of the CPU to flag chronic overloading).
START
http://community.borland.com/article/images/28892/cpu_performance_essentials.pdf
Performance tuning with OptimizeIt
(Page last updated March 2002, Added 2002-10-30, Author Jay Campan & Eric Muller, Publisher Borland).
8
<! CTGRY ><LI>Regular checking and testing of small modules of code from the earliest stage of code creation throughout the development process, into QA testing, and beyond. by the principal author is a proven way to assure that the Java applications produced will be fast, reliable, and scalable.
<! CTGRY ><LI>Three crucial performance issues for Java programs are: Java memory leaks, speed bottlenecks due to poor CPU utilization, and excessive use of temporary objects.
<! CTGRY ><LI>Sampling (taking periodic snapshots of the runtime stack) is appropriate for profiling long running sessions; Instrumentation (instrumenting the code to identify the time cost for each method) is appropriate for profiling short sessions.
<! CTGRY ><LI>[Paper works through an example of tuning a servlet using OptimizeIt].
<! CTGRY ><LI>Cache objects rather than re-generating them if they will be reused.
<! CTGRY ><LI>Use conditional tests to avoid executing statements that are unnecessary.
<! CTGRY ><LI>equalsIgnoreCase() is more efficient than the combination of toLowerCase() and equals().
<! CTGRY ><LI>If repeatedly accessing an XML file, SAX must parse the file each time, but DOM can create an in-memoy representation which is more efficient for repeated access.
START
http://www-106.ibm.com/developerworks/library/j-threads3.html
ThreadLocal
(Page last updated October 2001, Added 2002-10-30, Author Brian Goetz, Publisher IBM).
2
<! CTGRY ><LI>ThreadLocals provide you an alternative to resource pooling which avoids synchronized access of the resource, so improving scalability.
<! CTGRY ><LI>ThreadLocal performance has dramatically improved over versions: the 1.2 implementation is synchronized and so didn't scale; the 1.3 implementation is faster than 1.2 but uses Thread.currentThread() which slows it; 1.4 is finally fast enough to make using ThreadLocals efficient for resource management.
START
http://www.sys-con.com/weblogic/article.cfm?id=163
Session persistence performance
(Page last updated October 2002, Added 2002-10-30, Author Saurabh Dixit & Srikant Subramaniam, Publisher WeblogicDevelopersJournal).
4
<! CTGRY ><LI>Memory based session mechanisms are the fastest if seralization of the session data can be avoided.
<! CTGRY ><LI>Cookie based session mechanisms are efficient when you don't need to store large amounts of data in the session.
<! CTGRY ><LI>Database based session mechanisms are slow but fault tolerant.
<! CTGRY ><LI>File persistence is the slowest mechanism for managing sessions.
START
http://developer.java.sun.com/developer/community/chat/JavaLive/2002/jl0919.html
Sun community chat on NIO
(Page last updated September 2002, Added 2002-10-30, Author Edward Ort, Publisher Sun).
7
<! CTGRY ><LI>The main advantage of socket channels is that you can do non-blocking [multiplexed] I/O.
<! CTGRY ><LI>Socket channels can transfer data more efficiently if you use direct buffers for reads and writes.
<! CTGRY ><LI>Memory-mapped buffers are only reclaimed when they're GC'ed. You may need to explicitly call System.gc() to reclaim space from memory mapped files that you have finished with.
<! CTGRY ><LI>The "optimal" size for writing to a socket channel depends entirely upon the size of the channel's send buffer. The default size varies from OS to OS; you can use the {get,set} SendBufferSize methods in java.net.Socket to view and change the buffer size.
<! CTGRY ><LI>Mark Reinhold's general rule for direct buffers is that you shouldn't use them at all unless you can demonstrate a clear performance improvement.
<! CTGRY ><LI>NIO improves graphical application performance by memory mapping the video card memory into the Java application, allowing very fast updates to the screen bits.
<! CTGRY ><LI>Memory mapping files under 10K is not recommended. Memory mapping really big files may stress the virtual memory system of the operating system. In such cases consider memory mapping only sections of the file if possible.
START
http://softwaredev.earthweb.com/java/article/0,,12082_1473151,00.html
FileChannel objects background information
(Page last updated September 2002, Added 2002-10-30, Author Richard Baldwin, Publisher Earthweb).
2
<! CTGRY ><LI>The FileChannel.map() maps region of a file directly into memory.  For large files this is often much more efficient than invoking the usual read or write methods."
<! CTGRY ><LI>The FileChannel.transferFrom() and FileChannel.transferTo methods can transfer data file to some other channel, and vice versa in a way that can be optimized by many operating systems into a very fast transfer directly to or from the filesystem cache.
START
http://www.sys-con.com/java/article.cfm?id=1662
Clustering J2EE
(Page last updated October 2002, Added 2002-10-30, Authors Ashok Banerjee, Ganesh Kondal & Sunil Kunisetty, Publisher JavaDevelopersJournal).
6
<! CTGRY ><LI>Clustering can be achieved separately for each tier: web cache, web server, application server, database server.
<! CTGRY ><LI>Efficient clustering needs load balancing (distributing requests to balance the load across the cluster).
<! CTGRY ><LI>Load Balancing Strategies include: Random; Round-robin; Weighted; Equal request (equal weighting); Equal client (requests dispatched based on the client); Equal workload (theoretically ideal but often difficult or too expensive to achieve).
<! CTGRY ><LI>Stateless sessions are considerably more efficient to replicate over a cluster.
<! CTGRY ><LI>Clustering without replication is more efficient but less fault tolerant.
<! CTGRY ><LI>Speeding serialization usually helps performance. Using readObject/writeObject [or Externalization] can significantly improve serialization performance.
START
http://www.devx.com/java/free/articles/kabutz08/Kabutz08-1.asp
JDBC drivers
(Page last updated September 2002, Added 2002-10-30, Author Heinz Kabutz, Publisher DevX).
3
<! CTGRY ><LI>If your application uses the database continuously, you need to have as little overhead in your driver as possible.
<! CTGRY ><LI>If database access is not a bottleneck, the driver performance is not so important. It may be more important that it does not leak memory.
<! CTGRY ><LI>When inserting large amounts of data using setBytes(), type 4 drivers can be significantly slower than type 1 drivers for some databases.
START
http://www.sys-con.com/java/article.cfm?id=1663
Scaling J2EE
(Page last updated October 2002, Added 2002-10-30, Author Mikhail Skorik, Publisher JavaDevelopersJournal).
3
<! CTGRY ><LI>Scale horizontally by using multiple external (load balanced) servlet containers to dedicate application server resources to EJB processing. This architecture enables separate scaling of the presentation layer and the business logic layer.
<! CTGRY ><LI>Use cached Value Objects in servlet containers to reduce the number of requests made to the application server.
<! CTGRY ><LI>Use JMS to notify Value Object caches of any changes which invalidate a cached Value Object to get near real-time update of the cached Value Objects.
START
http://developer.java.sun.com/developer/JDCTechTips/2002/tt0924.html
File Locking
(Page last updated September 2002, Added 2002-10-30, Author John Zukowski, Publisher Sun).
1
<! CTGRY ><LI>Exclusive locking will serialize all access to a file, instead of permitting simultaneous reads or access to different sections of a file. (Note that if shared locking is not available on a platform then exclusive locking is automatically used.)
START
http://www.onjava.com/pub/a/onjava/2002/10/02/javanio.html
NIO
(Page last updated October 2002, Added 2002-10-30, Author Ron Hitchens, Publisher OnJava).
7
<! CTGRY ><LI>Direct buffers can be used from both sides of the JNI, allowing efficiencies such as direct memory manipulation without having to pass data through the JNI.
<! CTGRY ><LI>Memory mapped files use less system memory since the file data is held in page space only, rather than page space and JVM heap space.
<! CTGRY ><LI>Multiple memory mappings of any single file only requires one real memory mapping into the page file.
<! CTGRY ><LI>Scatter/gather operations allows multiple (old) I/O operations to be performed in fewer NIO operations.
<! CTGRY ><LI>FileChannel.transferTo() and FileChannel.transferFrom() allows data to be transferred between two file channels in the most efficient way.
<! CTGRY ><LI>Non-blocking sockets allows threads to efficiently check for I/O without blocking.
<! CTGRY ><LI>Multiplexing I/O avoids polling overheads and enables I/O on multiple channels using the minimum of resources.
START
http://www2.theserverside.com/resources/article.jsp?l=MonsonHaefel-Column4
The Timer service
(Page last updated October 2002, Added 2002-10-30, Author Richard Monson-Haefel, Publisher TheServerSide).
2
<! CTGRY ><LI>[Article describes the EJB Timer Service which allows tasks to be scheduled, and suggests improvements based on cron].
<! CTGRY ><LI>[Note an alternative implementation of the the timer service for earlier EJBs discussed in <A HREF="http://www.sys-con.com/websphere/article.cfm?id=150">http://www.sys-con.com/websphere/article.cfm?id=150</A>].
START
http://otn.oracle.com/oramag/oracle/02-sep/o52jdbc.html
JDBC tips
(Page last updated September 2002, Added 2002-10-30, Author William Crawford, Publisher Oracle).
6
<! CTGRY ><LI>Pool your connections.
<! CTGRY ><LI>Use PreparedStatements and close them when finished.
<! CTGRY ><LI>Use transactions optimally: no auto-commit mode; the lowest transaction isolation level consistent with the application; minimize transactions and don't let the user control when they finish.
<! CTGRY ><LI>Use database-side processing where this improves performance, such as reducing the number of SQL statements needing to be executed by using more complex SQL or stored procedures.
<! CTGRY ><LI>Use the fastest driver.
<! CTGRY ><LI>Optimize the network configurations of your machines and the network connections between your database server and Web/Application server.
START
http://portals.devx.com/Brew/Article/8124
Smooth animation/sprite engine requirements
(Page last updated September 2002, Added 2002-10-30, Author Chris Preimesberger, Publisher DevX).
1
<! CTGRY ><LI>Use transparent pixels to smooth sprite images.
START
http://www-106.ibm.com/developerworks/java/library/j-ebb0917b.html
Swing multi-threading
(Page last updated September 2002, Added 2002-10-30, Author Guruprasad H.N., Publisher IBM).
1
<! CTGRY ><LI>Use invokeLater() and invokeAndWait() with Swing to avoid threading problems.
START
http://java.ittoolbox.com/documents/document.asp?i=2028
Row level locking
(Page last updated September 2002, Added 2002-10-30, Author Nicholas Whitehead, Publisher ITtoolbox).
1
<! CTGRY ><LI>Use "SELECT <select statement> FOR UPDATE [nowait]", eg. "select empno from EMP for update nowait" to lock a row. The nowait makes your statement fail immediately if another user is  holding the lock. Otherwise, it will simply wait for the current user to  complete or cancel the transaction.
START
http://www.informit.com/content/index.asp?product_id={98614A3F-B3EA-4167-BA4E-3C774E48CFE1}
Chapter 3, "Popular Unix Performance-Monitoring Tools for Linux" from "Linux Performance Tuning and Capacity Planning"
(Page last updated October 2002, Added 2002-10-30, Author Jason Fink, Publisher InformIT).
1
<! CTGRY ><LI>[Nice introductory coverage of Unix OS level free performance monitoring tools.]
START
http://www7b.boulder.ibm.com/wsdd/techjournal/0211_polozoff/polozoff.html
WebSphere performance testing
(Page last updated November 2002, Added 2002-11-27, Author Alexandre Polozoff, Publisher IBM).
30
<! CTGRY ><LI>Performance testing is the only way to determine the optimal settings (for JVM, connection pooling, etc.)
<! CTGRY ><LI>The test environment should come as close to the production environment as possible. At the very least, the two environments should have the same machine and OS level configurations.
<! CTGRY ><LI>Common test environment mistakes include putting one or the other application server on a different OS patch or fixpack level, or on different memory configurations, resulting in inconsistent results and/or behavior. Doublecheck that the TCP/IP stack settings are identical to each other as well, particularly the duplex settings on the NIC cards.
<! CTGRY ><LI>If HTTP Session persistence is enabled, make sure that the Sessions table is isolated from other databases and marked as VOLATILE.
<! CTGRY ><LI>Testing should be done in isolation from other activity, to minimize unexpected competition for resources from non-application sources.
<! CTGRY ><LI>Problems of shared test environments include: someone else using a large portion of network capacity, e.g. from a network backup; and other applications utilizing or changing backend resources.
<! CTGRY ><LI>When the application is running at full capacity, introducing too many requests actually decreases performance and throughput so at that point requests should be queued at the front entry point (called gating).
<! CTGRY ><LI>Tune the maximum number of servlet engine threads by analyzing performance test results. There is no valid "general" value to set this to (the WebSphere default of 25 is normally too low for high volume applications).
<! CTGRY ><LI>Tune the maximum Connection Pool Size by monitoring the size and adjusting it in different tests. The generally accepted maximum value for data source connections, even in high volume installations, is 40, with the typical application somewhere between 10 and 20.
<! CTGRY ><LI>Correlate expected test results. If there are maximum 75 servlet engine threadsand the servlet response time is sub-second, then you would expect to see at least 75 requests per second. You would also not expect to see 8-second response times on the client side.   into account the number of HTTP connections for static data at the same time. Make sure that the test results match what you are
<! CTGRY ><LI>Make sure that the load test <em>client</em> is not running hot (100% CPU), low on memory or that some network bottleneck has been encountered.
<! CTGRY ><LI>The load test client must be capable of generating the appropriate type of request needed for loading the application in question.
<! CTGRY ><LI>Always start performance testing by recording a base line set of results.
<! CTGRY ><LI>Ensure you are monitoring the application during load testing. Compare measurements with previous one.
<! CTGRY ><LI>Monitor as many resources as possible, including CPU, ports in established state, bandwidth. Some key JVM parameters to monitor are: the number of active servlet engine threads; the number of active ORB threads for applications with EJBs; the amount of free and used memory, and the number and duration of garbage collection cycles; the servlet response times.
<! CTGRY ><LI>Resolve incorrect configurations first (e.g. mis-configured firewalls, reverse proxies, throughput set to half duplex instead of full duplex, routing taking different hops to/from the same set of devices, firewall set up for proxy instead of passthrough).
<! CTGRY ><LI>Specify performance expectations: servlet response time; client response time; requests per second throughput; etc.
<! CTGRY ><LI>Plan to fix problems. Note that the two generic solutions have costs: throwing more hardware at the problem can be expensive; fixing the application bottlenecks can take a long time.
<! CTGRY ><LI>The performance test phase of the development lifecycle can easily take several months to complete, even if the application has few problem issues. Testing early and often within the performance test environment is strongly recommended.
<! CTGRY ><LI>Waiting until the very end of the development lifecycle to begin load testing is probably the worst performance testing scenario.
<! CTGRY ><LI>[Article describes some testing procedures for various generic server configurations]
<! CTGRY ><LI>Adjust the JVM heap size settings in reasonable increments to determine the optimal memory settings for the application. Make sure that the JVM heap size settings are within the physical memory limits of the machine, including all other process memory requirements.
<! CTGRY ><LI>For each set of JVM heap size settings, run one test with garbage collection turned on, and another with it turned off. 
<! CTGRY ><LI>Monitor the garbage collection cycles by watching how the free and used memory is utilized by the JVM.
<! CTGRY ><LI>Test the application with a variety of minimum and maximum servlet thread pool sizes to determine which settings move as much work as possible through the application.
<! CTGRY ><LI>Once the CPU utilization of the application approaches 80% you will be hitting against the limits of the CPU.
<! CTGRY ><LI>Once CPU utilization has reached saturation, increased load only increases response time.
<! CTGRY ><LI>Tune the size of the ORB thread pool by monitoring the thread pool and EJB activity/response times.
<! CTGRY ><LI>The client simulation should accurately reflect expected user group usage patterns.
<! CTGRY ><LI>An application suffering from bottlenecks or excessive synchronization typically exhibits poor response times and low CPU utilization.
START
http://www.forum.nokia.com/main/1,35452,1_0_10_10,00.html
Efficient MIDP Programming
(Page last updated June 2002, Added 2002-11-27, Author Forum Nokia, Publisher Nokia).
32
<! CTGRY ><LI>Don't try to make all of your code efficient, find the bottlenecks and focus on making them more efficient.
<! CTGRY ><LI>Careful design and algorithm choice yield greater benefits than line-by-line code optimizations.
<! CTGRY ><LI>Get to know the performance of the libraries (especially graphics libraries), and choose carefully how you call them.
<! CTGRY ><LI>Different phones’ MIDP implementations vary significantly in their performance characteristics, sometimes even between versions of the same model.
<! CTGRY ><LI>The best-performing approach on one phone may not be the best on another.
<! CTGRY ><LI>Profiling a MIDlet running in an emulator may not tell you much, as emulators can have very different bottlenecks from actual phones.
<! CTGRY ><LI>You normally can't run a profiler on a MIDlet running in a phone. Explicitly determine timings by adding calls to System.currentTimeMillis(). Make sure to check the resolution of the phone's system clock, and adjust the test to be sufficiently longer than the minimum clock resolution.
<! CTGRY ><LI>Call System.gc() before starting a test.
<! CTGRY ><LI>If only a small part of the screen needs to change, you should request a repaint using the method Canvas.repaint(int x, int y, int width, int height)
<! CTGRY ><LI>If you issue repaint requests faster than the device can process them, it may merge several requests into one by calling the paint method with a clip rectangle covering all their rectangles; if the rectangles are widely spaced this will include much area that doesn’t need repainting.
<! CTGRY ><LI>Use an off-screen image if your screen changes only slightly between repaints, then copy the area specified by the Graphics parameter's clip rectangle.
<! CTGRY ><LI>Avoid creating unnecessary garbage objects on the heap. Often it is easy to reuse existing objects instead.
<! CTGRY ><LI>A MIDP virtual machine can comfortably garbage-collect thousands of objects per second.
<! CTGRY ><LI>Java threading is not guaranteed to be pre-emptive, but may be cooperative. Your code should not wait for a condition in a tight loop, but should call yield or wait every time around the loop.
<! CTGRY ><LI>Both bandwidth and latency have average values and variations. Even if the average value is acceptable, if the variation is large, the user will frequently experience unacceptable values.
<! CTGRY ><LI>For large amounts of data, bandwidth usually has the most effect on networking speed. For small amounts of data, it is often latency that is more important.
<! CTGRY ><LI>For current phones long latency rules out the possibility of highly interactive real-time multi-player arcade games, as you can't see and respond to other players' actions in real time.
<! CTGRY ><LI>Use threading to execute network communications in the background without blocking the interface, wherever appropriate.
<! CTGRY ><LI>Minimize network round trips by trying to get everything required in one remote request, possibly using a proxy servlet.
<! CTGRY ><LI>SOAP can be very inefficient. Design XML-based protocol to be as simple as possible. A custom protocl is likely to be more even more efficient.
<! CTGRY ><LI>Keep the JAR file size as small as possible: have as few classes as possible; avoid interfaces; use the unnamed package; use a pre-processor instead of static final constants; limit the use of static initializers; use an obfuscator.
<! CTGRY ><LI>Cut-and-paste reuse rather than library calls can help to make the JAR smaller.
<! CTGRY ><LI>Keep resources (such as PNG) as small as possible. Different tools give different compression factors.
<! CTGRY ><LI>Combine image files into one image and extract images at runtime.
<! CTGRY ><LI>Release unneeded screens (e.g. splash screens) for garbage collection.
<! CTGRY ><LI>Delay creation of rarely used screens (e.g. Help, Options) until needed, and release them as soon as possible.
<! CTGRY ><LI>Set references to null when they are no longer needed.
<! CTGRY ><LI>Design the MIDlet to avoid network communications unless absolutely necessary, e.g. only send packets when something changes.
<! CTGRY ><LI>If you do something that takes a long time, show a visible and animated indicator.
<! CTGRY ><LI>Keep the user-interface responsive. Make sure that your event call-backs (e.g., Canvas.keyPressed or CommandListener.commandAction) return quickly.
<! CTGRY ><LI>Make sure that there is a visible (or audible) reaction to each key press.
<! CTGRY ><LI>Hide unavoidable delays with some other activity.
START
http://developer.java.sun.com/developer/technicalArticles/Programming/turbo/
1.4 HotSpot GC
(Page last updated November 2002, Added 2002-11-27, Author Alka Gupta and Michael Doyle, Publisher Sun).
15
<! CTGRY ><LI>HotSpot heap is split into Eden (where new objects are created), two Survivor spaces (the three spaces collectively are the young generation space), and an old generation space. The young generation was collected using a copying collector (copy live objects from one space to another, everything left can be reclaimed), optimal for short-lived objects. The old generation used a mark-compact collector (mark all live objects, reclaim what's left then compact the resulting fragmented space).
<! CTGRY ><LI>Before 1.4.1, GC was single-threaded and stop-the-world in nature. This could cause long pauses in application activity, even on multi-processor systems.
<! CTGRY ><LI>1.4.1 includes a new young generation GC algorithm, parallel GC, enabled using -XX:+UseParNewGC (or -XX:+UseParallelGC for applications with very large young generation heaps and no concurrent mark-sweep GC). Parallel GC is essentially the same as previously but the stop-the-world phase of the young generation collection is multi-threaded, so the GC can complete more quickly on multi-process machines (as the GC algorithm is itself mostly parallelizable). The -XX:ParallelGCThreads=n flag allows the number of GC threads to be explcictly specified, the default is one thread per processor.
<! CTGRY ><LI>1.4.1 includes a new old generation GC algorithm, concurrent mark-sweep GC, enabled using -XX:+UseConcMarkSweepGC. Concurrent mark-sweep GC changes how the old generation is collected to minimize the amount of time that the other non-GC threads are suspended. The -XX:CMSInitiatingOccupancyFraction=x flag specifies how full the old generation can get before this GC kicks in, and the parameter should be tuned for the application.
<! CTGRY ><LI>The flag -XX:MaxTenuringThreshold=n specifies how many times (generations) the objects in the young generation are copied before being moved to the old generation.
<! CTGRY ><LI>The flag -XX:TargetSurvivorRatio=n specifies how full survivir space gets before moving objects to the old generation.
<! CTGRY ><LI>The following flags specify information printed out to stderr during GC: -verbose:gc (turns on GC logging); -Xloggc=filename (moves logging to filename instead of stderr); -XX:+PrintGCTimeStamps (timestamps GC log entries); -XX:+PrintGCDetails (extra GC info logged); -XX:+PrintTenuringDistribution (even more extra GC info logged).
<! CTGRY ><LI>[Article gives an example of interpreting the output from 1.4.1 GC logging].
<! CTGRY ><LI>[Article provides and describes a tool which can mine the 1.4.1 GC log data].
<! CTGRY ><LI>Use the alternate thread library available from Solaris 8 by setting the LD_LIBRARY_PATH=/usr/lib/lwp:/usr/lib on Solaris 8 (the default on Solaris 9).
<! CTGRY ><LI>Use prstat -Lm -p <jvm process id> to analyze the resource usage of a process on a per light-weight-process.
<! CTGRY ><LI>To get a full thread dump of a running Java application, send a SIGQUIT signal to the JVM process (e.g. kill -QUIT <JVM process pid>).
<! CTGRY ><LI>Use the -Xrunhprof command line flag available in the JVM to help identify unnecessary object retention (sometimes imprecisely called "memory leaks").
<! CTGRY ><LI>Minimize the number of times the DatagramSocket.connect(InetAddress address, int port) and DatagramSocket.disconnect() methods are called.
<! CTGRY ><LI>[Article describes tuning GC for a particular application].
START
http://www.developer.com/design/article.php/1545991
User Interface Design
(Page last updated November 2002, Added 2002-11-27, Author Mauro Marinilli, Publisher Developer.com).
7
<! CTGRY ><LI>Focus on the needs of end users. Know your user.
<! CTGRY ><LI>Slow response is a cause of error and user frustration in using the application.
<! CTGRY ><LI>If somebody is used to having a task completed in a given amount of time, both excessive completion time or too short a time can confuse the user.
<! CTGRY ><LI>Short response times help the user to explore the UI more easily.
<! CTGRY ><LI>Operations that can be processed using only a person's short-term-memory (STM) are easier and faster to solve than those that require long-term-memory or some external cognitive help. STM holds 5 to 9 items, each of which holds information that lasts 15-30 seconds. STM is assisted by the user: feeling at ease with the application; having a reassuringly predictable idea of how it works; without the fear of making catastrophic operations; without feeling compelled by the system.
<! CTGRY ><LI>Following standard designs leverages the knowledge users have gained from other applications.
<! CTGRY ><LI>Minimize the set tasks the user needs to carry out to complete their activity.
START
http://www-106.ibm.com/developerworks/java/library/j-jtp1029.html
The final keyword
(Page last updated October 2002, Added 2002-11-27, Author Brian Goetz, Publisher IBM).
4
<! CTGRY ><LI>Don't declare things <CODE>final</CODE> for performance reasons, until as late as possible.
<! CTGRY ><LI>Declaring methods <CODE>final</CODE> does NOT allow the compiler to inline that method. JITs can inline methods, whether or not they are <CODE>final</CODE>, so there is usually no performance benefit to declaring methods <CODE>final</CODE>.
<! CTGRY ><LI>If you want to optimize your code, stick to optimizations that will make a big difference, like using efficient algorithms and not performing redundant calculations -- and leave the cycle-counting optimizations to the compiler and JVM.
<! CTGRY ><LI>Unlike with final methods, declaring a final <em>field</em> helps the optimizer make better optimization decisions, because if the compiler knows the field's value will not change, it can safely cache the value in a register.
START
http://www.javaworld.com/javaworld/jw-10-2002/jw-1025-j2mebenchmark.html
J2ME benchmarking
(Page last updated October 2002, Added 2002-11-27, Author Wang Yi, C.J. Reddy, and Gavin Ang, Publisher JavaWorld).
5
<! CTGRY ><LI>J2ME benchmarking should focus on the total user experience
<! CTGRY ><LI>The benchmarks presented in the article can help determine which part of a J2ME application is a bottleneck
<! CTGRY ><LI>Most J2ME devices seem to have similar graphics painting performance.
<! CTGRY ><LI>Avoid creating multiple LCDUI objects.
<! CTGRY ><LI>XML parsing is resource instensive, and even a simple XML file needs seconds to parse.
START
http://crazybob.org/index.jsp?weblog=http://freeroller.net/page/crazyboblee/20021110
Multiple layers of dynamic proxies
(Page last updated November 2002, Added 2002-11-27, Author crazybob, Publisher crazybob.org).
1
<! CTGRY ><LI>By specializing a Proxy to test for handing off method invocation to another proxy, you can wrap proxies outside other proxies with negligible additional overheads.
START
http://www.javaworld.com/javaworld/javatips/jw-javatip132.html
Handling unexpected thread death
(Page last updated November 2002, Added 2002-11-27, Author Roy M. Pueschel, Publisher JavaWorld).
1
<! CTGRY ><LI>Create one (or two) watcher thread(s) to restart or log thread death for thread services when they could unexpectedly terminate.
START
http://www.cs.usfca.edu/~parrt/doc/devnybbles.html
Nybbles of Development Wisdom
(Page last updated October 2002, Added 2002-11-27, Author Terence Parr, Publisher ?).
4
<! CTGRY ><LI>Don't worry about writing super efficient code until you know there is or will be a speed problem. Use a profiler to know rather than deduce where the inefficient hot spots are. 
<! CTGRY ><LI>Do expensive operations either up front or in the background (load data, snoop or search other sites, sort, ...). 
<! CTGRY ><LI>Use memory if you have it. If your sizeof(database) < sizeof(RAM), cache the whole damn thing. 
<! CTGRY ><LI>Cache pages that don't change or change infrequently to reduce server load. 
START
http://dev2dev.bea.com/articlesnews/discussion/thread.jsp?thread=Hazarika
Capacity Planning
(Page last updated November 2002, Added 2002-11-27, Author Arunabh Hazarika and Srikant Subramaniam, Publisher BEA).
12
<! CTGRY ><LI>Capacity planning is achieved by measuring or estimating the number of requests the server processes,calculating the demand each request places on the server resources, then using this data to calculate the computing resources (CPU, RAM, disk space, and network bandwidth) necessary to support current and future usage levels.
<! CTGRY ><LI>When traffic increases on a major Web site that isn't adequately equipped to handle the surge, response time deteriorates significantly.
<! CTGRY ><LI>Studies have shown that if a site's response time is more than 10 seconds, users tend to leave.
<! CTGRY ><LI>SSL is a very computing-intensive technology and the overhead of cryptography can significantly decrease the number of simultaneous connections that a system can support. Typically, for every SSL connection the server can support, it can handle up to three non-SSL connections.
<! CTGRY ><LI>Typically, a good application will require a database three to four times more powerful than the application server hardware.
<! CTGRY ><LI>Increasing user numbers with no increase in CPU comsumption usually indicates a bottleneck exists.
<! CTGRY ><LI>Additional processes running on the same machine can significantly affect the capacity (and performance) of the application server. The database and Web servers are two popular choices for hosting on a separate machine.
<! CTGRY ><LI>User behaviour is unpredictable. When estimating the peak load, it's advisable to plan for demand spikes and focus on the worst-case scenario.
<! CTGRY ><LI>If the response time doesn't improve after adding servers to a cluster, and the Web server machine shows a CPU usage of over 95%, consider clustering the Web server or running it on more powerful hardware.
<! CTGRY ><LI>It's essential to optimize the application by eliminating or reducing the hot spots and considering the working set/concurrency issues.
<! CTGRY ><LI>In a fully loaded tuned system, the CPU utilization is usually in the 90-95% range. Throughput won't increase with the addition of more load, but response times will increase as more clients are added. The throughput at this point determines the capacity of the hardware.
<! CTGRY ><LI>During load testing it's essential to use a transaction scenario that closely resembles the real-world conditions the application deployment will be subjected to.
START
http://developer.java.sun.com/developer/JDCTechTips/2002/tt1119.html
Socket connection timeouts
(Page last updated November 2002, Added 2002-11-27, Author John Zukowski, Publisher Sun).
1
<! CTGRY ><LI>From 1.4, the connect call allows an additional timeout parameter that can timeout connection attempts. (This differs from the setSoTimeout method which sets the timeout for read() calls only).
START
http://dev2dev.bea.com/articlesnews/discussion/thread.jsp?thread=subramaniam
WebLogic Server Performance Tuning
(Page last updated October 2002, Added 2002-11-27, Author Arunabh Hazarika & Srikant Subramaniam, Publisher BEA).
10
<! CTGRY ><LI>The first step in performance tuning is isolating the hot spots, determining which system component is contributing to the performance problem.
<! CTGRY ><LI>The most expensive operations that the EJB container executes are probably database calls to load and store entity beans. Some cases reduce database calls: read-only beans only require one load; unmodified beans don't need to execute the store operation.
<! CTGRY ><LI>Pooling (e.g. beans and connections) and caching are important performance improving features of application servers, and should be used and tuned.
<! CTGRY ><LI>Disabling synchronous JMS writes can improve performance.
<! CTGRY ><LI>The JMS message acknowledgement interval should be tuned: too small may slow message processing; too large may cause lost or duplicate messages.
<! CTGRY ><LI>A single JMS server is adequate until scalability peaks, then multiple servers should be used.
<! CTGRY ><LI>Asynchronous JMS consumers typically scale and perform better than synchronous consumers. 
<! CTGRY ><LI>JSP cache tags can be used to cache data in a JSP page.
<! CTGRY ><LI>It is advisable not to store too much information in the HTTP session.
<! CTGRY ><LI>In JVMs that organize the heap into generational spaces, the new space or the nursery should typically be set to between a third and half of the total heap size.
START
http://www.zeropoint.com/Support/Docs/Articles/FastAuthentication.html
Fast authentication
(Page last updated November 2002, Added 2002-11-27, Author Larry Ashworth, Publisher ZeroPoint).
7
<! CTGRY ><LI>Cookie based authentication is simple and quick. Dynamically rewriting links to include a session id can impose a high load on the server.
<! CTGRY ><LI>The best time to check for expired sessions is during the authentication process.
<! CTGRY ><LI>Heavy-weight object creations (i.e. SimpleDateFormat) should only occur once if possible, during your authentication class's initialization process.
<! CTGRY ><LI>Use StringBuffer.append() and not String concatenation.
<! CTGRY ><LI>Use object methods that empty an existing object rather than recreating the object. String arrays are an exception 
<! CTGRY ><LI>Don't create an object within a looping structure if you can help it.
<! CTGRY ><LI>Larger database table sizes decrease performance. Cache data where possible.
START
http://www-1.ibm.com/support/docview.wss?rs=180&context=SSEQTP&uid=swg21078467
Speeding JVM startup
(Page last updated November 2002, Added 2002-11-27, Author ?, Publisher IBM).
1
<! CTGRY ><LI>Disabling JIT compilation improves JVM startup time.
START
http://www.sys-con.com/java/article.cfm?id=1720
Thread pooling
(Page last updated November 2002, Added 2002-11-27, Author Vishal Goenka, Publisher JDJ).
3
<! CTGRY ><LI>Each threads has a memory overhead, and also adds scheduling overhead. Thread pooling limits these overheads.
<! CTGRY ><LI>Thread creation also has an overhead that can be higher than the overhead of managing a thread pool. However in the latest JVMs thread creation is much cheaper than previous JVMs.
<! CTGRY ><LI>Thread pooling has a number of drawbacks: ThreadLocals are not as useful; the pool can be fully used stalling further requests from being processed; managing a pool can be more expensive than simply creating and discarding threads on demand.
START
http://dev2dev.bea.com/articlesnews/discussion/thread.jsp?thread=zadrozny
HTTP sessions vs. stateful EJB
(Page last updated October 2002, Added 2002-11-27, Author Peter Zadrozny, Publisher BEA).
2
<LI>The comparative costs of storing data in an HTTP session object are roughly the same as storing the same data in a stateful session bean.
<LI>Failure to remove an EJB that should have been removed (from the HTTP session) carries a very high performance price: the EJB will be passivated which is a very expensive operation.
START
http://developer.java.sun.com/developer/JDCTechTips/2002/tt1105.html
HashSet, LinkedHashSet, and TreeSet
(Page last updated November 2002, Added 2002-11-27, Author Glen McCluskey, Publisher Sun).
3
<! CTGRY ><LI>HashSet is faster than LinkedHashSet which is in turn faster than TreeSet for access/updates (iteration speed has a different order).
<! CTGRY ><LI>Iteration over a LinkedHashSet is generally faster than iteration over a HashSet.
<! CTGRY ><LI>Tree-based data structures (like TressSet) get slower as the number of elements get larger.
START
http://www.websphere-world.com/download/boost.doc
WebSphere performance tips
(Page last updated October 2002, Added 2002-11-27, Author Arvind Shukla, Publisher ).
3
<! CTGRY ><LI>Deliver compressed documents where possible.
<! CTGRY ><LI>Use the document expiration settings to let the client browser retrieve documents from its own cache.
<! CTGRY ><LI>Move static content from the application server to the web server.
START
http://www.eurekalert.org/pub_releases/2002-10/ps-sds103002.php
The effect of Slow download speeds
(Page last updated October 2002, Added 2002-11-27, Author Steve Sampsell, Publisher EurekaAlert).
1
<! CTGRY ><LI>Pages downloaded slower can sometimes increase user interest. [Probably when the wait enhances interest in some way - the example given was an erotic image].
START
http://www.javaspecialists.co.za/archive/Issue060.html
Does nulling variables help garbage collection
(Page last updated November 2002, Added 2002-12-27, Author Jack Shirazi, Publisher Kabutz).
5
<! CTGRY ><LI>In some rare situations, explicitly nulling a variable reference can allow the garbage collector to reclaim an object in the young generation, avoiding promoting that object and having to reclaim it more slowly in the old generation.
<! CTGRY ><LI>Object cycling (creation then deletion) is an order of magnitude faster in the young generation than the old generation.
<! CTGRY ><LI>Objects that are too large to fit into the young generation must be created directly in the old generation.
<! CTGRY ><LI>Correctly scoping objects avoids having to rely on nulling variables to dereference objects.
<! CTGRY ><LI>Tuning the heap is worthwhile and can avoid you having to make code changes.
START
http://www-106.ibm.com/developerworks/java/library/j-jtp1126.html
The util.concurrent package
(Page last updated November 2002, Added 2002-12-27, Author Brian Goetz, Publisher IBM).
4
<! CTGRY ><LI>wait(), notify(), and synchronized are tricky to use correctly and there are many performance, deadlock, fairness, resource management, and thread-safety hazards to avoid.
<! CTGRY ><LI>Doug Lea's util.concurrent is a well tried free package of concurrency utilities that will form the basis of the java.util.concurrent package in JDK 1.5. util.concurrent supports timing out locks; interrupting lock acquisition attempts; creating shared locks; supporting multi-mode locking, such as concurrent-read with exclusive-write; acquire a lock in one method and release it in another; etc.
<! CTGRY ><LI>A real-world task scheduler should deal with threads that die, kill excess pool threads so they don't consume resources unnecessarily, manage the pool size dynamically based on load, and bound the number of tasks queued. util.concurrent includes efficient thread pool management.
<! CTGRY ><LI>util.concurrent includes efficient asynchronous process scheduling.
START
http://www-106.ibm.com/developerworks/java/library/j-ejb1217.html
Optimizing EJB validation code
(Page last updated December 2002, Added 2002-12-27, Author Brett McLaughlin, Publisher IBM).
2
<! CTGRY ><LI>Place all your data validation code (ensuring data is the correct type/format/range) in the business delegate methods (which execute on the client). Keep your data validation logic as close to the client as possible to minimize unnecessary requests to the server.
<! CTGRY ><LI>Business-specific validation (testing against business rules, e.g. a specific book exists) should be in the EJB layer optimized to use local calls.
START
http://builder.com.com/article.jhtml?id=u00220021119sge01.htm&fromtm=e027
Long-running tasks
(Page last updated November 2002, Added 2002-12-27, Author Serguei Eremenko, Publisher Builder.com).
1
<! CTGRY ><LI>[Article describes a class designed for efficiently managing long running tasks].
START
http://www.javaworld.com/javaworld/javaqa/2002-11/01-qa-1108-cpu.html
CPU usage monitoring
(Page last updated November 2002, Added 2002-12-27, Author Vladimir Roubtsov , Publisher JavaWorld).
2
<! CTGRY ><LI>Programmatically querying for CPU usage is not possible using pure Java, you need to use a JNI call.
<! CTGRY ><LI>[Article describes implementing a JNI call to getProcessCPUTime() to get CPU usage of the system].
START
http://java.sun.com/features/2002/11/appserver_influences.html
Application server performance
(Page last updated November 2002, Added 2002-12-27, Author Rohit Valia and Marina Sum, Publisher Sun).
2
<! CTGRY ><LI>HTTPS is characterized by light inbound/heavy outbound traffic. SSL requires heavy CPU usage.
<! CTGRY ><LI>Each type of application has its own performance profile. Benchmark your application using measurment toolkits.
START
http://www.sys-con.com/java/article.cfm?id=1783
J2ME portability
(Page last updated December 2002, Added 2002-12-27, Author Jeremy Wakefield, Keith Braithwaite & Tony Robinson, Publisher JavaDevelopersJournal).
2
<! CTGRY ><LI>It's possible for a MIDP implementation to pass the TCK tests and not perform well at all.
<! CTGRY ><LI>MIDlets allocate resources in startApp() and release them in destroyApp(). MIDlets PAUSED by the device's operating system must release expensive or volatile resources. Some platforms call destroyApp() when the MIDlet is PAUSED, and create a new instance when it returns to the foreground. A MIDlet should expect the possibility of being DESTROYED when PAUSED, and manage resources accordingly.
START
http://www.javaworld.com/javaworld/jw-12-2002/jw-1213-j2medesign.html
J2ME design patterns
(Page last updated December 2002, Added 2002-12-27, Author Ben Hui, Publisher JavaWorld).
2
<! CTGRY ><LI>[Article presents several design patterns suitable for J2ME applications].
<! CTGRY ><LI>It takes a lot of memory and processing power to show 1,000 strings on a mobile phone. Use the Pagination pattern to divide data into pages.
START
http://wireless.java.sun.com/midp/articles/garbagecollection2/
Tuning 1.4.1 heap and GC
(Page last updated November 2002, Added 2002-12-27, Author Nagendra Nagarajayya and J. Steven Mayer, Publisher Sun).
26
<! CTGRY ><LI>1.4.1 has three young generation collectors (copying collector; parallel copying collector; parallel scavenge collector) and two old generation collectors (mark-compact collector and concurrent collector).
<! CTGRY ><LI>The parallel copying collector uses multiple threads (one per CPU by default) to garbage collect the young generation, thus should be faster than the default single-threaded copying collector on multiple-CPU machines. Enabled by using the -XX:+UseParNewGC option (though on a single CPU machine the default copy collector is still used since it is more efficient in that case). The -XX:ParallelGCThreads=<num threads> option can be used to specify a different number of threads from the default (one per CPU), and can force the use of this collector on a single CPU machine.
<! CTGRY ><LI>The concurrent collector minimizes the stop-the-world portions of the old generation garbage collection, thus minimizing application pause times. Most of the concurrent collector GC occurs concurrently with the application. Enabled by using the -XX:+UseConcMarkSweepGC option. The concurrent collector background thread starts running when the percentage of allocated space in the old generation goes above the -XX:CMSInitiatingOccupancyFraction=<percent>, default value is 68%. If "the rate of creation" of objects is too high, and the concurrent collector is not able to keep up with the concurrent collection, it falls back to the traditional mark-sweep collector.
<! CTGRY ><LI>The parallel scavenge collector is similar to the parallel copying collector but is optimized for large systems: mutliple CPUs and heap sizes above 10 gigabytes. Enabled by using the -XX:UseParallelGC option, which forces old generation GC to use the original mark-compact old generation collector. With large heaps, the -XX:TargetSurvivorRatio should pronbably be increased beyond the default of 50. The -XX:ParallelGCThreads=<num threads> option can be used to specify a different number of threads from the default (one per CPU), and can force the use of this collector on a single CPU machine. Adaptive sizing can be turned on with the -XX:+UseAdaptiveSizePolicy option.
<! CTGRY ><LI>The mark compact (original) old generation garbage collector is very efficient where pause time is not a big criterion.
<! CTGRY ><LI>1.4.1 heap consist of: permanent generation, used to store class objects and related meta data (sized using -XX:PermSize and -XX:MaxPermSize, use -Xnoclassgc to prevent GC here); old generation used to hold old objects promoted from the younger generation (sized using -Xms and -Xmx which specifies the total sizes of young and old generation combined); and young generation which is further divided into an Eden, and two semi-spaces (sized using -XX:NewSize, -XX:MaxNewSize, -XX:SurvivorRatio such that <CODE>EdenSize = NewSize - ((NewSize / ( SurvivorRatio + 2)) * 2)</CODE> and <CODE>SemispaceSize = (NewSize - EdenSize) / 2</CODE>).
<! CTGRY ><LI>The -XX:MaxTenuringThreshold=<N> option specifies how many collections an object can remain in the young generation, after which it is promoted to the old generation. The promoteall option (last available in 1.2.2) which immediately promoted any object that survived a young generation to old generation space, can be simulated using -XX:MaxTenuringThreshold=0 (in which case there is no need for any semispace, so they should be sized extremely small in conjunction, e.g. -XX:SurvivorRatio=20000).
<! CTGRY ><LI>[Article gives an example of using Amdahls law to predict the parallelism efficiency of an application from its GC costs].
<! CTGRY ><LI>Options that generate GC logging are -verbose:gc, -XX:+PrintGCDetails, -XX:+PrintGCTimeStamps, -XX:+PrintHeapAtGC. Note that -Xloggc does not log data from the -XX switches. [Article describes the information available when using these options].
<! CTGRY ><LI>[Article provides an analysis script to analyze the GC logging output available from 1.4.1 GC logging options].
<! CTGRY ><LI>If the application has few intermediate objects (objects surviving one or more young generations GCs), using the promoteall modifier decreases the amount of time that the application spends copying in young GC. But the collection cost is moved to old generation GC, which may be worse.
<! CTGRY ><LI>Copy collection is directly proportional to the size of the live objects.
<! CTGRY ><LI>Dereference objects (perhaps by nulling the variable pointing to them) as soon as they are no longer needed.
<! CTGRY ><LI>Avoid creating unnecessary objects.
<! CTGRY ><LI>Pooling objects can easily cost more to use than the time saved in GC. Objects are suitable for pooling when they: take a long time to create or use up a lot of memory (threads, db connections); are static objects, especially when they have no state.
<! CTGRY ><LI>Temporary objects referenced from objects in the old generation (e.g. long-lived objects) have a higher scanning cost (young generation GC phase).
<! CTGRY ><LI>Flattened objects are cheaper to garbage collect than the equivalent data in nested objects.
<! CTGRY ><LI>The -XX:PretenureSizeThreshold=<byte size> (default 0) specifies the size of objects to create directly in the old generation. This option can easily degrade performance.
<! CTGRY ><LI>NIO direct buffers are stored outside the heap, so avoid GC, and can be used to store long life objects like lookup tables, caches, etc. [Except presumably there is some GC when the buffer is released].
<! CTGRY ><LI>Reference objects are expensive for the garbage collectors.
<! CTGRY ><LI>Finalizers are very expensive for the garbage collectors.
<! CTGRY ><LI>Finding the optimal size for the young generation is pretty easy. The rule of thumb is to make it about as large as possible, given acceptable collection (pause) times. There is a certain amount of fixed overhead with each collection, so their frequency should be minimized. If pauses are not an issue, young generation space should be made as large as possible.
<! CTGRY ><LI>Old generation heap size needs to be balanced to minimize overall GC times. Too small a size leads to an increased rate of GC, to large a size leads to long GC times as the old generation GC time is proportional to the size of the heap.
<! CTGRY ><LI>Old generation is not compacted by default, leading to a fragmented heap. The -XX:+UseCMSCompactAtFullCollection option can be used to enable compaction of the old generation heap at the cost of performance.
<! CTGRY ><LI>Heaps large than physical memory incur operating system paging overheads which significantly degrades performance.
<! CTGRY ><LI>[Article inludes Solaris specific tuning options, sections 16.2.6.1 and 18].
START
http://www7b.software.ibm.com/dmdd/library/techarticle/0202campbell/0202campbell.html
Java Performance for DB2 Applications
(Page last updated November 2002, Added 2002-12-27, Author John Campbell, Publisher IBM).
9
<! CTGRY ><LI>SQLJ can be faster than JDBC because some of the JDBC runtime overheads can be shifted to compilation time.
<! CTGRY ><LI>Ensure the SQLJ serialized profile is customized correctly, and request online checking.
<! CTGRY ><LI>Use the same ConnectionContext for corresponding SQLJ statements.
<! CTGRY ><LI>Close resources (Resultsets, Statements, ...) when finished with
<! CTGRY ><LI>Disable autocommit.
<! CTGRY ><LI>SELECT and UPDATE only those columns you need.
<! CTGRY ><LI>Tune the JVM heap.
<! CTGRY ><LI>Use the latest JVM and JDBC driver.
<! CTGRY ><LI>Turn on DB2 dynamic SQL statement caching with CACHEDYN=YES in your subsystem parameters (DSNZPARM).
START
http://www-106.ibm.com/developerworks/webservices/library/ws-cach1/
Caching web services
(Page last updated December 2002, Added 2002-12-27, Author Brian D. Goodman, Publisher IBM).
2
<! CTGRY ><LI>Web service performance depends on: Network transaction time; The time it takes to handle the message (XML parsing/generation, etc); The time the service itself takes to execute.
<! CTGRY ><LI>Cache where possible [Article describes a few caching scenarios].
START
http://www.messageq.com/systems_management/proactivenet_1a.html
Statistical analysis to help identify performance bottlenecks
(Page last updated November 2002, Added 2002-12-27, Author ProactiveNet, Publisher ebizQ).
3
<! CTGRY ><LI>A user’s perception of a quality application experience is predominantly determined by the application’s response time and availability.
<! CTGRY ><LI>Use statistical quality control to manage the huge volume of performance data: periodic statistical sampling, creation of "normal" control charts and focusing additional analysis on "abnormal" data points. Accurate baselining is critical.
<! CTGRY ><LI>A series of analyses helps identify the causes of performance problems: 1 detect abnormal performance (outside expected ranges); 2 correlate abnormalities compared to baseline measurements for all other variables at about the same time as the alerted performance abnormality; 3 eliminate detected abnormalities that are unlikely causes; 4 score the remaining abnormalities according to degree of abnormailty and likely causation.
START
http://research.sun.com/techrep/2002/abstract-118.html
Compile time assists for JITs
(Page last updated October 2002, Added 2002-12-27, Author Vivek Haldar, Publisher Sun).
1
<! CTGRY ><LI>[Article describes how the compiler can add optimization hints while still satisfying the Java security model].
START
http://www.devx.com/xml/Article/10114
Building a lightweight XML parser
(Page last updated November 2002, Added 2002-12-27, Author Guang Yang, Publisher DevX).
2
<! CTGRY ><LI>A full-featured XML parser can be too resource intensive for your particular application. The SimpleDOMParser (described here) is a highly simplified, under 4 KB and fewer than 400 lines of source.
<! CTGRY ><LI>SAX parsing provides better performance than DOM as SAX process one tag at a time, while DOM maintains global state. However SimpleDOMParser provides a simplified DOM which is not resource intensive.
START
http://www.devx.com/DevX/Article/10027
Safe data writing with memory mapped files
(Page last updated November 2002, Added 2002-12-27, Author Greg Travis, Publisher DevX).
4
<! CTGRY ><LI>Efficiently updating file based data caches changes in memory and writes it periodically to disk (called checkpointing).
<! CTGRY ><LI>Using memory mapped files can be efficient because the underlying operating system manages disk pages on demand, only loading the data that is actually accessed.
<! CTGRY ><LI>Any change to a memory mapped file immediately changes the file, so care must be taken to avoid corrupt states. The article describes a class which maintains changes in memory and duplicated in a disk-based "change log", efficiently applying changes atomically to avoid corrupt states. In case of a crash, the "change log" allows recovery to the last non-corrupt state.
<! CTGRY ><LI>Writes to disk are not necessarily immediately flushed to disk, for efficiency reasons. You can force data to disk using MappedByteBuffer.force(), but this can slow down processing.
START
http://webperformanceinc.com/library/ServletReport/
Comparing The Performance of J2EE Servers
(Page last updated November 2002, Added 2002-12-27, Author Christopher L Merrill, Publisher Web Performance Inc).
1
<! CTGRY ><LI>[Report comparing the performance of servlet servers. Describes how to build a load test].
START
http://www.aceshardware.com/read.jsp?id=50000347
Scaling Server Performance
(Page last updated January 2003, Added 2002-12-29, Author Brian Neal, Publisher AcesHardware).
8
<! CTGRY ><LI>Java servlet based site served 250,000 page visits in a day (average of 3 visits per second), each page required an average of 2.36 requests to be handled by the server. Peak rate was 677 requests per minute (11.28/second). The Java Web application used only 20% of CPU AT PEAK TIME! (database took another 7.5% CPU).
<! CTGRY ><LI>Cached content is key to excellent performance. Caching pages (and page fragments) in-memory can easily provide an order of magnitude speedup.
<! CTGRY ><LI>For optimal performance, you need to isolate the bottlenecks in your software and eliminate them.
<! CTGRY ><LI>Keepalive means that each HTTP connection must wait idle for a certain period of time, perhaps 10 or 15 seconds. With Keepalive, a large number of concurrent requests from unique clients can result in a large number of idle HTTP connections waiting to timeout, potentially depleting resources.
<! CTGRY ><LI>You can mitigate performance issues by throwing hardware at them.
<! CTGRY ><LI>If database performance is lacking, even solid state disks (SSDs) can't outperform a system that doesn't have to run the query in the first place.
<! CTGRY ><LI>Serving compressed pages to browsers that can handle them alleviates bandwidth problems.
<! CTGRY ><LI>Serving static content is the least demanding workload a modern day HTTP server will encounter.
START
http://www.e-promag.com/eparchive/index.cfm?fuseaction=viewarticle&ContentID=2627&websiteid=
Implementing High Availability for WebSphere Application Servers
(Page last updated November 2002, Added 2002-12-29, Author John Lamb, Michael Laskey, Publisher e-ProMag.com).
10
<! CTGRY ><LI>For most Web servers, high availability (i.e., system accessibility on as close to a 24/7 basis as possible) is of paramount importance.
<! CTGRY ><LI>Reliable hardware and software provide the base level of availability. 
<! CTGRY ><LI>Advanced features such as RAID devices enhance availability.
<! CTGRY ><LI>Fault-tolerant systems ensure the constant availability of the entire system but at a higher cost.
<! CTGRY ><LI>OS/hardware clustering provides high availability but not necessarily load balancing.
<! CTGRY ><LI>If the failover system uses the same disk as the main system it is important to have a mirrored (RAID 1) shared disk to use for OS clustering.
<! CTGRY ><LI>Application code should be prepared to rollover to an alternative database server if the current server stops providing data.
<! CTGRY ><LI>Web sites that require massive scalability need IP Sprayers which provide for load distribution and failover for incoming HTTP requests.
<! CTGRY ><LI>[Articles details the configuration and architecture of an actual website which is highly available, scalable, fast and reliable].
<! CTGRY ><LI>Use: the application server failover features; OS clustering; Web/IP sprayer; RAID disks; SMP; redundant power supplies; Round robin DNS;
START
http://www.cs.wustl.edu/~schmidt/PDF/PDCP.pdf
Optimizing the performance of JAWS Webserver
(Page last updated 1999, Added 2002-12-29, Author James C. Hu, Irfan Pyarali, Douglas C. Schmidt, Publisher Distributed Object-Oriented Systems).
10
<! CTGRY ><LI>Caching disk data in-memory is the primary improvement possible for webservers. The overhead of disk I/O is the primary factor in webserver performance, but this can be reduced to a negligible constant factor via memory caches.
<! CTGRY ><LI>After disk I/O the primary determinants of Web server performance are its concurrency and event dispatching strategies.
<! CTGRY ><LI>Asynchronous event dispatching can increase server throughput by reducing the context switching and synchronization overhead incurred from multi-threading by reducing the number of threading resources required to handle client requests concurrently.
<! CTGRY ><LI>Request dispatching occupies a large portion (50%) of non-I/O related Web server overhead. The choice of concurrency strategy, such as thread/process pool vs. thread/process per-request, and dispatching strategy, such as asynchronous vs. synchronous, has a major impact on performance.
<! CTGRY ><LI>Synchronous Event Dispatching uses one thread to accept client connections and hands off each resulting client socket to one other processing thread for request handling. Asynchronous Event Dispatching multiplexes all client connection I/O through the same I/O subsystem (usually consisting of one or two threads), with processing threads handling only non I/O tasks, i.e. request processing only excluding low-level reads and writes.
<! CTGRY ><LI>The time required to create a new thread is an order of magnitude smaller (faster) than the time required to create a new system process (on Windows NT)
<! CTGRY ><LI>A synchronous thread pool server strategy is useful for bounding the number of OS resources consumed by a Web server. Each thread waits in accept(), and the operating system selects one thread to unblock when a client connection request is received. Then the thread synchronously processes that client connection, returing to accept() when request handling is complete. If there are more pending requests than pooled threads, connection requests are queued in the TCP/IP stack preventing the server from being overloaded (of course response times degrade from the client's point of view since that response time includes time spent in the queue).
<! CTGRY ><LI>An asynchronous thread pool server strategy consists of having threads wait on completion ports (equivalent to the Selector from the NIO packages). The operating system selects one thread to handle any non-blocking request (accept/read/write). [In Java you'd probably do it slightly differently, with one thread executing the Selector in one thread and explicitly handing off requests to other threads].
<! CTGRY ><LI>Dedicating a thread for each client connection provides good support for prioritization of client requests, allowing differentiation of quality of service. However if certain connections receive considerably more requests than others, they can become a performance bottleneck.
<! CTGRY ><LI>Memory mapping files can boost their transmission speed. However under heavy server loads the extra kernel load produced by using I/O with memory mapped files may degrade performance.
START
http://www.javaworld.com/javaworld/jw-12-2002/jw-1227-sort.html
Sorting
(Page last updated December 2002, Added 2002-12-29, Author Alex Blewitt, Publisher JavaWorld).
1
<! CTGRY ><LI>When sorting large amounts of data extracted from a database, it is usually more efficient to let the database perform the sort using the ORDER BY clause, rather than to extract the data unordered and sort in Java.
START
http://www.fawcette.com/javapro/2002_11/online/obj_krangaraju_11_08_02/
Make Object Pooling Simple
(Page last updated November 2002, Added 2002-12-29, Author Karthik Rangaraju, Publisher JavaPro).
3
<! CTGRY ><LI>Object pooling is one efficient way to manage access to a finite set of objects among competing clients.
<! CTGRY ><LI>By limiting object access to only the period when the client requires it, you can free resources for use by other clients. Increasing utilization through pooling usually increases system performance.
<! CTGRY ><LI>Reuse objects to minimize costly initializations (pooling objects is often associated with such reuse).
START
http://www.onjava.com/pub/a/onjava/excerpt/jebp_3/index1.html
Servlet Best Practices 1
(Page last updated December 2002, Added 2002-12-29, Author Jason Hunter, Publisher OnJava).
4
<! CTGRY ><LI>OutputStream has less overhead than PrintWriter, so use it for characters as well as bytes, except when there's a charset mismatch between the stored encoding and the required encoding.
<! CTGRY ><LI>Use ResultSet getAsciiStream( ) method instead of getCharacterStream( ) to avoid conversion overhead for ASCII strings.
<! CTGRY ><LI>You can pre-encode static String contents with String.getBytes( ) so that they're encoded only once.
<! CTGRY ><LI>Don't Use SingleThreadModel.
START
http://www.onjava.com/pub/a/onjava/excerpt/jebp_3/index2.html
Servlet Best Practices 2
(Page last updated January 2003, Added 2002-12-29, Author Jason Hunter, Publisher OnJava).
3
<! CTGRY ><LI>Pre-generate pages as much as possible offline to reduce online overheads.
<! CTGRY ><LI>Cache as much as possible.
<! CTGRY ><LI>Use the Last-Modified HTTP header and the associated If-Modified-Since header to enable use of the browser cache.
START
http://www.artima.com/intv/distrib.html
Designing Distributed Systems
(Page last updated October 2002, Added 2002-12-29, Author Bill Venners, Publisher Artima.com).
7
<! CTGRY ><LI>When designing for distributed systems, failure should be your number one concern.
<! CTGRY ><LI>Local/remote transparency is misleading, there is no real transparency. Local and remote are fundamentally different.
<! CTGRY ><LI>Simplicity is one key solution. The more things you do, the more you have to think about recovering from failure modes.
<! CTGRY ><LI>Transactions are one way to deal with potential failure, but transactions add overhead.
<! CTGRY ><LI>Idempotency, reinvoking remote method calls, should be harmless (e.g. method call has ID attached, so a call either invokes the method or is ignired if it has already been invoked).
<! CTGRY ><LI>Latency is important for distributed systems. Batching (combining) multiple requests into one request is one way of improving latency dependencies.
<! CTGRY ><LI>Stateless interactions are much more efficient than stateful interactions because stateless interactions reduce the amount of work required to recover from failure.
START
http://www.ociweb.com/jnb/jnbDec2002.html
New IO API
(Page last updated December 2002, Added 2002-12-29, Author Todd Stewart, Publisher OCIWeb).
10
<! CTGRY ><LI>The NIO packages enable write high performance, scaleable socket applications, and improved performance when reading and writing data to and from files.
<! CTGRY ><LI>High-performance server applications which manipulate Strings tend to create a lot of garbage causing significant overhead. Buffers are fixed size and can significantly reduce the amount of garbage produced
<! CTGRY ><LI>Direct Buffers can use operating systems native I/O mechanisms, which are very efficient at moving and copying data
<! CTGRY ><LI>Direct buffers have higher allocation and de-allocation costs than non-direct Buffers. Use direct buffers for large, long-lived buffers.
<! CTGRY ><LI>FileChannel allows a file to be mapped into memory, which may provide better performance than the typical read or write methods. 
<! CTGRY ><LI>The FileChannel allows bytes to be transferred from one file to another file (via its channel). Many operating systems can perform this in a very efficient manner by transferring directly from the file system cache.
<! CTGRY ><LI>Multiplexed non-blocking I/O, possible with selectable channels and selectors is more scaleable and efficient than the standard thread-oriented, blocking I/O (one socket per thread).
<! CTGRY ><LI>[Article runs through a pattern matching example which shows no performance improvement from using NIO I/O opertions, and even shows a significant performance decrease when memory mapping the file].
<! CTGRY ><LI>Memory mapped files are unlikely to improve performance of sequentially accessed, line-based data.
<! CTGRY ><LI>Memory mapped files can be much more efficient when dealing with large binary data sets or randomly accessed data.
START
http://www-106.ibm.com/developerworks/linux/library/l-simpy.html
Simulate discrete simultaneous events
(Page last updated December 2002, Added 2002-12-29, Author David Mertz, Publisher IBM).
3
<! CTGRY ><LI>[Article describes a Python package that lets you simulate systems].
<! CTGRY ><LI>Simulations and tests help you determine the limits and bottlenecks of a system.
<! CTGRY ><LI>Determine what it is that you need to optimize before starting to optimize.
START
http://www.informit.com/content/index.asp?product_id={2286C770-2C28-4E6B-8881-C1AAF2963155}
Designing and Implementing J2EE Clients
(Page last updated June 2002, Added 2002-12-29, Author Mark Johnson, Inderjeet Singh, Beth Stearns, Publisher informIT).
12
<! CTGRY ><LI>From a user's point of view, the client <em>is</em> the application. It must be useful, usable, and responsive.
<! CTGRY ><LI>Always keep in mind that the client depends on the network, and the network is imperfect: latency is non-zero; bandwidth is finite; and the network is not always reliable.
<! CTGRY ><LI>The ideal client connects to the server only when it has to, transmits only as much data as it needs to, and works reasonably well when it cannot reach the server.
<! CTGRY ><LI>Every client platform's capabilities influence an application's design. For example, a browser client cannot generate most types of graphics, the server must generate such graphics. A programmable client, on the other hand, could generate such graphics, reducing server and network load.
<! CTGRY ><LI>Typical client responsibilities include: presenting the user interface; validating user inputs; communicating with the server; managing conversational state. The more responsibilities you place on the client, the more responsive it can be.
<! CTGRY ><LI>A cost of using browser clients is potentially low responsiveness. The server handles logic, so many remote connections can be required which is a problem when latency is high or bandwidth capacity is reached.
<! CTGRY ><LI>Validating in a browser using Javascript improves responsiveness at the cost of extra bytes downloaded. Separate Javascript source files (specified using the SCRIPT element's SRC attribute) allows the browser to cache the Javascript.
<! CTGRY ><LI>Client-side validation is an optimization to improve user experience and decrease load, but you should re-validate on the server: never rely on the client exclusively to enforce data consistency.
<! CTGRY ><LI>Full programmability enables Java clients to be potentially much more responsive than browser clients. Java clients can use less bandwidth and fewer remote calls to manage the same activity as a browser.
<! CTGRY ><LI>Binary messages consume little bandwidth, an attractive feature in low-bandwidth environments.
<! CTGRY ><LI>Java clients (as opposed to browser clients) have the ability to work while disconnected, which is beneficial when latency is high or when each connection consumes significant bandwidth.
<! CTGRY ><LI>The primary consideration throughout the design of a J2EE client should be the network.
START
http://www.onjava.com/pub/a/onjava/2002/12/23/javagame.html
Intro to MicroJava Game creation
(Page last updated December 2002, Added 2002-12-29, Author David Fox, Publisher OnJava).
14
<! CTGRY ><LI>MIDP 2.0 includes better support for audio, animations, sprites, tiled backgrounds, transparency, and better graphics.
<! CTGRY ><LI>Preverification sets up hints so that the actual verification of bytecode will happen much more quickly, saving you valuable startup time.
<! CTGRY ><LI>Double-buffering guarantees that your animation will occur at the same rate no matter which phone your game is running on.
<! CTGRY ><LI>Many phones automatically double-buffer your graphics for you: you can check whether double-buffering is supported within a Canvas using the isDoubleBuffered() method.
<! CTGRY ><LI>Rolling your own double-buffering can make for smoother animations, but copying images can very slow and memory-intensive.
<! CTGRY ><LI>Some systems repaint the screen slower than the image can be copied -- these phones will show graphic flickering.
<! CTGRY ><LI>The refresh rate of most mobile phone screens is much slower than you may be used to for PC game programming. Frame rates of 4 fps (frames per second) and even slower are common.
<! CTGRY ><LI>The best way to smoothly animate sprites is to create a game loop as a separate thread, and use the System.currentTimeMillis() method to adjust the sprite's position over real time.
<! CTGRY ><LI>Remember that in the micro wrold every byte counts. Avoid hashtables and vectors, and recycle any objects you no longer need.
<! CTGRY ><LI>Instead of creating two buttons on two separate screens, try to merely change the label on an existing button.
<! CTGRY ><LI>Avoid using costly operations like string concatenations. Use a StringBuffer instead.
<! CTGRY ><LI>For user interface design, use few, large, simple components that require as few keypad presses as possible.
<! CTGRY ><LI>Garbage collect whenever resources fall too low, using: Runtime.getRuntime().gc()
<! CTGRY ><LI>Use a code packer or obfuscator to compress your bytecode as much as possible.
START
http://www.informit.com/content/index.asp?product_id={67E79D2A-486B-4325-AD8C-654B2798D121}
J2EE Enterprise Bean Basics
(Page last updated August 2002, Added 2002-12-29, Author Dale Green, Kim Haase, Eric Jendrock, Stephanie Bodoff, Monica Pawlan, Beth Stearns, Publisher informIT).
8
<! CTGRY ><LI>Use enterprise beans when an application needs to be scalable
<! CTGRY ><LI>Because stateless session beans can support multiple clients, they can offer better scalability for applications that require large numbers of clients. Typically, an application requires fewer stateless session beans than stateful session beans to support the same number of clients.
<! CTGRY ><LI>An EJB container may write a stateful session bean to secondary storage. However, stateless session beans are never written to secondary storage. Therefore, stateless beans may offer better performance than stateful beans.
<! CTGRY ><LI>Use stateless session beans when: the bean retains no client specific data; the bean performs a generic task for all clients (e.g. sending emails); the bean fetches read-only data from a database.
<! CTGRY ><LI>Only Message-driven beans can receive messages asynchronously. Asynchronous processing helps to avoid tying up server resources.
<! CTGRY ><LI>Local calls are usually faster than remote calls, so entity beans designed using local interfaces provide better performance. Local access means that the beans must run in the same JVM and the location of the bean is not transparent (unlike remote interface beans).
<! CTGRY ><LI>Distributing beans over multiple servers can improve performance for some applications, and these beans would need to have remote interfaces (rather than or as well as local interfaces).
<! CTGRY ><LI>Remote calls should be coarse-grained to reduce the access calls are required, since coarse-grained objects contain more data than fine-grained ones.
START
http://www.javalobby.org/members/jpr/methodopt.jsp
Benchmarking Method Devirtualization and Inlining
(Page last updated December 2002, Added 2002-12-29, Author Osvaldo Pinali Doederlein, Publisher JavaLobby).
2
<! CTGRY ><LI>[Article discusses the overheads of polymorphic method calls].
<! CTGRY ><LI>Tricks employed to <em>avoid</em> compiler optimizations (for microbenchmarks): Parsing, like "Integer.parseInt("3")", to hide a constant from the compiler; Avoid compile-time constants in loop bounds to prevent easy loop unrolling; Test loops are run sufficient numbers of times to avoid timer's precision error, e.g. a ~10ms precison requires each test runs for at least 1000ms; Repeat the full test within a VM invocation a few times to be nice with dynamic optimizers; Test loops should produce some data which is consumed after the loop ends so that code and values and cannot be optimized away; Instead of do-nothing code (like empty methods), use minimal code that's still difficult to compute in compile time; Know your compiler theory.
START
http://www.cs.rice.edu/CS/Systems/DynaServer/perf_scalability_ejb.pdf
Performance and Scalability of EJB Applications
(Page last updated November 2002, Added 2002-12-29, Author Emmanuel Cecchet, Julie Marguerite, Willy Zwaenepoel, Publisher OOPSLA).
8
<! CTGRY ><LI>EJB applications with session beans perform as well as a Java servlets-only implementation and an order-of-magnitude better than most of the implementations based on entity beans.
<! CTGRY ><LI>Fine-granularity access entity beans limits scalability.
<! CTGRY ><LI>Session façade beans improve performance for entity beans but only if local communication is very efficient or EJB 2.0 local interfaces are used.
<! CTGRY ><LI>Using session beans, communication costs form the major component of the execution time on the EJB server
<! CTGRY ><LI>Using entity beans, the cost of reflection affects performance severely. 
<! CTGRY ><LI>Using session façade beans, local communication cost is critically important.
<! CTGRY ><LI>EJB 2.0 local interfaces improve the performance by avoiding the communication layers for local communications.
<! CTGRY ><LI>Set the thread stack size to 32 KB using -Xss32k instead of the default thread stack size to avoid running out of space. (32 KB stack size is sufficient for non-recursive applications). (JDK 1.4.0_01. requires a 96 KB minimum stack size, -Xss96k).
START
http://dev2dev.bea.com/articlesnews/discussion/thread.jsp?thread=Ludin
Large-Scale Financial Applications & Service-Oriented Architectures
(Page last updated December 2002, Added 2002-12-29, Author Anwar Ludin, Publisher BEA).
6
<! CTGRY ><LI>[Article describes various types of enterprise architectures].
<! CTGRY ><LI>The web server parses the SOAP message, invokes a remote EJB session facade which handles local calls to session and enitity beans.
<! CTGRY ><LI>Clustering at different nodes enhances reliability and availability.
<! CTGRY ><LI>Horizontal scaling is achieved through clustering.
<! CTGRY ><LI>Adding resources such as CPUs and memory to the server machines achieves vertical scaling.
<! CTGRY ><LI>J2EE design patterns are an invaluable source of information for avoiding performance pitfalls.
START
http://dev2dev.bea.com/articlesnews/discussion/thread.jsp?thread=zadrozny_002
BEA JMS performance
(Page last updated January 2003, Added 2003-02-28, Author Peter Zadrozny, Publisher BEA).
3
<! CTGRY ><LI>The only way to understand JMS performance is by testing your own application (or a proof of concept).
<! CTGRY ><LI>Performance of asynchronous messaging systems is typically measured based on throughput, e.g. messages per second
<! CTGRY ><LI>Throughput is a measure of capacity, not speed, i.e. consumer performance, not response time.
START
http://developer.java.sun.com/developer/community/chat/JavaLive/2003/jl0121.html
Swing perf community chat
(Page last updated January 2003, Added 2003-02-28, Author Edward Ort, Publisher Sun).
17
<! CTGRY ><LI>For trees that contain many nodes, you can set the rowHeight to a fixed value, and set the largeModel property to true. On the down side, this makes your model queried much more often (very little is cached), but can improve memory and performance usage.
<! CTGRY ><LI>VariableHeightLayoutCache creates one object per visible node to track its size, whereas FixedHeightLayoutCache will only create an object per expanded node. The tradeoff between Fixed* and Variable* is that the model is queried much more often.
<! CTGRY ><LI>To garbage collect non-visible nodes, send a TreeModelEvent indicating that the nodes are no longer in the model.
<! CTGRY ><LI>Use RepaintManager.setRepaint(false) if you only need frame animation, not simple component repaints.
<! CTGRY ><LI>Gaming apps may want to minimize the number of components to maximize frame rates. Swing components have events and rendering overhead that are unnecessary need for simple sprite-based games.
<! CTGRY ><LI>The single biggest difference between so-so and really great Swing apps has to do with the way developers handle threading issues.
<! CTGRY ><LI>Create your objects lazily; if you don't need it yet, don't waste time creating it.
<! CTGRY ><LI>Watch the number of classes you create, since each class adds some amount of overhead (both memory and performance).
<! CTGRY ><LI>Translucent components or rendering looks great, but can cause some performance bottlenecks in the current releases (1.4.1).
<! CTGRY ><LI>JFileChooser on large datasets is slow in the current releases (1.4.1).
<! CTGRY ><LI>The -Xmx flag will let you specify a larger heap.
<! CTGRY ><LI>getScaledInstance() is not accelerated, so if you are concerned about performance, you might use the drawImage() call that scales during the copy, or cache a new scaled image for repeated use.
<! CTGRY ><LI>Use a profiler to determine bottlenecks.
<! CTGRY ><LI>When you call repaint on a bunch of components, the RepaintManager unions the dirty regions together and makes one giant rectangle to repaint. This is good in the general case, but for cases with LOTS and LOTS of small components, things bog down. You can create your own RepaintManager to just repaint the right parts of the screen.
<! CTGRY ><LI>Don't spawn more rendering threads. Multi- threaded rendering can at the very least buy you nothing in terms of rendering performance. But it can also lead to deadlock situations and undefined behavior.
<! CTGRY ><LI>Calls like drawLine or drawText are pretty easy for the printer to do. But images have to be scaled and printed completely, which can be very slow. Rendering to a buffer, then printing is probably bad for printing performance.
<! CTGRY ><LI>Internationalizing fastest to slowest, hold resources in: Java class; Property files; ListResourceBundle (XML)?
START
http://developer.java.sun.com/developer/EJTechTips/2003/tt0114.html#2
Preventing Repeated Operations
(Page last updated January 2003, Added 2003-02-28, Author Mark Johnson, Publisher Sun).
1
<! CTGRY ><LI>Generate a unique symbol that can be embedded as a hidden input in the form being processed to ensure that operations are processed only once.
START
http://www-106.ibm.com/developerworks/ibm/library/i-garbage1/
IBM GC 1
(Page last updated August 2002, Added 2003-02-28, Author Sam Borman, Publisher IBM).
7
<! CTGRY ><LI>If the frequency of GCs is too high prior to reaching a steady state, use verbosegc to determine the size of the heap at a steady state and set -Xms to this value.
<! CTGRY ><LI>If the heap is fully expanded and the occupancy level is greater than 70%, increase the -Xmx value so the heap is not more than 70% occupied. For best performance, try to make sure that the heap never pages. The maximum heap size should, if possible, fit in physical memory.
<! CTGRY ><LI>If, at 70% occupancy, the frequency of GCs is too great, change the setting of -Xminf. The default is 0.3, which will try to maintain 30% free space by expanding the heap. A setting of 0.4 increases this free space target to 40%, reducing the frequency of GCs.
<! CTGRY ><LI>If pause times are too long, try using -Xgcpolicy:optavgpause (introduced in 1.3.1), which reduces pause times and makes them more consistent as the heap occupancy rises. There is a cost to pay in throughput. This cost varies and will be about 5%.
<! CTGRY ><LI>Make sure the heap never pages; the maximum heap size must fit in physical memory.
<! CTGRY ><LI>Avoid finalizers. If you do use finalizers, try to avoid allocating objects in the finalizer method. A verbosegc trace shows if finalizers are being called.
<! CTGRY ><LI>Avoid compaction. Compaction is usually caused by requests for large memory allocations. Analyze requests for large memory allocations and avoid them if possible; if they are large arrays, try to split them into smaller pieces.
START
http://www-106.ibm.com/developerworks/ibm/library/i-garbage2/
IBM GC 2
(Page last updated August 2002, Added 2003-02-28, Author Sam Borman, Publisher IBM).
1
<! CTGRY ><LI>GC is done in three phases: mark, sweep, and optionally compaction. [Article describes the GC algorithm].
START
http://www-106.ibm.com/developerworks/library/i-garbage3.html
IBM GC 3
(Page last updated September 2002, Added 2003-02-28, Author Sam Borman, Publisher IBM).
1
<! CTGRY ><LI>The output from -verbosegc lets you analyze the garbage collections. [Article describes the IBM JVM -verbosegc output].
START
http://www-106.ibm.com/developerworks/ibm/library/i-gctroub/
GC
(Page last updated January 2003, Added 2003-02-28, Author Sumit Chawla, Publisher IBM).
14
<! CTGRY ><LI>Once the application has reached a steady state garbage collection, where heap expansions are no longer required, a good value for the startup heap size has been determined.
<! CTGRY ><LI>Determine the maximum heap size by stressing the application and finding the value for -Xmx that avoids an OutOfMemory error.
<! CTGRY ><LI>Keep the heap small enough to avoid paging. The heap size must never exceed the amount of physical memory installed on the system.
<! CTGRY ><LI>If the heap size is too small, there will be frequent garbage collection cycles.
<! CTGRY ><LI>The time to complete a full garbage collection cycle grows directly proportional to the size of the heap, so if the heap is too large, this can lead to long delays in the application.
<! CTGRY ><LI>A common performance-tuning measure is to make the initial heap size (-Xms) equal to the maximum heap size (-Xmx). Since no heap expansion or contraction occurs, this can result in significant performance gains in some situation.
<! CTGRY ><LI>Usually, only the applications that need to handle a surge of allocation requests keep a substantial difference between initial and maximum heap size.
<! CTGRY ><LI>If -Xms is different from -Xmx the application can run into a scenario where too many allocation failures are occurring, but the heap doesn't expand - known as heap thrashing. Increase the -Xminf and -Xmaxf values to avoid this.
<! CTGRY ><LI>Finalizers are a bad idea, and performing allocations from inside the finalizers should be avoided at all costs.
<! CTGRY ><LI>Break down large (>500 KB) requests to smaller chunks, if possible. If the heap is fragmented, it is possible to attain an out-of-memory condition when there is plenty of space if trying to allocate a very large object (i.e. large array) which cannot fit into any of the fragments.
<! CTGRY ><LI>Do not ignore the "mark stack overflow" messages. These indicate an inappropriate object retention problem.
<! CTGRY ><LI>Concurrent GC smooths the effects of GC but may reduce the throughput of an application.
<! CTGRY ><LI>Avoid -Xnocompactgc, -Xcompactgc and -Xgcthreads.
<! CTGRY ><LI>Question whether calls to System.gc() are of any use, and if they are not, remove them.
START
http://www-106.ibm.com/developerworks/java/library/j-jtp0114/
floating point and decimal numbers
(Page last updated January 2003, Added 2003-02-28, Author Brian Goetz, Publisher IBM).
1
<! CTGRY ><LI>[Article has nothing specific about performance, but if you want to improve the performance of manipulating floating point numbers, you need to know all of this].
START
http://www-106.ibm.com/developerworks/java/library/wi-devo/
Performance of networked J2ME apps
(Page last updated January 2003, Added 2003-02-28, Author Michael Abernethy, Publisher IBM).
9
<! CTGRY ><LI>Every class in the application brings with it some size overhead. You have to create constructors, variables, and functions for every class you create.
<! CTGRY ><LI>Every class has to be loaded into memory when it is used.
<! CTGRY ><LI>Cherish every byte and keep as much available as possible.
<! CTGRY ><LI>Make each screen its own function, NOT its own class.
<! CTGRY ><LI>Don't use get/set methods; make every variable a public one.
<! CTGRY ><LI>Eliminate screen location checking by using a stack and simply push() the screens when we go forward, and pop() the screens as we go backwards.
<! CTGRY ><LI>When communicating with a database, the size of the data object being sent and returned is at the top of the list of concerns.
<! CTGRY ><LI>Every request to the database should get as short a response as possible while still answering the request.
<! CTGRY ><LI>Assume: small screen sizes; slow transmission speeds; slow processing speed; and a cost for every byte transmitted; 2Kb is the maximum size of a file (RecordStore) stored locally (to maintain portability).
START
http://www-106.ibm.com/developerworks/library/x-databdopt2/
XML data binding performance
(Page last updated January 2003, Added 2003-02-28, Author Dennis M. Sosnoski, Publisher IBM).
2
<! CTGRY ><LI>The choice of XML framework used dramatically affects performance and memory usage.
<! CTGRY ><LI>[Article introduces a highly efficient XML data binding framework which avoids reflection and uses a pull parser rather than SAX2].
START
http://www.adtmag.com/article.asp?id=7164
Manage Java apps for premium performance
(Page last updated January 2003, Added 2003-02-28, Author Peter Bochner, Publisher ADTMagazine).
1
<! CTGRY ><LI>The average time for resolving a performance problem is 25.8 hours.
START
http://www.devx.com/Intel/Article/10640
Four Critical Issues for Mobile Apps Developers
(Page last updated January 2003, Added 2003-02-28, Author Alan Zeichick, Publisher DevX).
3
<! CTGRY ><LI>Mobile technology is not ubiquitous or reliable. Even when connected, a link's reliability and bandwidth can change instantly, so the software needs to be able gracefully accommodate disconnects and reconnects, with minimal impact to the quality of the user experience.
<! CTGRY ><LI>Putting all of the program logic on the server with only a user-interface stub on the client, may produce an unsatisfactory user experience due to unpredictable network availability.
<! CTGRY ><LI>When thinking "mobile," think "power miser." There's a power cost to everything: consuming CPU cycles, lighting the display, driving the speakers, operating a USB-based peripheral, even pinging across the Internet. Among the biggest power drains: memory, processor, and wireless transceiver.
START
http://www.e-promag.com/eparchive/index.cfm?fuseaction=viewarticle&ContentID=2836&websiteid=
Concise Guide to WebSphere Capacity Management
(Page last updated January 2003, Added 2003-02-28, Author Ruth Willenborg Stacy Joines, Publisher e-ProMag.com).
12
<! CTGRY ><LI>Define acceptable service levels: throughput (how many users/second or hits the site must support); response time (the wait a user experiences before receiving a response from the Web site); tolerance for outages (also called the site's availability).
<! CTGRY ><LI>The first step in establishing a service level for your Web site is to examine what the site <em>must</em> do well.
<! CTGRY ><LI>Determine the peak load. Peak load is frequently an order-of-magnitude higher than average load. Target the application to handle peak loads rather than average loads.
<! CTGRY ><LI>Capture at least the following application data: user load (concurrent HTTP sessions or servlet requests being processed), throughput (requests per second), and response time.
<! CTGRY ><LI>Capacity utilization is: how much CPU is required; the memory footprint of the application; the network capacity utilized at peak loading; the disk capacity utilized during peak loading. This data can be obtained using tools such as vmstat, iostat, or perfmon to report CPU, memory, and disk utilization and netstat for network data.
<! CTGRY ><LI>JVM capacity can be measured using ­verbosegc or other JVM memory utilization measures.
<! CTGRY ><LI>Continual garbage collecting indicates the need for a larger heap or another JVM (clone).
<! CTGRY ><LI>Underutilization of the heap allows you to reduce the JVM's maximum heap allocation and give other JVMs sharing the machine more memory as needed.
<! CTGRY ><LI>Look for high CPU utilization, excessive paging, unusually high disk I/O, network saturation.
<! CTGRY ><LI>A component running at full capacity can't handle additional work. Any component running at full utilization may constrain the overall responsiveness and throughput of the Web site.
<! CTGRY ><LI>Project future capacity requirements using historical growth data, expected additional functionality, marketing campaigns and promotions. Don't extrapolate beyond twice the performance limits measured in your existing production or test environment.
<! CTGRY ><LI>Continually test and monitor the application.
START
http://www.devx.com/enterprise/Article/10549
Web service management
(Page last updated January 2003, Added 2003-02-28, Author Justin Murray, Publisher DevX).
6
<! CTGRY ><LI>The key concerns in managing Web services begin with runtime instantiation and responsiveness to requests. These issues include:
<! CTGRY ><LI>Consider how multiple instances of the Web service may be handled concurrently, and how the load is being dealt with by one instance or shared across those instances 
<! CTGRY ><LI>Consider how the loading characteristics on a Web service can be discovered and presented.
<! CTGRY ><LI>Measures should include: the number of concurrent messages being processed; current load statistics including byte sizes.
<! CTGRY ><LI>The Web service platform must be able to identify the source and destination of SOAP messages to understand the usage of a service so that it's usage can be optimized.
<! CTGRY ><LI>Response time and uptime are measures of the quality of a Web service.
START
http://www.devx.com/enterprise/Article/10397
Applying Design Issues and Patterns in Web Services
(Page last updated January 2003, Added 2003-02-28, Author Chris Peltz, Publisher DevX).
3
<! CTGRY ><LI>When you parse an XML document using DOM, you have to parse the entire document. So, there is an up-front performance and memory hit in this approach, especially for very large XML documents. DOM is appropriate when you are dealing with more document-oriented XML files.
<! CTGRY ><LI>The SAX approach (events that invoke a callback when a given tag is found) reduces the overall memory overhead and can increase scalability if you are only processing subsets of the data.
<! CTGRY ><LI>The Façade pattern takes existing components that are already exposed and encapsulates some of the complexity into high-level, coarse-grained services that meet the specific needs of the client. This can enhance overall performance of the Web service.
START
http://www.e-promag.com/eparchive/index.cfm?fuseaction=viewarticle&ContentID=1492&websiteid=
Monitoring Performance with WebSphere
(Page last updated January 2002, Added 2003-02-28, Author Ruth Willenborg, Publisher e-ProMag.com).
16
<! CTGRY ><LI>A poorly performing Web site causes unsatisfied customers and lost revenue opportunities.
<! CTGRY ><LI>Monitoring the performance of your Web site, identifying performance problems, and quickly finding the cause of and resolving problems should be a critical part of your overall Web site operations.
<! CTGRY ><LI>If you don't measure performance, you won't know that you have problems.
<! CTGRY ><LI>If you don't know where to measure performance, you can't find problems.
<! CTGRY ><LI>If you don't know how to find the source of a problem, you can't fix problems.
<! CTGRY ><LI>Users don't care about how a website works, they care only about how fast your Web page appears.  Monitoring the end- user view tells you whether you have a publicly visible performance problem.
<! CTGRY ><LI>If your Web site is too slow, your customers will give up and leave.
<! CTGRY ><LI>You need to monitor all components, including your application servers, databases, network, and routers
<! CTGRY ><LI>Watch key metrics and compare them with normal, expected behavior. If you find deviations, investigate these areas more closely.
<! CTGRY ><LI>Three main metrics to monitor are: load (number of concurrent users); response time; throughput (requests per second).
<! CTGRY ><LI>As the number of concurrent user requests increases, throughput should grow almost linearly and request response times should remain approximately constant. When throughput starts to grow more slowly or reaches an upper bound, you have a bottleneck — typically a saturated resource.
<! CTGRY ><LI>If throughput has reached an upper bound, request response time increases linearly with the rate of requests (until a system resource becomes exhausted).
<! CTGRY ><LI>If a system resource becomes exhausted, throughput starts to degrade and response times will simultaneously increase.
<! CTGRY ><LI>The ten most commonly monitored parameters are: concurrent requests being processed (EJB and HTTP); response time (EJB/HTTP); throughput (requests serviced per second EJB/HTTP); busy/idle HTTP servers; thread pool (size and percent maxed); DB connection pool (size/percent in use); JVM heap used/free; CPU utilization; disk I/O read/write rates; paging.
<! CTGRY ><LI>Thread state profiling, e.g. dumping the thread stack, allows you to identify synchronization bottlenecks and method hotspots.
<! CTGRY ><LI>Application call flow analysis, i.e. looking at the times spent in the various components of a request, can help eliminate components as bottleneck suspects.
START
http://www-106.ibm.com/developerworks/java/library/j-pj2ee1/
Servlets, stateless session beans, or both?
(Page last updated February 2003, Added 2003-03-31, Author Kyle Gabhart, Publisher IBM).
5
<! CTGRY ><LI>The strength of the servlet architecture is in its overall efficiency and relative simplicity. EJB components, on the other hand, are more robust, and consequently more complicated to develop, maintain, and debug.
<! CTGRY ><LI>Servlet scalability is smooth and efficient: a given servlet instance handles simultaneous requests by spawning a new thread for every request and executing the service() method within each thread.
<! CTGRY ><LI>An EJB container requires a substantial amount of server power and memory.
<! CTGRY ><LI>In exchange for this higher overhead, however, EJB components provide effective management of enterprise resources, transactions, and security checks, without sacrificing too much in the way of response times and overall scalability.
<! CTGRY ><LI>The most common scalable alternative to pure servlets is to use the combination of servlets talking to stateless session beans which in turn communicate with the enterprise beans.
START
http://developer.java.sun.com/developer/JDCTechTips/2003/tt0220.html
Choosing A Collections Framework Implementation/Providing a Scalable Image Icon
(Page last updated February 2003, Added 2003-03-31, Author John Zukowski, Publisher Sun).
7
<! CTGRY ><LI>Use interfaces to define variables, allowing the actual class implementation used to be easily changed.
<! CTGRY ><LI>The additional features provided by TreeSet and LinkedHashSet add to the runtime costs.
<! CTGRY ><LI>ArrayList provides quick indexed access to its elements, and works best when elements are only added and removed at the end.
<! CTGRY ><LI>LinkedList is best when add and remove operations happen anywhere, not only at the end.
<! CTGRY ><LI>LinkedList has slower indexed operations than ArrayList.
<! CTGRY ><LI>TreeMap maintains the keys of the map in a sorted order. However, if you only need the keys sorted when you are done with the Map, sometimes it's better to simply keep everything in a HashMap while adding elements, and create a TreeMap when required since maintaining the element order when elements are changing has overhead.
<! CTGRY ><LI>On-the-fly scaling of images is practically as fast as caching and reusing a scaled image for some JVM and hardware configurations. And on-the-fly scaling requirers less memory as there is no cached instance.
START
http://www.javaworld.com/javaworld/javaqa/2003-02/01-qa-0214-threadsafe.html
Thread safety
(Page last updated February 2003, Added 2003-03-31, Author Vladimir Roubtsov, Publisher Javaworld).
1
<! CTGRY ><LI>Atomic update is insufficient to ensure timely access in multiple threads. Synchronized or volatile may be necessary depending on context.
START
http://www.neward.net/ted/weblog/index.jsp?date=20030227#1046366957815
Optimizing
(Page last updated February 2003, Added 2003-03-31, Author Ted Neward, Publisher Ted Neward).
3
<! CTGRY ><LI>Remember the 80/20 rule: 20% of the code is responsible for 80% of the time taken by the application. Focus on that 20%
<! CTGRY ><LI>Use a profiler to find the bottlenecks and speed them, not other irrelevant parts of the application.
<! CTGRY ><LI>When profiling run the system under "normal load" conditions.
START
http://www.sys-con.com/java/article.cfm?id=1811
HttpSession Objects
(Page last updated January 2003, Added 2003-03-31, Author Brian Russell, Publisher JavaDevelopersJournal).
4
<! CTGRY ><LI>The most common type of session persistence is database persistence. It provides an efficient way of saving session data and it's usually fairly easy to set up on the application server. Memory persistence in a cluster is also easy to use, if your application server supports it. The only drawback is that sessions can sometimes hold large amounts of data. Storing the session in memory reduces the amount of memory available to the other processes on the server. File system persistence can be slow at times and the file system may not always be accessible to multiple servers. (The remaining alternative, cookie persistence, is highly insecure).
<! CTGRY ><LI>The session is convenient but not always the best place to put information. Single page data should use the request scope and then forward the request from the servlet to the JSP. This causes the objects to be destroyed after the request has ended, which is after the data is displayed by the JSP. If you put the objects into the session, you would either have to remove them in your code or leave them there. Leaving objects in the session is not a good idea because you're using up valuable resources for no reason. This becomes even more of an issue when your Web site has hundreds or thousands of visitors, all of whom have a session that's loaded with objects. 
<! CTGRY ><LI>Anything that needs to exist longer than one request can be stored in the session, as long as these objects are removed as soon as they're no longer needed.
<! CTGRY ><LI>Session timeout (default usually 30 minutes of inactivity) is configured in the deployment descriptor. The HttpSession API also provides a setMaxInactiveInterval() method (and getMaxInactiveInterval() method).
START
http://www.sys-con.com/java/articlenews.cfm?id=1824 
JVM Shutdown Hooks
(Page last updated January 2003, Added 2003-03-31, Author Frank Jennings, Publisher JavaDevelopersJournal).
2
<! CTGRY ><LI>Don't run Runtime.runFinalizersOnExit() in a shutdown hook.
<! CTGRY ><LI>Add a shutdown hook thread which times the shutdown and terminates the process (using Runtime.halt()) after a reasonable interval (a few seconds at most).
START
http://www.sys-con.com/webservices/article.cfm?id=435
Optimized web services
(Page last updated January 2003, Added 2003-03-31, Author Howard D'Souza, Publisher WebservicesDevelopersJournal).
2
<! CTGRY ><LI>WSDL provides a language- and protocol-neutral way to describe a service. It is possible to have multiple definitions for a single service, allowing sophisticated clients running on a fast local network to use the alternate binding to get significantly improved performance
<! CTGRY ><LI>[Article gives an example of optimizing a Java web service by providing a definition optimized for Java clients.]
START
http://www.theserverside.com/resources/article.jsp?l=TMCBestPractices
J2ee best practices
(Page last updated January 2003, Added 2003-03-31, Author TheMiddlewareCompany, Publisher TheServerSide).
15
<! CTGRY ><LI>Modern methodologies have placed more emphasis on the design phase because it contributes tremendously to the quality, scalability and reliability of an application.
<! CTGRY ><LI>Create a limited number of expensive resources, and share them from a common pool.
<! CTGRY ><LI>Cache remote data locally. A distributed cache needs synchronization which may have high (excessive) overheads. Examples of objects worth caching include: the results of JNDI lookups; EJB home objects; JDBC datasource objects; and JMS topics and queues.
<! CTGRY ><LI>Use design patterns. Many assist performance such as: Session Façade (provide a service access layer that hides the complexity of underlying interactions, and consolidates many logical communications into one larger physical communication); Value Objects (Create a single representation of all the data that an EJB call needs. By aggregating all of the needed data for a series of remote calls, you can execute a single remote call instead of many remote ones increasing overall application performance); Service Locator (efficiently manage and obtain resources through centralizing distributed object lookups, reducing the difficulty and expense to obtain handles to components).
<! CTGRY ><LI>OPTIMIZE COMMUNICATION COSTS: Use local calls as opposed to remote; Aggregate data;Batch requests (e.g use JDBC batched statements); cache data;
<! CTGRY ><LI>BUILD A PERFORMANCE PLAN: work with your customers, both internal and external, to specify reasonable performance criteria; build in a little time during each design iteration, to work the bottlenecks out for each scenario; understand what tools that you’ll use to analyze and tune performance, e.g. load simulators, profiler generators, profile analyzers; create or rent a simulation environment; build critical test cases; in the build phase don't spend time tuning components that are not bottlenecks, only fix major performance problems; leave extensive tuning to the later test phases; stop tuning when the system achieves performance targets.
<! CTGRY ><LI>typical iterative steps for effective performance tuning: Establish performance criteria from requirements; Identify major performance problems; Identify hot spots; Find and solve majorbottlenecks only; Use regression tests; Set base lines; Verify production performance; Monitor production performance.
<! CTGRY ><LI>Plug memory leaks (i.e. inappriopriate object retention by leaving references from roots). Close resources; ensure long-lived objects stop referencing short-lived objects; ensure that any potential exception doesn't prevent cleanups from proceeding. Typical leaks include: putting an object in a collection and not removing it; not flushing stale data from caches; forgetting to unsubscribe objects; singletons holding references to objects that should be short-lived; seldom used objects being kept alive for the application duration; leaving session state alive for too long.
<! CTGRY ><LI>The major symptom of a memory leaks is that used heap space continually increases and doesn't stabilize. In this situation, use a memory profiler to find the cause of the leak.
<! CTGRY ><LI>Use the 80/20 rule (80% of a code’s execution will occur in 20% of the code); focus on performance hot spots.
<! CTGRY ><LI>Measure all of the major components of your infrastructure to locate the bottlenecks.
<! CTGRY ><LI>Improve your deployment configuration, e.g. single system to a clustered architecture, upgrade hardware, or upgrade other infrastructure (like your network).
<! CTGRY ><LI>If your database platform is the bottleneck, then it won’t make any difference how your J2EE server is deployed
<! CTGRY ><LI>When you require high availability and a more scalable performance environment, you will need to go with a clustered approach. Clustering options include: adding additional JVMs, and load balance between them; adding additional CPUs, and cluster multiple JVMs with connection routing, failover and load balancing between them; adding multiple machines, with the Application Server providing failover, clustering, load balancing and connection routing.
<! CTGRY ><LI>Clustering can degrade your caching performance because of distribution overheads (communications overhead for distributed invalidation of dirty data; with N different caches you have less of a chance for getting a hit)
START
http://www.sys-con.com/java/articleprint.cfm?id=1852
JMS security options
(Page last updated February 2003, Added 2003-03-31, Author Steve Trythall, Publisher JavaDevelopersJournal).
5
<! CTGRY ><LI>SSL is expensive because of a high cost of establishing a connection (five remote messages between the client and broker and two very costly asymmetric cryptographic operations). For a small number of long-lasting connections, this may be acceptable, but may be too expensive for multiple short connections.
<! CTGRY ><LI>Two options to reduce this security cost are: Fewer connection initiations by altering your design to reuse connections; and Message-level security, that is avoiding SSL and encrypting the messages instead.
<! CTGRY ><LI>The choice of cipher can have a large impact on messaging performance. Typically the broker will choose the strongest cipher available to it, which is often triple DES (3DES). This will seriously impact performance and may be considerably stronger security than the user had ever intended. For example triple DES is consistently double the cost of using 56-bit DES.
<! CTGRY ><LI>If performance is a concern, an RC4-based cipher is a considerably better choice than DES or 3DES. If cipher strength is of paramount importance, then a 128- or 256-bit AES is a better choice when it's supported by the JMS vendor.
<! CTGRY ><LI>Using message-level encryption allows individual messages to be encrypted once, before sending to all subscribers. This is much more efficient than SSL which which will separately encrypt every message send to each subscriber.
START
http://www.javaworld.com/javaworld/javaqa/2003-01/01-qa-0110-timing.html
Submillisecond precision from Java
(Page last updated January 2003, Added 2003-03-31, Author Vladimir Roubtsov, Publisher JavaWorld).
5
<! CTGRY ><LI>[Article provides code for evaluating the timer resolution of the underlying machine.]
<! CTGRY ><LI>Measuring times near or smaller than the system resolution can give misleading results.
<! CTGRY ><LI>System.currentTimeMilllis() is suitable only for profiling relatively long-lasting (100 ms and longer) operations.
<! CTGRY ><LI>Object.wait(long) or Thread.sleep(long) timer based systems give alternative methods that may have better resolution than using System.currentTimeMilllis(), but are unreliable.
<! CTGRY ><LI>[Article provides a native call implementation for sub-milisecond timer resolution].
START
http://www.javaspecialists.co.za/archive/Issue063.html 
Stack Trace Decoding
(Page last updated January 2003, Added 2003-03-31, Author Heinz Kabutz, Publisher JavaSpecialists).
2
<! CTGRY ><LI>JDK 1.4 stack trace classes provide faster stack tracking than JDK 1.3
<! CTGRY ><LI>[Article provides version-polymorphic stack tracing that uses the most efficient available methodology.]
START
http://www.oreilly.com/catalog/javapt2/chapter/index.html
Chapter 12 of "Java Performance Tuning", "Distributed computing".
(Page last updated January 2003, Added 2003-03-31, Author Jack Shirazi, Publisher O'Reilly).
20
<! CTGRY ><LI>Use a relay server to examine data transfers.
<! CTGRY ><LI>Reduce the number of messages transferred.
<! CTGRY ><LI>Cache data and objects to change distributed requests to local ones.
<! CTGRY ><LI>Batch messages to reduce the number of messages transferred.
<! CTGRY ><LI>Compress large transfers.
<! CTGRY ><LI>Partition the application so that methods execute where their data is held.
<! CTGRY ><LI>Multiplex communications to reduce connection overhead.
<! CTGRY ><LI>Stub out data links to reduce the amount of data required to be transferred.
<! CTGRY ><LI>Design the various components so that they can execute asynchronously from each other.
<! CTGRY ><LI>Anticipate data requirements so that data is transferred earlier.
<! CTGRY ><LI>Split up data so that partial results can be displayed.
<! CTGRY ><LI>Avoid creating distributed garbage.
<! CTGRY ><LI>Optimize database communications. Application partitioning is especially important with databases.
<! CTGRY ><LI>Use statically defined database queries.
<! CTGRY ><LI>Avoid database transactional modes if possible.
<! CTGRY ><LI>Use JDBC optimizations such as prepared statements,specific SQL requests, etc.
<! CTGRY ><LI>Try to break down the time to execute a Web Service into client, server, and network processing times,and extract the marshalling and unmarshalling times from client and server processing.
<! CTGRY ><LI>Don ’t forget about DNS resolution time for a Web Service.
<! CTGRY ><LI>Try to load-balance high-demand Web Services or provide them asynchronously.
<! CTGRY ><LI>The granularity of a Web Service is important. For more scalable and better performing Web Services, create coarser services that require fewer network requests to complete.
START
http://archive.devx.com/free/tips/tipview.asp?content_id=4044
Create objects in scope
(Page last updated February 2003, Added 2003-03-31, Author Ashutosh Shinde, Publisher DevX).
1
<! CTGRY ><LI>Create objects in the scope that they are needed to avoid redundantly creating objects when they might never be used.
START
http://www.intel.com/technology/itj/2003/volume07issue01/art03_java/p01_abstract.htm
Enterprise Java Performance: Best Practices
(Page last updated February 2003, Added 2003-03-31, Author Kingsum Chow Ricardo Morin Kumar Shiv, Publisher Intel).
34
<! CTGRY ><LI>Components of enterprise applications requiring tuning: network topology; system configuration; network I/O; disk I/O; operating system; database; clustering; application design; application server; driver choice; persistence implementation; JVM choice; JVM parameters; JVM code & JIT; cache architecture; SMP scaling.
<! CTGRY ><LI>The primary element for good performance is the application design.
<! CTGRY ><LI>Testing should take place in a performance test environment that mimics the production environment. Workloads must be representative (e.g. good user simulations, fully populated databases with realistic data) measurable (e.g. throughput, response times, and concurrency or injection rate), and repeatable (e.g. databases need to be reinstated to the original states for each test). Variations in the primary metrics should not exceed a 5% margin across measurements.
<! CTGRY ><LI>Establish a baseline, including recording all configurable parameters for that baseline.
<! CTGRY ><LI>Define performance goals for the system (e.g. the desired throughput within certain response time constraints).
<! CTGRY ><LI>The iterative tuning process are as follows: Collect data (Use stress tests and performance-monitoring tools to capture performance data as the system is exercised); Analyze the collected data to identify performance bottlenecks; Identify, explore, and select alternatives to address the bottlenecks; Apply solution; Evaluate the new performance.
<! CTGRY ><LI>Use the measured data to drive performance improvement actions (don't guess).
<! CTGRY ><LI>Make sure only one performance improvement action is applied at a time.
<! CTGRY ><LI>Follow a top-down approach to identifying bottlenecks. At the top are system-level items such as disk subsystem configuration, network devices, and database configuration; in the middle are application-level items such as transaction configuration, persistence strategies, and JDBC drivers; and at the bottom are machine-level items such as JVM configuration, multi-processor configurations, and processor caches.
<! CTGRY ><LI>Performance tools fall under the following categories: Stress test tools (repeatably simulate user activity); System monitoring tools such as Windows perfmon and Unix/Linux sar and iostat utilities (e.g. to measure CPU utilization, % processor time, disk I/O, % disk time, read/write queue lengths, I/O rates, latencies, network I/O); Application server monitoring tools (measure statistics such as queue depths, utilization of thread pools, and database connection pools); Database monitoring tools (measure statistics such as cache hit ratios, sorts rates, table scan rates, SQL response times, and database table activity); Application profilers (identify application-level hotspots and drill down to the code-level); JVM monitoring tools (such as Garbage Collection monitoring with verbosegc).
<! CTGRY ><LI>Beware the overheads of measurement tools, and try measure one components at a time (some tools can slow processing by one or more orders of magnitude on application performance i.e., 10-100X).
<! CTGRY ><LI>For batch processing the raw throughput (the amount of work done in a period of time) is the only real metric of interest.
<! CTGRY ><LI>For interactive processing the response time (the time taken for each unit of work) is very important and in some cases it may be of higher importance than the throughput.
<! CTGRY ><LI>Pipelining (breaking down the required work into many parts) allows component sections to simultaneously work on multiple parts of transactions, thereby maximizing use of system components. Pipelining is extensively used to increase throughput, but its effect on the time taken for an individual transaction is not a primary consideration.
<! CTGRY ><LI>Parallelism throws multiple resources at a task so that the task completes faster. Its primary effect is to reduce response time. Multi-threaded code is a way to achieve this in software. Hardware examples would include mirrored disks and multiple network cards.
<! CTGRY ><LI>Drawing a throughput curve can be very valuable in understanding system-level bottlenecks and helping identify potential solutions.
<! CTGRY ><LI>Reaching maximum throughput without full saturation of the CPU is an indicator of a performance bottleneck such as I/O contention, over- synchronization, or incorrect thread pool configuration.
<! CTGRY ><LI>Hitting a high response time metric with an injection rate well below CPU saturation indicates latency issues such as excessive disk I/O or improper database configuration.
<! CTGRY ><LI>Reaching application server CPU saturation indicates that there are no system-level bottlenecks outside of the application server.  Further tuning may involve tweaking the application to address specific hotspots, adjusting garbage collection parameters, or adding application server nodes to a cluster.
<! CTGRY ><LI>Reaching CPU saturation is a goal for the performance tuning process, not an operational goal. An operational CPU utilization goal would be that there is sufficient capacity available to address usage surges.
<! CTGRY ><LI>For databases: Isolate log files to dedicated devices to reduce conflicts between the sequential nature of log operations and random access to data tables; Size the sort area memory size to minimize disk sort operations; Allocate sufficient database cache memory (but avoiding swapping); Index frequently used, highly selective keys; Index foreign keys frequently used in joins; Use full-text retrieval keys where appropriate; Use disk striping (e.g., RAID 1+0) to spread I/O operations and to avoid device contention.
<! CTGRY ><LI>Use the Composite Entity design pattern. This lets coarse-grained entity beans manage a set of subordinate persistent objects, reducing the number of fine- grained remote calls); Value Object. This pattern assembles data requests into aggregated data objects to reduce remote calls to individual field get methods. It reduces the number of fine-grained remote calls and allows the transfer of more data with fewer remote calls.
<! CTGRY ><LI>Use the Session Façades design pattern. This encapsulates business logic and data access, eliminating the need for clients to access fine-grained business and data objects, thus reducing the number of remote calls. It is often used in combination with the Value Object pattern.
<! CTGRY ><LI>Use the Service Locator design pattern. This encapsulates access to directory access through JNDI and provides caching of retrieved initial contexts and factory objects (e.g., EJB Homes), reducing expensive accesses to JNDI by implementing caching strategies.
<! CTGRY ><LI>Use the Value List Handler design pattern. This encapsulates access and traversal of database-generated lists of items, improving performance by providing low-overhead list population mechanisms and implementing caching strategies.
<! CTGRY ><LI>Enterprise JavaBeans (EJB) homes and data sources should be cached to avoid repeated JNDI lookups.
<! CTGRY ><LI>Try to minimize HTTP session use. JSPs create HTTP sessions by default: override this with session="false" where appropriate.
<! CTGRY ><LI>Release database connections when they are no longer needed.
<! CTGRY ><LI>Explicitly remove unused stateful session beans.
<! CTGRY ><LI>Asynchronous messaging can enhance the scalability of the system by supporting pipelining of operations, though at a latency cost (reduced response times).
<! CTGRY ><LI>Key Application Server Parameters to tune: socket multiplexing (use where available); thread pool size (increase until fully utilized); transaction queues; database connection pools (sized one per active thread); JDBC prepared statement cache (increase size until fully utilized); session timeouts (too long will use too much memory); initial bean pool size (to optimize initial response times); bean cache size (try to avoid passivations); transaction isolation levels (use the least restrictive but still valid); JSP fragment or full-page caching (minimize dynamic page generation).
<! CTGRY ><LI>Tune the waiting queue size (server entry point at TCP level) to a high enough level that the server is at full capacity, but not so high that the server is swamped.
<! CTGRY ><LI>Tune the heap configuration.
<! CTGRY ><LI>Select the best garbage collection algorithm.
START
http://www.informit.com/isapi/product_id~{AFB2EC69-5AF9-46A4-BC64-5AB282552FF2}/content/index.asp
J2EE perf tuning 1
(Page last updated 2003 March, Added 2003-04-28, Author Steven Haines, Publisher informIT).
6
<! CTGRY ><LI>The goal of performance tuning is to service more users faster and not break down in the process. This requires maximizing: Concurrent users; Throughput (transactions performed per second); Reliability.
<! CTGRY ><LI>Load test the application running in your application server and estimate the number of concurrent users it can support before requests start failing and/or the response time does not meet your requirements.
<! CTGRY ><LI>Ensure that you have representative transactions that reflect the real use of your application; If it is not representative, there are no guarantees that your application will stand up to real users.
<! CTGRY ><LI>Tune to maximize the throughput of the server.
<! CTGRY ><LI>Tuning includes minimizing the number of failed requests. All servers will produce some failures mostly due to network latency or timeouts.
<! CTGRY ><LI>You need to tune both the application code and the application server configuration. You also need to tune any resources these two depend on, so that they are not waiting on external resources (such as the database).
START
http://www.informit.com/content/articlex.asp?product_id={F35A459F-C8EF-49D5-9F14-01A25768DBE3}
J2EE perf tuning 2
(Page last updated 2003 March, Added 2003-04-28, Author Steven Haines, Publisher informIT).
8
<! CTGRY ><LI>Analyse (expected) user activity and generate load tests based on that activity.
<! CTGRY ><LI>Measure performance metrics from the application, application server, underlying platform, and any external resources.
<! CTGRY ><LI>A load tester can: perform user-defined transactions on a system with a given frequency; control the number of simultaneous users in the load; simulate user think-time between requests; and increase the number of users in a test according to a defined rate.
<! CTGRY ><LI>Statistics to gather include: Application Server memory usage, database connection usage, thread usage; Application class or method response times, call paths, exceptional methods; Application total transaction rates and requests rates; Platform CPU, processes; Database performance; legacy system performance.
<! CTGRY ><LI>JMX provides a standard mechanism for obtaining configuration and runtime information for Java products. Application code needs to be instrumented to obtain relevant application performance statistics.
<! CTGRY ><LI>Tuning is an iterative process: Start with a configuration that "looks good," load test the system, observe performance, change parameters, and start over.
<! CTGRY ><LI>Pay particular attention to the concurrent user load and the transaction throughput of the system.
<! CTGRY ><LI>The greater the throughput, the better the performance.
START
http://www.informit.com/content/index.asp?product_id={5E454C58-FD93-4080-937C-EA4372B9D337}
J2EE Performance Tuning, Part 3: Application Server Architecture
(Page last updated 2003 April, Added 2003-04-28, Author Steven Haines, Publisher informIT).
11
<! CTGRY ><LI>The size of your connection pools can greatly impact the performance of your application. When tuning, JDBC connection pool size is one of the factors with the highest impact on your application's overall performance.
<! CTGRY ><LI>Tune to minimize activation and passivation of cached beans, and to maxmimize cache hits.
<! CTGRY ><LI>The size of bean pools must be large enough to service the requests from business processes without having to wait for a bean before it can complete its work. If the pool size is too small, there are too many processes waiting for beans; if the pool size is too large, you are using more system resources than you actually need.
<! CTGRY ><LI>Two of the most influential tuning parameters of Stateless Session Bean and Message Driven Bean pools are the size of the pools that support them and the number of beans preloaded into the pools.
<! CTGRY ><LI>Tune the session timeout to avoid retaining unused resources too long in the server, while avoiding inconveniencing slow users.
<! CTGRY ><LI>If JMS  thresholds are too low, messages will be lost; if JMS thresholds are too high and the server is used to an excessive upper limit, it can degrade the performance of your entire system.
<! CTGRY ><LI>JMS tuning parameters include: Message Delivery Mode (persistent or non-persistent); Time-to-live (defines a expiration time on a message); Transaction States; Acknowledgments.
<! CTGRY ><LI>EJB choice of method transaction levels affects performance: Supported is the lowest cost; Required is safe, but a little more costly; and Requires New is probably the most expensive. 
<! CTGRY ><LI>The size of the application server thread pool limits the amount of work your application server can do; the tradeoff is that there is a point at which the context-switching (giving the CPU to each of the threads in turn) becomes so costly that performance degrades.
<! CTGRY ><LI>The JVM heap size is important to performance. The rule-of-thumb is to give the application server all the memory that you can afford to give it on any particular machine.
<! CTGRY ><LI>Your goal when tuning garbage collection is to size the generations to maximize minor collections and minimize major collections.
START
http://www.javaworld.com/javaworld/jw-03-2003/jw-0307-j2segc.html
1.4.1 garbage collectors
(Page last updated 2003 March, Added 2003-04-28, Author Greg Holling, Publisher Javaworld).
9
<! CTGRY ><LI>[Article describes the six garbage collectors available from 1.4.1].
<! CTGRY ><LI>Incremental garbage collection (-Xincgc) provides shorter, but more frequent pauses for garbage collection. Overall garbage collection may take longer.
<! CTGRY ><LI>The parallel (multithreaded) algorithms (-XX:+UseParNewGC, -XX:+UseParallelGC) are optimized for machines with multiple CPUs.
<! CTGRY ><LI>The parallel scavenging collector (-XX:+UseParallelGC) is optimized for very large (gigabyte) heaps.
<! CTGRY ><LI>The concurrent garbage collection (-XX:+UseConMarkSweepGC) allows the stop-the-world phase to be as short as possible, which means that application pauses for garbage collection should be minimized.
<! CTGRY ><LI>If you have a single-processor client machine and are having problems with pause times in your application, try the incremental garbage collector
<! CTGRY ><LI>If you have a single-processor server machine with lots of memory and experience trouble with application pause times, try the concurrent garbage collector. 
<! CTGRY ><LI>If you have a multiprocessor machine, especially with four or more processors, try one of the parallel garbage collection algorithms. These should significantly decrease pause times. If you have lots of memory (gigabytes), use the scavenging collector; otherwise, use the copying collector. 
<! CTGRY ><LI>Don't even consider changing GC parameters until you've profiled and optimized your application. 
START
http://www.javaspecialists.co.za/archive/Issue064.html
Disassembling Java Classes
(Page last updated 2003 January, Added 2003-04-28, Author Heinz Kabutz, Publisher Kabutz).
1
<! CTGRY ><LI>Disassembling i++ and ++i show that these have identical code, so neither one can be faster than the other.
START
http://www-106.ibm.com/developerworks/java/library/j-jtp02183.html
Immutable objects
(Page last updated 2003 February, Added 2003-04-28, Author Brian Goetz, Publisher IBM).
4
<! CTGRY ><LI>You can share and cache references to immutable objects without having to copy or clone them
<! CTGRY ><LI>Immutable objects are inherently thread-safe, so you don't have to synchronize access to them across threads.
<! CTGRY ><LI>The Flyweight pattern employs a factory method to provide immutable objects, giving out the same instance for objects of the same value.
<! CTGRY ><LI>util.concurrent.CopyOnWriteArrayList creates a new array when the list is modified. This allows iterators to be immutable and therefore traversed without synchronization or risk of concurrent modification, eliminating the need to either clone the list before traversal or synchronize on the list during traversal. If traversals are much more frequent than insertions or removals such as with event listener classes, CopyOnWriteArrayList offers better performance than ArrayList.
START
http://www.theserverside.com/resources/articles/RodJohnsonInterview/article.html
Rod Johnson interview
(Page last updated 2003 February, Added 2003-04-28, Author TheServerSide, Publisher TheServerSide).
3
<! CTGRY ><LI>Several benchmarks have indicated that using entity beans usually leads to poor performance, yet many developers simply ignore this. Use entity beans when required, not just in every case.
<! CTGRY ><LI>Performance is an important business requirement, and systems that don't perform don't meet business expectations.
<! CTGRY ><LI>Sometimes a stored procedure can provide much more efficient persistence (and more concise code) than Java code.
START
http://www.theserverside.com/resources/articles/RodJohnsonInterview/JohnsonChapter4.pdf
Chapter 4 of Expert1on1, Design Techniques and Coding Standards
(Page last updated 2003 January, Added 2003-04-28, Author Rod Johnson, Publisher Wrox).
14
<! CTGRY ><LI>Program to an interface, not an implementation. There is a slight performance penalty for calling an object through an interface, but this is seldom an issue in practice, whereas the ability to change the implementing class of any application object without affecting calling code allows performance improvements to be made easily an selectively
<! CTGRY ><LI>The disadvantage of parameter consolidation is the potential creation of many objects, which increases memory usage and the need for garbage collection. Objects consume heap space; primitives don't.
<! CTGRY ><LI>Consolidating method parameters in a single object can occasionally cause performance degradation in J2EE applications if the method call is potentially remote (a call on the remote interface of an EJB), as marshaling and unmarshaling several primitive parameters will always be faster than marshaling and unmarshaling an object. However, this isn't a concern unless the method is invoked particularly often (which might indicatepoor application partitioning – we don't want to make frequent remote calls if we can avoid it).
<! CTGRY ><LI>Code that uses reflection is usually slower than code that uses normal Java object creation and method calls, however, this seldom matters in practice,  and the overhead of reflection is usually far outweighed by the time taken by the operations the invoked methods actually do.
<! CTGRY ><LI>Unnecessary optimization that prevents us from choosing superior design choices is harmful.
<! CTGRY ><LI>The overhead added by the use of reflection to populate a JavaBean when handling a web request won't be detectable.
<! CTGRY ><LI>In some cases such as when replacing a lengthy chain of if/else statements, reflection will actually improve performance.
<! CTGRY ><LI>StringBuffer is more efficient than concatenating strings with the + operator.
<! CTGRY ><LI>Console output may also seriously degrade performance when running in some servers.
<! CTGRY ><LI>Correct use of a logging framework should have negligible effect on performance
<! CTGRY ><LI>It's important to ensure that generating log messages doesn't slow down the application. If a log message might be slow to generate, it's important to check whether or not it will be displayed before generating it.
<! CTGRY ><LI>Log settings that show the class, method and line number should be switched off in production, as it's very expensive to generate this information
<! CTGRY ><LI>Writing log messages to the console or to a database will probably be much slower than writing to a file.
<! CTGRY ><LI>All logging packages should allow automatic rollover to a new log file when the existing log file reaches a certain size. Allowing too large a maximum file size may significantly slow logging, as each write to the file may involve substantial overhead.
START
http://wireless.java.sun.com/midp/ttips/optimize/
J2ME Optimization Tips and Tools
(Page last updated 2002 November, Added 2003-04-28, Author Eric D. Larson, Publisher Sun).
11
<! CTGRY ><LI>Obfuscation is a great way to reduce the size of your finished product.
<! CTGRY ><LI>Code optimization should be postponed until the very end of the development cycle.
<! CTGRY ><LI>Use System.currentTimeMillis() to accurately determine the amount of time it takes to execute a given block of code.
<! CTGRY ><LI>The J2ME Wireless Toolkit version 1.0.4 includes a profiler tool. The profiler is the main tool used to pinpoint performance problems.
<! CTGRY ><LI>java.lang.Runtime class's totalMemory() and freeMemory() methods are useful for monitoring your heap size.
<! CTGRY ><LI>The 1.0.4 version of the J2ME Wireless Toolkit allows you to set the heap size, along with storage size (for RMS), and also the VM speed emulation and network throughput emulation to help you gauge performance of your application in your development environment before you deploy.
<! CTGRY ><LI>Version 1.0.4 of the toolkit also includes a real-time memory monitor.
<! CTGRY ><LI>To see when the system is performing garbage collection, enable the toolkit's Trace Garbage Collection option.
<! CTGRY ><LI>To keep heap space free, be sure to set objects to null as soon as you're done with them.
<! CTGRY ><LI>Set an Image to null after a paint to free up a good chunk of memory.
<! CTGRY ><LI>(J2ME only tip) Explicitly call the System.gc() method to manage the GC schedule. Instead of just letting the system garbage-collect at its own discretion, try calling System.gc() when you know the user will be reading a screen and thus won't be interacting with the application immediately.
START
http://www.sys-con.com/java/article.cfm?id=1855
Java 3D
(Page last updated 2002 July, Added 2003-04-28, Author Dan Pilone, Publisher JavaDevelopersJournal).
2
<! CTGRY ><LI>Be aware of your memory allocation particularly in behaviors. To many garbage collections will destroy the 3D flow.
<! CTGRY ><LI>Carefully lay out your scenegraph and be aware that rendering is happening in a separate thread. Java 3D could render frames between updates, causing strange inter-frame effects.
START
http://www.theserverside.com/resources/article.jsp?l=ContinuousPerformance
Continuous Performance
(Page last updated 2003 April, Added 2003-05-22, Author Cody Menard, Publisher TheServerSide).
2
<! CTGRY ><LI>It isn't unusual for Java development teams to spend 20 percent of their time - up to a week every month - tediously fixing performance problems
<! CTGRY ><LI>[Article advocates continuous performance testing throughout project development, i.e. tune while you build. The trouble, from my point of view, is having performance goals availble to identify bottlenecks at all stages of development, without wasting resources on bottlenecks that don't matter in the final application].
START
http://www.sys-con.com/webservices/article.cfm?id=505
Understanding Performance in Web Service Development
(Page last updated 2003 April, Added 2003-05-22, Author Peter Varhol, Publisher Web Services Journal).
7
<! CTGRY ><LI>Individual application components may not show performance problems but, on integration, performance bottlenecks may result from interactions between components.
<! CTGRY ><LI>You need to measure throughput: the ability to accept a request and provide a response in accordance with required performance parameters. 
<! CTGRY ><LI>You should measure the performance of all of the application components simultaneously, during the same test run.
<! CTGRY ><LI>Bottlenecks can come from application components, resource or processing issues, synchronization problems, networking, or data throughput.
<! CTGRY ><LI>Carefully monitor and optimize the amount of data transmitted in each SOAP call. 
<! CTGRY ><LI>A chatty (fine-grained) interface passing less complex data may turn out to be less computationally expensive because its marshalling isn't as complex.
<! CTGRY ><LI>Chunky calls (coarse-grained) are more efficient because they reduce the overall volume of calls
START
http://www.sys-con.com/java/article.cfm?id=1944
Caching in J2EE Architectures
(Page last updated 2003 April, Added 2003-05-22, Author Helen Thomas, Publisher JDJ).
9
<! CTGRY ><LI>Caching objects in memory, called in-process caching, can be reduce object creation and destruction overhead and provide fast object access
<! CTGRY ><LI>Longer lived objects are much more expensive for the garbage collector than short-lived objects
<! CTGRY ><LI>Soft (weak) references are often used to cache objects. However they can impose a heavy overhead on the garbage collector
<! CTGRY ><LI>Article compared different types of caches: no-cache provided constant load; soft reference cache provided a sawtooth load with spikes when memory filled and the cache was reclaimed; a hard reference cache crashed with an out-of-memory error; 
<! CTGRY ><LI>A soft reference cache is more efficient than no cache if the cache does not need to be reclaimed. If the cache needs to be reclaimed regularly, a soft reference cache can be less efficient than no cache
<! CTGRY ><LI>In memory-constrained application environments, in-process caching can be detrimental to application performance because of the additional garbage collection overheads
<! CTGRY ><LI>An external cache using serialized objects, where the cache server handles all the cache and resource management, is an efficient alternative to caching objects with high external resource costs. The external cache imposes no additional garbage collection overheads on the JVM, which is the reason for it's efficiency profile.
<! CTGRY ><LI>In-memory caches also have distributed cache coherency problems which an external cache can solve or reduce.
<! CTGRY ><LI>An external cache imposes the overhead of interprocess calls and marshalling.
START
http://www.sdmagazine.com/documents/sdm0304a/
Errant Architectures
(Page last updated 2003 April, Added 2003-05-22, Author Martin Fowler, Publisher Software Development Magazine).
19
<! CTGRY ><LI>Transparency is valuable, but while many things can be made transparent in distributed objects, performance isn’t usually one of them.
<! CTGRY ><LI>Don't distribute objects for performance reasons. It doesn't work.
<! CTGRY ><LI>A procedure call within a process is extremely fast. A procedure call between two separate processes is orders of magnitude slower. Make that a process running on another machine, and you can add another order of magnitude or two.
<! CTGRY ><LI>A fine-grained interface doesn’t work well when it’s remote.
<! CTGRY ><LI>Remote calls are best coarse-grained, designed not for flexibility and extendibility but for minimizing calls.
<! CTGRY ><LI>Any object that may be used remotely should have a coarse-grained interface, while every object that isn’t used remotely can have a fine-grained interface (and should for good design).
<! CTGRY ><LI>It only makes sense to pay the remote call cost when you need to, and so you need to minimize the number of interprocess collaborations.
<! CTGRY ><LI>You can’t just take a group of classes that you design in the world of a single process, throw some distribution architecture at them and come up with a distributed model. Distributed design is more than that.
<! CTGRY ><LI>If you base your distribution strategy on classes, you’ll end up with a system that does a lot of remote calls and thus needs awkward, coarse-grained interfaces.
<! CTGRY ><LI>Even with coarse-grained interfaces on every remotable class, you’ll still end up with too many remote calls and a system that’s awkward to modify as a bonus.
<! CTGRY ><LI>Fowler's First Law of Distributed Object Design: Don’t distribute your objects.
<! CTGRY ><LI>Distribute applications using clustering: ut all the classes into a single process and then run multiple copies of that process on the various nodes
<! CTGRY ><LI>Unavoidable distribution boundaries include: client/server separation; database communications; web server/application server interface.
<! CTGRY ><LI>Remote Facades are useful for limiting distribution boundaries. Remote Facades provide a remote interface to fine-grained objects.
<! CTGRY ><LI>Don’t be transparent about a potential remote call.
<! CTGRY ><LI>Data Transfer Objects (also known as Value Objects) allows you to bundle data into fewer transfers, thus reducing remote calls.
<! CTGRY ><LI>Applications can see a significant performance improvement by replacing an XML-based interface with a (binary) remote call.
<! CTGRY ><LI>Use XML Web services only when a more direct approach isn’t possible.
<! CTGRY ><LI>Asynchronous message based systems are probably more efficient than synchronous RPC based systems.
START
http://www.jptc.org/article8.html
Performance of Lists
(Page last updated 2003 April, Added 2003-05-22, Author karschten, Publisher JPTC).
2
<! CTGRY ><LI>ArrayList is quite fast for accessing the elements in direct or random order, but for pure sequential use the LinkedList might the faster List
<! CTGRY ><LI>Vector is slower than ArrayList.
START
http://www.javaworld.com/javaworld/jw-04-2003/jw-0411-select.html
Select for high-speed networking
(Page last updated 2003 April, Added 2003-05-22, Author Greg Travis, Publisher Javaworld).
5
<! CTGRY ><LI>The stream model (java.io) is very flexible, but not alwasy the fastest. A buffer model (java.nio) allows data to be dealt with in large blocks, which can maximize throughput.
<! CTGRY ><LI>The main advantage of buffers is that they deal with data in bulk.
<! CTGRY ><LI>In some cases buffer implementations can represent system-level buffers which means you can read and write data with minimal data copying.
<! CTGRY ><LI>Blocking I/O requires one thread per concurrent open I/O stream. Threads can be resource-intensive. Under many implementations, each thread can occupy a sizeable amount of memory, even if it's not doing anything. And a performance hit can result from having too many threads.
<! CTGRY ><LI>NIO Select allows you to use one thread to handle multiple open I/O channels.
START
http://www.javaworld.com/javaworld/javaqa/2003-04/01-qa-0411-hotspot.html
Watch your HotSpot compiler go
(Page last updated 2003 April, Added 2003-05-22, Author Vladimir Roubtsov, Publisher Javaworld).
4
<! CTGRY ><LI>HotSpot comples methods after a while causing a temporary slowdown followed by faster method execution.
<! CTGRY ><LI>Use the -XX:+PrintCompilation HotSpot option to see which methods are being compiled (and when they are compiled).
<! CTGRY ><LI>Warming up code by running it for a while can be useful in some specialized situations, such as for more accurate timing.
<! CTGRY ><LI>The -XX:CompileThreshold allows you to specify how many iterations of a method are needed before it is compiled (default 1500 for client mode and 10 000 for server mode).
START
http://www7b.boulder.ibm.com/wsdd/library/techarticles/0304_polozoff/polozoff.html
Proactive Application Monitoring
(Page last updated 2003 April, Added 2003-05-22, Author Alexandre Polozoff, Publisher IBM).
19
<! CTGRY ><LI>Proactive Application Monitoring allows you to detect and respond to problems before end users are even aware that a problem exists.
<! CTGRY ><LI>Care must be taken to avoid synchronizing logging in distributed environments or serialized execution can result, severely limiting the scalability and performance of the application.
<! CTGRY ><LI>Logging to files can severely slow down an enterprise application by impacting the server's file I/O subsystem. Server caches and other mechanisms should be configured to minimize such hits, but this may still be a serious and unavoidable bottleneck, especially in high volume situations where the application is continually sending data to the log.
<! CTGRY ><LI>Application monitoring tools automate the logging process and reduce the chances that the server process will be adversely compromised.
<! CTGRY ><LI>Monitor Network latency (Ping time and network bandwidth measurements) for Timings > 1000 ms or network bandwidth maxed
<! CTGRY ><LI>Monitor CPU utilization (all servers) for utilization > 80% over x minutes
<! CTGRY ><LI>Monitor Memory utilization (all servers) for utilization > 80% over x minutes
<! CTGRY ><LI>Monitor Paging/swapping (OS level, all servers) for paging/swapping beyond background levels
<! CTGRY ><LI>Monitor File system available file space (all servers) for space > 80% used
<! CTGRY ><LI>Monitor Network components SNMP traps for Degraded counters
<! CTGRY ><LI>Monitor Java naming server using scripts to run JNDI queries for response times > 3 secs
<! CTGRY ><LI>Monitor Average servlet and JSP response times for response times > 8 secs
<! CTGRY ><LI>Monitor The EJB container average response time for response times > 900 ms
<! CTGRY ><LI>Monitor SQL INSERT, UPDATE, DELETE statements for sesponse times > 1600 ms
<! CTGRY ><LI>Monitor Gateways average response times for sesponse time > 1 second
<! CTGRY ><LI>Monitor Web server for response time retrieving 1K GIF > 1 second
<! CTGRY ><LI>Monitor Databases for average response times > 1000 ms
<! CTGRY ><LI>Monitor Message queues for average response times > 200 ms and queue depths exceeding 500
<! CTGRY ><LI>Monitor The application, e.g. for complex page requests > 10 secs
START
http://www-106.ibm.com/developerworks/linux/library/l-perf/
Practical examples for improving system responsiveness
(Page last updated 2003 April, Added 2003-05-22, Author Cameron Laird, Publisher IBM).
8
<! CTGRY ><LI>Users need to know quickly and reliably how long an activity will take. Use progress monitors, progress bars, stopwatches, etc.
<! CTGRY ><LI>You can solve many apparent performance problems just by teaching your programs to show what they're doing.
<! CTGRY ><LI>Superior algorithms often outperform inferior ones by a factor of a thousand or more.
<! CTGRY ><LI>Avoid sorting by indexing on insertion. Insertion time increases but ordered lookup is much faster.
<! CTGRY ><LI>Avoid sorting by using secondary structures to hold data in the alternative required order.
<! CTGRY ><LI>Memory impact can dominate performance if it exceeds memory boundaries (e.g. process starts paging).
<! CTGRY ><LI>An increase in main memory is an inexpensive improvement that often yields dramatic performance results.
<! CTGRY ><LI>Disk drive combinations can easily have faults which do not lead to data loss, but do lead to performance problems, such as a RAID unit that has lost one spindle. Monitor disks and use reliable ones.
START
http://www.neward.net/ted/weblog/index.jsp?date=20030307#1047038930964
Minimize Contention
(Page last updated 2003 March, Added 2003-05-22, Author Ted Neward, Publisher Neward).
6
<! CTGRY ><LI>Scalable means that we can achieve higher throughput in the system as demand grows by adding hardware to the system without redesign.
<! CTGRY ><LI>Contention refers to the conflict that arises when multiple concurrent operations try to access a shared resource.
<! CTGRY ><LI>The scalability of a given system is constrained by contention for shared resources within the system.
<! CTGRY ><LI>[Article gives a nice example of contention restraints causing performance problems].
<! CTGRY ><LI>Each operation trying to acquire exclusive access to a resource may also already hold exclusive access on other resources, forcing even more concurrent operations to wait, increasing the scope of the bottleneck, and system throughput seriously suffers as a result.
<! CTGRY ><LI>Eliminate or minimize that contention, and the system becomes more scalable.
START
http://www.ftponline.com/portals/compuware/java/features/varhol/default.asp
6 Tips for High-Performance Java Apps
(Page last updated 2003 March, Added 2003-05-22, Author Peter Varhol, Publisher ftponline).
6
<! CTGRY ><LI>The garbage collector can be a significant performance bottleneck so allocate memory wisely.
<! CTGRY ><LI>The more memory your code allocates, the more often the garbage collector has to run, and for longer time periods.
<! CTGRY ><LI>Use profiling tools.
<! CTGRY ><LI>Threads can perform actions independently and provide the appearance of faster overall performance.
<! CTGRY ><LI>Poorly designed thread use can lead to unnecessary memory consumption and deadlocks.
<! CTGRY ><LI>Test methodically.
START
http://servlet.java.sun.com/javaone/resources/content/sf2003/conf/sessions/pdfs/3054.pdf
Case Study of a High-Volume Account Servicing Application Using J2EE Technology
(Page last updated June 2003, Added 2003-06-25, Author Carol McDonald, Joseph Paulchell, Publisher Sun).
6
<! CTGRY ><LI>High volume is: peak 23000 concurrent sessions, average 30 transactions per second, 24/7 site, (still growing rapidly).
<! CTGRY ><LI>Architecture: browser->load balancer->web server (static content/encryption)->app server cluster (servlets/JSP/EJB)->DB/Legacy systems
<! CTGRY ><LI>[Architecture for high performance Enterprise system covered in good detail in this article].
<! CTGRY ><LI>Architecture: Presentation Layer (Struts)->Decoupling Layer: Front-end user data cache (recently used data) and business logic proxies (increases decoupling and flexibility)->Business Logic Layer: Stateless Session Beans ONLY (Facade and Delegate patterns used); service beans (non-business logic) and business beans->Data Access Layer: Connection pools and Object/Relational Mapping->Remote Servers Layer: Separates Vendor and Native Code interfaces from core application
<! CTGRY ><LI>Patterns used: Facades, Factories, Proxies, Adapters, Singletons, Load-on-Demand, Caching
<! CTGRY ><LI>Each layer can be timed separately to enable performance testing
START
http://servlet.java.sun.com/javaone/resources/content/sf2003/conf/sessions/pdfs/3014.pdf
How J2EE Technology, Open Standards and Open Source Brought You the Architecture of the Miller Time Network
(Page last updated June 2003, Added 2003-06-25, Author John Haro, Publisher Sun).
3
<! CTGRY ><LI>Value List Handler avoids Repeated database calls, handles search capabolities, caches results and provides a filterable and traversable result set
<! CTGRY ><LI>Updatable Value Objects encapsulates business data for efficient transfer between tiers
<! CTGRY ><LI>Performance testing is important.
START
http://servlet.java.sun.com/javaone/resources/content/sf2003/conf/sessions/pdfs/1440.pdf
Graphics Performance Writing Optimized Client Applications
(Page last updated June 2003, Added 2003-06-25, Author Scott Violet, Joshua Outwater, Chet Haase, Publisher Sun).
17
<! CTGRY ><LI>Use profiling tools to find the hotspots and fix the problems.
<! CTGRY ><LI>Lazy Loading is the key to a fast startup: Load just enough to show your app; Use a splash screen for immediate feedback; load only those classes immediately needed.
<! CTGRY ><LI>Use -verbose to see what classes are being loaded at startup amd remove or delay loading of those not needed.
<! CTGRY ><LI>Static variables are initialized BEFORE main is called, and may load classes unnecessarily or too early.
<! CTGRY ><LI>Determining what caused a class to load: remove that class from rt.jar, then an exception will be thrown showing what caused the removed class to try to be loaded.
<! CTGRY ><LI>Lazily: Populate JTabbedPanes; Create JInternalFrames; create display representation.
<! CTGRY ><LI>Using threads is the key to a responsive GUI; Avoid heavy processing on event dispatching thread; Use SwingWorker; Use invokeLater or invokeAndWait to schedule processing; Only access widgets in the GUI thread.
<! CTGRY ><LI>Consider overriding: revalidate, repaint, validate, firePropertyChange to do nothing (Look at DefaultTableCellRenderer for details).
<! CTGRY ><LI>Create your own model implementation: Application specific models outperform defaults.
<! CTGRY ><LI>Use widget constructors that take models, and populate the model BEFORE creating the widget.
<! CTGRY ><LI>When tiling small images, create a bigger image to reduce amount of paint calls.
<! CTGRY ><LI>Managed Images (Component.createImage()/GC.createCompatibleImage()/Toolkit.getImage()) use hardware copies to map the offscreen image to screen - much faster than BufferedImage (BufferedImage and other images managed in 1.5+).
<! CTGRY ><LI>GC.createCompatibleImage() will return the most efficient image format for copying to the screen.
<! CTGRY ><LI>Graphics.drawImage() is where acceleration takes place (for subsequent draws).
<! CTGRY ><LI>Draw using the simplest drawing primitive that achieves the effect. Draw complex shapes into an image for repeated rendering.
<! CTGRY ><LI>Rectangles are much faster than wide lines.
<! CTGRY ><LI>Use GraphicsDevice.getDefaultConfiguration() rather than GraphicsDevice.getConfigurations()[0].
START
http://servlet.java.sun.com/javaone/resources/content/sf2003/conf/sessions/pdfs/2879.pdf
Performance Tuning the Sun ONE Application Server
(Page last updated June 2003, Added 2003-06-25, Author David Dagastine, Eileen Loh, Scott Oaks, Martin Zaun, Publisher Sun).
22
<! CTGRY ><LI>Out of the box configuration is not optimal for performance.
<! CTGRY ><LI>Correctly size the overall heap: -Xms/-Xmx.
<! CTGRY ><LI>Too small heap: More frequent GCs; May run out of memory; Overall throughput decreased.
<! CTGRY ><LI>Too large heap: Long pauses during full GCs; Unnecessary memory use.
<! CTGRY ><LI>Sizing the young generation (-XX:NewRatio=n, -XX:NewSize=n, -XX:MaxNewSize=n) too big forces full GCs.
<! CTGRY ><LI>-XX:+AggressiveHeap Automatically sizes heap (Targets long-running memory allocation intensive jobs; Uses throughput collector; Size of initial heap based on system memory; Automatically sizes generations).
<! CTGRY ><LI>Use parallel GC when average response and througput are most important (-XX:+ParNewGC).
<! CTGRY ><LI>Use concurrent GC when low pause times are most important (-XX:+UseConcMarkSweepGC).
<! CTGRY ><LI>Web container: Pay attention to HTTP Traffic; Optimize output streams; Cache common queries.
<! CTGRY ><LI>HTTP tunables: Increase acceptor threads if lots of short-lived connections; Decrease RqThrottle unless you have lots of CPUs; Decrease KeepAliveTimeout if clients disconnect a lot.
<! CTGRY ><LI>KeepAliveQueryMeanTime and KeepAliveQueryMaxSleepTime: reduce if CPU idle else increase.
<! CTGRY ><LI>In servlets, set content length; for JSP pages, set UseOutputStreamSize.
<! CTGRY ><LI>Turn off page reloading &lt;jsp-config>&lt;property name="reload-interval" value="-1"/>&lt;/jsp-config>.
<! CTGRY ><LI>LD_PRELOAD=/usr/lib/libmtmalloc.so bin/startserv increases SSL performance.
<! CTGRY ><LI>Optimize pool and cache configuration parameters: commit-option, max-cache-size, cache-idle-timeout-in-seconds, removal-timeout-in-seconds, steady-pool-size, max-pool-size, pool-idle-timeout-in-seconds, (pool-,cache-)resize-quantity.
<! CTGRY ><LI>Monitor: total-beans-created/destroyed; num-beans-in-pool; GC activity, memory footprint; cache-misses/hits ratios; num-passivations (stateful session beans); total-beans-in-cache.
<! CTGRY ><LI>Increase bean pool size when observing excessive creation and deletion of bean instances.
<! CTGRY ><LI>Decrease bean pool size when accumulating a steadily large number of instances in pool.
<! CTGRY ><LI>Increase cache size until a good cache-hits rate is reached.
<! CTGRY ><LI>Decrease cache size if accumulating a large number of instances and cache hit rate doesn’t improve.
<! CTGRY ><LI>Chose optimistic concurrency for CMPs with read-mostly access.
<! CTGRY ><LI>Use statement caching if possible.
START
http://servlet.java.sun.com/javaone/resources/content/sf2003/conf/sessions/pdfs/3600.pdf
Optimizing EJB Performance in High-Volume Data-Warehousing Applications Patterns, Strategies and Best Practices
(Page last updated June 2003, Added 2003-06-25, Author Samrat Ray, Arunabh Hazarika, Publisher Sun).
5
<! CTGRY ><LI>Use batch inserts for large updates.
<! CTGRY ><LI>Cache data from small tables.
<! CTGRY ><LI>Use Optimistic Concurrency in place of higher isolation levels. Handle Optimistic Concurrency violations.
<! CTGRY ><LI>Read-mostly data lends itself easily to caching.
<! CTGRY ><LI>Use a timer-based invalidation when the data does not have to be real time; Use programmatic invalidation for real-time data.
START
http://servlet.java.sun.com/javaone/resources/content/sf2003/conf/sessions/pdfs/3264.pdf
A Billion Hits a Day
(Page last updated June 2003, Added 2003-06-25, Author Deepak Alur, Rajmohan Krishnamurthy, Arnold Goldberg, Publisher Sun).
10
<! CTGRY ><LI>EBay 1,000 million hits/day => 11,500 hits per second (2005 estimate, 2002 reality 380M/day, 4500/second).
<! CTGRY ><LI>Scaling achieved by: using patterns; performance testing; capacity planning; configuration tuning; redundant infrastructure.
<! CTGRY ><LI>Minimize server-side state.
<! CTGRY ><LI>Don't use server affinity.
<! CTGRY ><LI>Parition the database horizontally and vertically.
<! CTGRY ><LI>Optimize persistency by generating optimal specialized code.
<! CTGRY ><LI>Use data caching
<! CTGRY ><LI>Use lazy loading
<! CTGRY ><LI>Target the dataset to fetch data accurately (minimizing round trips or data transferred or both).
<! CTGRY ><LI>Target end-tier data store location late, i.e. make the location dynamically choosable (horizontal scalability, failover).
START
http://servlet.java.sun.com/javaone/resources/content/sf2003/conf/sessions/pdfs/3099.pdf
Measuring Java 2 Platform, Enterprise Edition (J2EE) Application Performance in Production
(Page last updated June 2003, Added 2003-06-25, Author Geoff Vona, Publisher Sun).
9
<! CTGRY ><LI>Basic Metrics: Response Time (R); Throughput (X); Resource Utilization (U). R tends to increase with load; X and U increase linearly until U is maxed out; Once U is maximum, R and X plateau or decrease. [This is the first time I have every wanted to have a graphic as a tip. Check out page 10 for a crystal clear picture of the behavior of these metrics].
<! CTGRY ><LI>Response Time reflects the end-user experience. Can vary significantly from Locking, resource contention, container activity. Deviation implies will be outliers - and these outliers will generate complaints.
<! CTGRY ><LI>Throughput Measures the number of transactions that are executed by the system over a period of time: A measure of the system’s capacity for load
<! CTGRY ><LI>A common performance goal is to target maximizing throughput, while maintaining 95% of requests having reposnse times below a given value.
<! CTGRY ><LI>Measure performance! Don't guess.
<! CTGRY ><LI>Try to change only one thing between measurements.
<! CTGRY ><LI>Metrics to measure: client response time; OS CPU utilization; OS memory use; OS disk activity; JVM heap usage; JVM locks; JVM thread call stacks; JVM method exclusive time; JVM memory size; Servlet response times; JSP response times; EJB utilization; EJB response times; JDBC utilization & response times; JMS utilization & response times; JCA utilization & response times; JNDI utilization; Transaction rates and duration; Threads utilization; Queue sizes and throughout; General configuration; [article also covers Weblogic/WebSphere/JBoss/Oracle metrics].
<! CTGRY ><LI>[Discusses various ways of obtaining performance measurements: protocol sniffers; logs; manual instrumentation; automatic bytecode insertion]
<! CTGRY ><LI>Understand the impact of your measurements!
START
http://servlet.java.sun.com/javaone/resources/content/sf2003/conf/sessions/pdfs/3153.pdf
Garbage Collection in the Java HotSpot Virtual Machine
(Page last updated June 2003, Added 2003-06-25, Author John Coomes, Tony Printezis, Publisher Sun).
11
<! CTGRY ><LI>new java.lang.Object() is about 10 native instructions (with Sun 1.4.1 JVM).
<! CTGRY ><LI>Stop-the-world GC in HotSpot does not stop threads running in native code.
<! CTGRY ><LI>Generational GC assumes that (i.e. is tuned for) most objects being short-lived and few references from old to young objects
<! CTGRY ><LI>Parallel (-XX:+UseParallelGC) and concurrent (-XX:+UseConcMarkSweepGC) GCs also now available. 
<! CTGRY ><LI>Finalization delays object allocation and garbage collection of an object.
<! CTGRY ><LI>Limit the number of finalizable objects. Reorganize classes so finalizable object holds no extra data.
<! CTGRY ><LI>Beware when extending finalizable objects in standard libraries: GUI elements, nio buffers.
<! CTGRY ><LI>Use java.lang.ref.WeakReference to avoid finalizers but still get object cleanup where necessary
<! CTGRY ><LI>Use Object Pools only if allocation or initialization is expensive.
<! CTGRY ><LI>Size the heap appropriately: the maximum should be larger than working set but smaller than available physical memory.
<! CTGRY ><LI>Avoid calls to java.lang.System.gc().
